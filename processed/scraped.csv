,fname,text
0,n\setu,"n\setu. # -*- coding: utf-8 -*- __author__ = 'yangyang' import setuptools # from py-spy/setup.py try:  from wheel.bdist_wheel import bdist_wheel as _bdist_wheel, get_platform  class bdist_wheel(_bdist_wheel):   def finalize_options(self):    _bdist_wheel.finalize_options(self)    # Mark us as not a pure python package (we have platform specific ctpse lib)    if self.plat_name != ""any"":     self.root_is_pure = False     plat_name = (self.plat_name or get_platform()).replace('-', '_').replace('.', '_')     if plat_name == ""linux_x86_64"" or plat_name == ""manylinux1_x86_64"":      self.distribution.package_data[""""] = [""ctpse/LinuxDataCollect64.so""]     elif plat_name == ""win32"":      self.distribution.package_data[""""] = [""ctpse/WinDataCollect32.dll""]     elif plat_name == ""win_amd64"":      self.distribution.package_data[""""] = [""ctpse/WinDataCollect64.dll""]   def get_tag(self):    # this set's us up to build generic wheels.    python, abi, plat = _bdist_wheel.get_tag(self)    # We don't contain any python source    python, abi = 'py3', 'none'    return python, abi, plat except ImportError:  bdist_wheel = None with open(""README.md"", mode=""r"", encoding='utf-8') as fh:  long_description = fh.read() setuptools.setup(  name='tqsdk',  version=""3.2.12"",  description='TianQin SDK',  author='TianQin',  author_email='tianqincn@gmail.com',  long_description=long_description,  long_description_content_type=""text/markdown"",  url='https://www.shinnytech.com/tqsdk',  packages=setuptools.find_packages(),  zip_safe=False,  python_requires='>=3.6.4',  install_requires=[""websockets>=8.1"", ""requests"", ""numpy"", ""pandas>=1.1.0"", ""scipy"", ""simplejson"", ""aiohttp"",      ""certifi"", ""pyjwt"", ""psutil"", ""shinny_structlog"", ""sgqlc"", ""filelock""],  cmdclass={'bdist_wheel': bdist_wheel},  classifiers=[   ""Programming Language :: Python :: 3"",   ""License :: OSI Approved :: Apache Software License"",   ""Operating System :: OS Independent"",  ],  include_package_data=True ) "
1,n\doc\con,"n\doc\con. # -*- coding: utf-8 -*- import os import sys sys.path.insert(0, os.path.abspath('../')) # -- General configuration ------------------------------------------------ # If your documentation needs a minimal Sphinx version, state it here. # # needs_sphinx = '1.0' # Add any Sphinx extension module names here, as strings. They can be # extensions coming with Sphinx (named 'sphinx.ext.*') or your custom # ones. extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'sphinx.ext.githubpages', 'autodocsumm'] smartquotes = False # 设置 graphviz_dot 路径 graphviz_dot = 'dot' # 设置 graphviz_dot_args 的参数，这里默认了默认字体 # graphviz_dot_args = ['-Gfontname=Georgia', #      '-Nfontname=Georgia', #      '-Efontname=Georgia'] # 输出格式，默认png，这里我用svg矢量图 graphviz_output_format = 'svg' # Add any paths that contain templates here, relative to this directory. templates_path = ['_templates'] # The suffix(es) of source filenames. # You can specify multiple suffix as a list of string: # # source_suffix = ['.rst', '.md'] source_suffix = '.rst' # The master toctree document. master_doc = 'index' # General information about the project. project = u'TianQin Python SDK' copyright = u'2018-2022, TianQin' author = u'TianQin' # The version info for the project you're documenting, acts as replacement for # |version| and |release|, also used in various other places throughout the # built documents. # # The short X.Y version. version = u'3.2.12' # The full version, including alpha/beta/rc tags. release = u'3.2.12' # The language for content autogenerated by Sphinx. Refer to documentation # for a list of supported languages. # # This is also used if you do content translation via gettext catalogs. # Usually you set ""language"" from the command line for these cases. language = ""zh"" # List of patterns, relative to source directory, that match files and # directories to ignore when looking for source files. # This patterns also effect to html_static_path and html_extra_path exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store'] # The name of the Pygments (syntax highlighting) style to use. pygments_style = 'sphinx' # If true, `todo` and `todoList` produce output, else they produce nothing. todo_include_todos = False # -- Options for HTML output ---------------------------------------------- # The theme to use for HTML and HTML Help pages. See the documentation for # a list of builtin themes. # html_theme = 'classic' html_theme = 'sphinx_rtd_theme' html_theme_options = {  'analytics_id': 'UA-18345151-2', } # html_sidebars = { # '**': ['localtoc.html','globaltoc.html','relations.html', 'sourcelink.html', 'searchbox.html'], # 'using/windows': ['windowssidebar.html', 'searchbox.html'], # } # html_sidebars = { #  '**': [ #   'about.html', #   'navigation.html', #   'relations.html', #   'searchbox.html', #   'donate.html', #  ] # } # Add any paths that contain custom static files (such as style sheets) here, # relative to this directory. They are copied after the builtin static files, # so a file named ""default.css"" will overwrite the builtin ""default.css"". html_static_path = ['_static'] def setup(app):  app.add_js_file(""baidu.js"") # -- Options for HTMLHelp output ------------------------------------------ # Output file base name for HTML help builder. htmlhelp_basename = 'TianQinPythonSDKdoc' # -- Options for LaTeX output --------------------------------------------- on_rtd = os.environ.get('READTHEDOCS', None) == 'True' if on_rtd:  latex_elements = {  # The paper size ('letterpaper' or 'a4paper').  #'papersize': 'letterpaper',  # The font size ('10pt', '11pt' or '12pt').  #'pointsize': '10pt',  # Additional stuff for the LaTeX preamble.  'preamble': r'''   \hypersetup{unicode=true}   \usepackage{CJKutf8}   \DeclareUnicodeCharacter{00A0}{\nobreakspace}   \DeclareUnicodeCharacter{2203}{\ensuremath{\exists}}   \DeclareUnicodeCharacter{2200}{\ensuremath{\forall}}   \DeclareUnicodeCharacter{2286}{\ensuremath{\subseteq}}   \DeclareUnicodeCharacter{2713}{x}   \DeclareUnicodeCharacter{27FA}{\ensuremath{\Longleftrightarrow}}   \DeclareUnicodeCharacter{221A}{\ensuremath{\sqrt{}}}   \DeclareUnicodeCharacter{221B}{\ensuremath{\sqrt[3]{}}}   \DeclareUnicodeCharacter{2295}{\ensuremath{\oplus}}   \DeclareUnicodeCharacter{2297}{\ensuremath{\otimes}}   \begin{CJK}{UTF8}{gbsn}   \AtEndDocument{\end{CJK}}   ''',  } else:  latex_elements = {   'papersize' : 'a4paper',   'utf8extra' : '',   'inputenc' : '',   'babel'  : r'''\usepackage[english]{babel}''',   'preamble' : r'''   \usepackage{ctex}   ''',  } # Grouping the document tree into LaTeX files. List of tuples # (source start file, target name, title, # author, documentclass [howto, manual, or own class]). latex_documents = [  (master_doc, 'TianQinPythonSDK.tex', u'TianQin Python SDK Documentation',  u'TianQIn', 'manual'), ] # -- Options for manual page output --------------------------------------- # One entry per manual page. List of tuples # (source start file, name, description, authors, manual section). man_pages = [  (master_doc, 'tianqinpythonsdk', u'TianQin Python SDK Documentation',  [author], 1) ] # -- Options for Texinfo output ------------------------------------------- # Grouping the document tree into Texinfo files. List of tuples # (source start file, target name, title, author, # dir menu entry, description, category) texinfo_documents = [  (master_doc, 'TianQinPythonSDK', u'TianQin Python SDK Documentation',  author, 'TianQinPythonSDK', 'TianQin Python SDK.',  'Miscellaneous'), ] # Example configuration for intersphinx: refer to the Python standard library. intersphinx_mapping = {'https://docs.python.org/': None} autodoc_member_order = ""bysource"" autoclass_content = 'both' "
2,n\doc\enterprise,"n\doc\enterprise. .. _enterprise: TqSdk2 企业版 ================================================= 除了 TqSdk 专业版以外，我们还提供 TqSdk2 企业版本来供用户使用，如果想了解专业版和企业版的区别，`可以点击查看 TqSdk2 文档 <https://doc.shinnytech.com/tqsdk2/latest/advanced/for_tqsdk1_user.html#tqsdk2-tqsdk>`_ 如果想使用 TqSdk2 企业版功能，可以点击 `个人中心 <https://account.shinnytech.com/>`_ 申请15天试用或购买 企业版本提供专业版的全部功能 :ref:`profession` ，且 TqSdk 和 TqSdk2 专业版权限通用，此外还包含如下功能 TqSdk2 直连功能 ------------------------------------------------- 在 TqSdk2 中除了通过中继模式接入期货公司以外，还提供用户通过直连模式接入任意一家指定期货公司 除了接入指定期货公司的优点以外，直连模式还带来了一下好处: * 交易指令直达期货公司，省去中继服务器路径，交易延迟平均减少10ms左右 * 减少了交易服务器依赖，程序运行稳定性提升 .. _tqrohon: TqSdk2 连接资管平台功能 ------------------------------------------------- TqSdk2 提供了资管平台的对接支持，支持用户连接到指定资管平台 以连接融航的模拟服务器为例:: from tqsdk2 import TqApi, TqAuth, TqRohon acc = TqRohon(td_url=""tcp://129.211.138.170:10001"", broker_id=""RohonDemo"", app_id=""shinny_tqsdk_01"", auth_code= ""qZWmA7iTXaEO2w40"", user_name=""融航模拟账户"", password=""融航模拟账户密码"") api = TqApi(acc,auth= TqAuth(""信易账户"",""账户密码"")) 其中融航模拟的 **模拟账户** 和 **模拟账户密码** 需要自行和融航联系获取，其他参数在融航模拟下为 td_url=""tcp://129.211.138.170:10001"" broker_id=""RohonDemo"" app_id=""shinny_tqsdk_01"" auth_code=""qZWmA7iTXaEO2w40"" 融航实盘情况下将对应信息换成实盘信息即可 资管平台连接模式的详细介绍，请点击 :py:class:`~tqsdk2.api.TqRohon` . "
3,n\doc\index,"n\doc\index. .. image:: logo.png :width: 600 px :align: center | .. _pysdk: TianQin Python Sdk User Guide ======================================== 本文档是 TqSdk 的使用说明. 从 TqSdk 中的一些关键概念开始, 逐步介绍如何充分利用 TqSdk 全部功能。 .. toctree::  :maxdepth: 2  intro.rst  quickstart.rst  usage/index.rst  demo/index.rst  reference/index.rst  advanced/index.rst  dev/index.rst  profession.rst  enterprise.rst  qa.rst  version.rst "
4,n\doc\intro,"n\doc\intro. .. _intro: TqSdk 介绍 ================================================= TqSdk是什么 ------------------------------------------------- TqSdk 是一个由 `信易科技 <https://www.shinnytech.com>`_ 发起并贡献主要代码的开源 python 库. 依托 `快期多年积累成熟的交易及行情服务器体系 <https://www.shinnytech.com/diff>`_ , TqSdk 支持用户使用很少的代码量构建各种类型的量化交易策略程序, 并提供包含 历史数据-实时数据-开发调试-策略回测-模拟交易-实盘交易-运行监控-风险管理 的全套解决方案:: from tqsdk import TqApi, TqAuth, TqAccount, TargetPosTask api = TqApi(TqAccount(""H海通期货"", ""4003242"", ""123456""), auth=TqAuth(""信易账户"", ""账户密码""))  # 创建 TqApi 实例, 指定交易账户 q_1910 = api.get_quote(""SHFE.rb1910"")       # 订阅近月合约行情 t_1910 = TargetPosTask(api, ""SHFE.rb1910"")     # 创建近月合约调仓工具 q_2001 = api.get_quote(""SHFE.rb2001"")       # 订阅远月合约行情 t_2001 = TargetPosTask(api, ""SHFE.rb2001"")     # 创建远月合约调仓工具 while True:  api.wait_update()           # 等待数据更新  spread = q_1910.last_price - q_2001.last_price  # 计算近月合约-远月合约价差  print(""当前价差:"", spread)  if spread > 250:  print(""价差过高: 空近月，多远月"")         t_1910.set_target_volume(-1)        # 要求把1910合约调整为空头1手  t_2001.set_target_volume(1)        # 要求把2001合约调整为多头1手  elif spread < 200:  print(""价差回复: 清空持仓"")        # 要求把 1910 和 2001合约都调整为不持仓  t_1910.set_target_volume(0)  t_2001.set_target_volume(0) 要快速了解如何使用TqSdk, 可以访问我们的 :ref:`quickstart` 系统架构 ---------------------------------------------------- .. raw:: html <svg xmlns=""http://www.w3.org/2000/svg"" xmlns:xlink=""http://www.w3.org/1999/xlink"" version=""1.1"" width=""761px"" viewBox=""-0.5 -0.5 761 221"" style=""max-width:100%;max-height:221px;""><defs/><g><path d=""M 620 60 L 620 40"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><a xlink:href=""https://github.com/shinnytech/open-md-gateway""><rect x=""480"" y=""60"" width=""280"" height=""40"" fill=""none"" stroke=""#d6b656""/><g transform=""translate(569.5,66.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""100"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 102px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><div><a href=""https://github.com/shinnytech/open-md-gateway"">Open Md Gateway</a></div><div><a href=""https://github.com/shinnytech/open-md-gateway"">行情网关</a></div></div></div></foreignObject><text x=""50"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a><a xlink:href=""https://github.com/shinnytech/open-trade-gateway""><rect x=""0"" y=""60"" width=""280"" height=""40"" fill=""none"" stroke=""#d6b656""/><g transform=""translate(82.5,66.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""114"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 116px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><a href=""https://github.com/shinnytech/open-trade-gateway"">Open Trade Gateway<br />交易中继网关</a><br /></div></div></foreignObject><text x=""57"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a><rect x=""0"" y=""0"" width=""280"" height=""40"" fill=""none"" stroke=""#36393d""/><g transform=""translate(84.5,6.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""110"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 110px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">期货公司交易系统<br />CTP / FEMAS / UFX<br /></div></div></foreignObject><text x=""55"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">期货公司交易系统&lt;br&gt;CTP / FEMAS / UFX&lt;br&gt;</text></switch></g><rect x=""480"" y=""0"" width=""280"" height=""40"" fill=""none"" stroke=""#36393d""/><g transform=""translate(577.5,13.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""84"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 85px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">交易所行情系统<br /></div></div></foreignObject><text x=""42"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">交易所行情系统&lt;br&gt;</text></switch></g><path d=""M 140 60 L 140 40"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10""/><path d=""M 380 120 L 140 100"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10""/><path d=""M 380 120 L 620 100"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10""/><a xlink:href=""http://doc.shinnytech.com/diff/latest/""><rect x=""0"" y=""120"" width=""760"" height=""40"" rx=""6"" ry=""6"" fill=""none"" stroke=""#b85450""/><g transform=""translate(352.5,133.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""54"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 55px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><a href=""https://github.com/shinnytech/diff"">DIFF 协议</a></div></div></foreignObject><text x=""27"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a><path d=""M 380 180 L 380 160"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10""/><a xlink:href=""https://github.com/shinnytech/tqsdk-python""><rect x=""320"" y=""180"" width=""120"" height=""40"" fill=""#dae8fc"" stroke=""#6c8ebf""/><g transform=""translate(362.5,193.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""34"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 36px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><a href=""https://github.com/shinnytech/tqsdk-python"">TqSdk</a><br /></div></div></foreignObject><text x=""17"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a></g></svg> * `行情网关 (Open Md Gateway) <https://github.com/shinnytech/open-md-gateway>`_ 负责提供实时行情和历史数据 * `交易中继网关 (Open Trade Gateway) <https://github.com/shinnytech/open-trade-gateway>`_ 负责连接到期货公司交易系统 * 这两个网关统一以 `Diff协议 <https://doc.shinnytech.com/diff/latest>`_ 对下方提供服务 * TqSdk按照Diff协议连接到行情网关和交易中继网关, 实现行情和交易功能 功能要点 ---------------------------------------------------- TqSdk 提供的功能可以支持从简单到复杂的各类策略程序. * 提供当前所有可交易合约从上市开始的 **全部Tick数据和K线数据** * 支持数十家期货公司的 **实盘交易** * 支持 **模拟交易** * 支持 **Tick级和K线级回测**, 支持 **复杂策略回测** * 提供近百个 **技术指标函数及源码** * 用户无须建立和维护数据库, 行情和交易数据全在 **内存数据库** , 无访问延迟 * 优化支持 **pandas** 和 **numpy** 库 * 无强制框架结构, 支持任意复杂度的策略, 在一个交易策略程序中使用多个品种的K线/实时行情并交易多个品种 .. _linear_framework: 编程风格 ---------------------------------------------------- TqSdk使用单线程异步模型, 它支持构建各类复杂结构的策略程序, 同时保持高性能及高可读性. 要了解 TqSdk 的编程框架, 请参见 :ref:`framework` 如果您曾经使用并熟悉过其它量化交易开发工具, 这些文件可以帮助您尽快了解TqSdk与它们的差异: * :ref:`for_ctp_user` * :ref:`for_vnpy_user` License ------------------------------------------------- TqSdk 在 Apache License 2.0 协议下提供, 使用者可在遵循此协议的前提下自由使用本软件. "
5,n\doc\profession,"n\doc\profession. .. _profession: TqSdk 专业版 ================================================= TqSdk 中大部分功能是供用户免费使用的, 同时我们也提供了 TqSdk 专业版的增值功能供用户选择 如果想使用 TqSdk 专业版功能，可以登录 `个人中心 <https://account.shinnytech.com/>`_ 申请15天试用或正式购买 更稳定的行情服务器 ------------------------------------------------- 在每次的行情服务器升级当中，我们会优先选择连接到免费版行情服务器中的百分之十左右的用户进行升级，然后在稳定后逐步扩大免费版的升级范围 专业版的行情服务器会在免费版全部升级成功且没有问题之后再进行升级，因此对于 TqSdk 的专业版用户来说，会有更稳定行情服务器连接 更多的实盘交易账户数 ------------------------------------------------- 对于 TqSdk 免费版，每个信易账户支持最多绑定一个实盘账户，而天勤量化专业版支持最多一个信易账户绑定3个实盘账户 信易账户会在用户使用实盘账户时自动进行绑定，直到该信易账户没有能绑定实盘账户的名额(自动绑定功能需要 TqSdk 版本> 1.8.3) 如果需要注册信易账户或者修改您的信易账户绑定的实盘账户，请点击 `登录用户管理中心 <https://account.shinnytech.com/>`_ 登录成功后显示如下，在下方红框处,用户可以自行解绑/绑定实盘账户，其中解绑操作每天限定一次 .. figure:: images/user_web_management.png 如需一个信易账户支持更多的实盘账户，请联系工作人员进行批量购买 `个人中心 <https://account.shinnytech.com/>`_ 策略回测功能 ------------------------------------------------- :ref:`backtest` 是 TqSdk 专业版中的功能，能让用户在不改变代码的情况下去回测自己的策略在历史行情的表现，并且提供对应的web界面来统计用户的回测表现 .. figure:: images/web_gui_backtest.png 对于 TqSdk 免费版本的用户，每天可以进行3次回测，同时也可以申请模拟账户后模拟运行来检验策略 :ref:`sim_trading` 股票行情 ------------------------------------------------- TqSdk 免费版本提供全部的期货、商品/金融期权和上证50、沪深300和中证500的实时行情 购买或申请 TqSdk 专业版试用后可提供A股股票的实时和历史行情，TqSdk 中股票示例代码参考如下:: 	SSE.600000 - 上交所浦发银行股票编码 	SZSE.000001 - 深交所平安银行股票编码 	SSE.000016 - 上证50指数 	SSE.000300 - 沪深300指数 	SSE.000905 - 中证500指数 	SSE.510050 - 上交所上证50etf 	SSE.510300 - 上交所沪深300etf 	SZSE.159919 - 深交所沪深300etf 	SSE.10002513 - 上交所上证50etf期权 	SSE.10002504 - 上交所沪深300etf期权 	SZSE.90000097 - 深交所沪深300etf期权 .. _profession_tqkqstock: 股票模拟交易 ------------------------------------------------- TqSdk 提供了 :py:class:`~tqsdk.TqKqStock` 方法供用户来进行股票的模拟交易 专业版用户可以长久的对同一账户进行模拟股票交易测试 需要注意股票模拟交易下，get_account，get_order，get_position 会返回对应股票交易模型下的 objs ，如 :py:class:`~tqsdk.objs.SecurityAccount`， :py:class:`~tqsdk.objs.SecurityOrder`，:py:class:`~tqsdk.objs.SecurityPosition` 参考代码如下::  from tqsdk import TqApi, TqAuth, TqKqStock  tq_kq_stock = TqKqStock()  api = TqApi(account=tq_kq_stock, auth=TqAuth(""信易账户"", ""账户密码""))  quote = api.get_quote(""SSE.688529"")  print(quote)  # 下单限价单  order = api.insert_order(""SSE.688529"", volume=200, direction=""BUY"", limit_price=quote.ask_price1)  while order.status == 'ALIVE':   api.wait_update()   print(order) # 打印委托单信息  print(api.get_account()) # 打印快期股票模拟账户信息  print(api.get_position(""SSE.688529"")) # 打印持仓信息  for trade in order.trade_records.values():   print(trade) # 打印委托单对应的成交信息  api.close() 下载数据功能 ------------------------------------------------- 数据下载工具 :py:class:`~tqsdk.tools.DataDownloader` 是 TqSdk 专业版中的功能 支持专业版用户下载目前 TqSdk 提供的全部期货、期权和股票类的历史数据，下载数据支持 tick 级别精度和任意 kline 周期 其他相关函数 ------------------------------------------------- :py:meth:`~tqsdk.TqApi.query_symbol_ranking` 交易所每日成交持仓排名 :py:meth:`~tqsdk.TqApi.get_kline_data_series` 以起始日期获取 Dataframe 格式的 kline 数据 :py:meth:`~tqsdk.TqApi.get_trading_status` 获取指定合约的交易状态，帮助用户实现开盘/跨小节抢单 期权交易 & 交易所组合 ------------------------------------------------- TqSdk 中期权交易(商品期权、金融期权)和交易所官方组合也是 TqSdk 专业版中提供的功能 详细期权说明请点击 :ref:`option_trade` TqSdk 中期权和交易所组合合约代码参考如下:: 	DCE.m1807-C-2450 - 大商所豆粕期权 	CZCE.CF003C11000 - 郑商所棉花期权 	SHFE.au2004C308 - 上期所黄金期权 	CFFEX.IO2002-C-3550 - 中金所沪深300股指期权 	SSE.10002513 - 上交所上证50etf期权 	SSE.10002504 - 上交所沪深300etf期权 	SZSE.90000097 - 深交所沪深300etf期权 	CZCE.SPD SR901&SR903 - 郑商所 SR901&SR903 跨期合约 	DCE.SP a1709&a1801 - 大商所 a1709&a1801 跨期合约 工作时间内的天勤客服支持 ------------------------------------------------- 如果您是 TqSdk 专业版的年费用户，那么我们将会单独为您建立一个讨论组，里面会有 TqSdk 的专门技术支持人员在工作时间内优先回答您的问题"
6,n\doc\qa,n\doc\qa. 天勤用户论坛 ------------------------------------------------- 在学习TqSdk的过程中可能会碰到一些疑惑，我们相信用户论坛能够帮助到你。 在用户论坛中你可以： * 根据关键词搜索已解决问题 * 查看热门问题及其解决方案 * 提出待解决的新问题 * 回答/讨论他人提出的问题 点击进入 `用户论坛 <https://www.shinnytech.com/qa>`_ ，加入讨论. .. figure:: images/qa_pic.png
7,n\doc\quickstart,"n\doc\quickstart. .. _quickstart: 十分钟快速入门 ================================================= 希望快速开始使用天勤量化(TqSdk)？ 本页面将介绍如何开始使用 TqSdk. 如果您以前曾经使用过其它框架编写过策略程序, 这些内容可以快速帮助您了解 TqSdk 与它们的区别: * :ref:`intro` * :ref:`for_ctp_user` * :ref:`for_vnpy_user` 注意: TqSdk 使用了 python3 的原生协程和异步通讯库 asyncio，部分 Python IDE 不支持 asyncio，例如: * spyder: 详见 https://github.com/spyder-ide/spyder/issues/7096 * jupyter: 详见 https://github.com/jupyter/notebook/issues/3397 可以直接运行示例代码，或使用支持 asyncio 的 IDE (例如: pycharm / vscode) .. _tqsdk_install: 安装 ------------------------------------------------- 天勤量化的核心是TqSdk开发包, 在安装天勤量化 (TqSdk) 前, 你需要先准备适当的环境和Python包管理工具, 包括: * Python >=3.6.4,3.7,3.8,3.9 版本 * Windows 7 以上版本, Mac Os, 或 Linux 你可以选择使用 `pip` 命令安装 TqSdk, 或者下载源代码安装. 对于一般用户, 我们推荐采用 `pip` 命令安装/升级 TqSdk::  pip install tqsdk -U 但是由于 `pip` 使用的是国外的服务器，普通用户往往下载速度过慢或不稳定，对于使用 `pip` 命令下载速度较慢的用户，我们推荐采用切换国内源的方式安装/升级 TqSdk::  pip install tqsdk -U -i https://pypi.tuna.tsinghua.edu.cn/simple --trusted-host=pypi.tuna.tsinghua.edu.cn .. _quickstart_0: 注册信易账户 ------------------------------------------------- 在使用 TqSdk 之前，用户需要先注册自己的 **信易账户** ，传入信易账户是使用任何 TqSdk 程序的前提,点击 `注册信易账户 <https://account.shinnytech.com/>`_ 信易账户可以使用注册时的手机号/用户名/邮箱号进行登录,详细介绍请点击 :ref:`shinny_account` 在注册完信易账户后，让我们从一个简单的例子开始 .. _quickstart_1: 获取实时行情数据 ------------------------------------------------- 通过 TqSdk 获取实时行情数据是很容易的. 首先, 必须引入 tqsdk 模块::  from tqsdk import TqApi, TqAuth 创建API实例，并填入自己的信易账户::  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) 获得上期所 ni2206 合约的行情引用::  quote = api.get_quote(""SHFE.ni2206"") 现在, 我们获得了一个对象 quote. 这个对象总是指向 SHFE.ni2206 合约的最新行情. 我们可以通过 quote 的各个字段访问行情数据::  print (quote.last_price, quote.volume) 要等待行情数据更新, 我们还需要一些代码::  while True:   api.wait_update()   print (quote.datetime, quote.last_price) :py:meth:`~tqsdk.TqApi.wait_update` 是一个阻塞函数, 程序在这行上等待, 直到收到数据包才返回. 上面这个例子的完整程序请见 :ref:`tutorial-t10` . 你也可以在自己电脑python安装目录的 site_packages/tqsdk/demo 下找到它 很简单, 对吗? 到这里, 你已经了解用 TqSdk 开发程序的几个关键点: * 创建 TqApi 实例 * 用 api.get_quote() 或 其它函数获取数据引用对象 * 在循环中用 api.wait_update() 等待数据包. * 收到数据包以后通过引用对象获得所需数据 下面我们将继续介绍 TqSdk 更多的功能. 无论使用哪个功能函数, 都遵循上面的结构. .. _quickstart_2: 使用K线数据 ------------------------------------------------- 你很可能会需要合约的K线数据. 在TqSdk中, 你可以很方便的获得K线数据. 我们来请求 ni2206 合约的10秒线::  klines = api.get_kline_serial(""SHFE.ni2206"", 10) klines是一个pandas.DataFrame对象. 跟 api.get_quote() 一样, api.get_kline_serial() 也是返回K线序列的引用对象. K线序列数据也会跟实时行情一起同步自动更新. 你也同样需要用 api.wait_update() 等待数据刷新. 一旦k线数据收到, 你可以通过 klines 访问 k线数据::  while True:   api.wait_update()   print(""最后一根K线收盘价"", klines.close.iloc[-1]) 这部分的完整示例程序请见 :ref:`tutorial-t30` . 我们也可以通过传入一个合约列表作为参数，来获取包含多个合约数据的K线::  klines = api.get_kline_serial([""SHFE.au1912"", ""SHFE.au2006""], 5) # 获取SHFE.au2006向SHFE.au1912对齐的K线 详细使用方法及说明请见 :py:meth:`~tqsdk.TqApi.get_kline_serial` 函数说明。 到这里为止, 你已经知道了如何获取实时行情和K线数据, 下面一段将介绍如何访问你的交易账户并发送交易指令 .. _quickstart_2_web_gui: 生成图形化界面 ------------------------------------------------- 如果想要将你订阅的K线或策略图形化显示, 只需在 :py:meth:`~tqsdk.TqApi` 中传入参数 web_gui = True即可::   # 引入TqSdk模块   from tqsdk import TqApi, TqAuth   # 创建api实例，设置web_gui=True生成图形化界面   api = TqApi(web_gui=True, auth=TqAuth(""信易账户"", ""账户密码""))   # 订阅 ni2010 合约的10秒线   klines = api.get_kline_serial(""SHFE.ni2010"", 10)   while True:    # 通过wait_update刷新数据    api.wait_update() 当你运行该程序后，预期会显示如下两条信息::   2019-12-13 10:45:26,468 - INFO - 您可以访问 http://127.0.0.1:62964 查看策略绘制出的 K 线图形。   2019-12-13 10:45:27,422 - INFO - 通知: 与 wss://openmd.shinnytech.com/t/md/front/mobile 的网络连接已建立 点击生成的地址，即可访问订阅的K线图形 .. figure:: images/web_gui_demo.png 具体请见 :ref:`web_gui` .. _quickstart_3: 交易账户, 下单/撤单 ------------------------------------------------- 要获得你的账户资金情况, 可以请求一个资金账户引用对象::  account = api.get_account() 要获得你交易账户中某个合约的持仓情况, 可以请求一个持仓引用对象::  position = api.get_position(""DCE.m1901"") 与行情数据一样, 它们也通过 api.wait_update() 获得更新, 你也同样可以访问它们的成员变量::  print(""可用资金: %.2f"" % (account.available))  print(""今多头: %d 手"" % (position.volume_long_today)) 要在交易账户中发出一个委托单, 使用 api.insert_order() 函数::  order = api.insert_order(symbol=""DCE.m2105"", direction=""BUY"", offset=""OPEN"", volume=5, limit_price=3000) 这个函数调用后会立即返回, order 是一个指向此委托单的引用对象, 你总是可以通过它的成员变量来了解委托单的最新状态::  print(""委托单状态: %s, 已成交: %d 手"" % (order.status, order.volume_orign - order.volume_left)) 要撤销一个委托单, 使用 api.cancel_order() 函数::  api.cancel_order(order) 这部分的完整示例程序请见 :ref:`tutorial-t40` . 到这里为止, 我们已经掌握了 TqSdk 中行情和交易相关功能的基本使用. 我们将在下一节中, 组合使用它们, 创建一个自动交易程序 .. _quickstart_4: 构建一个自动交易程序 ------------------------------------------------- 在这一节中, 我们将创建一个简单的自动交易程序: 每当行情最新价高于最近15分钟均价时, 开仓买进. 这个程序是这样的::  klines = api.get_kline_serial(""DCE.m2105"", 60)  while True:   api.wait_update()   if api.is_changing(klines):    ma = sum(klines.close.iloc[-15:])/15    print(""最新价"", klines.close.iloc[-1], ""MA"", ma)    if klines.close.iloc[-1] > ma:     print(""最新价大于MA: 市价开仓"")     api.insert_order(symbol=""DCE.m2105"", direction=""BUY"", offset=""OPEN"", volume=5) 上面的代码中出现了一个新函数 api.is_changing(). 这个函数用于判定指定对象是否在最近一次 wait_update 中被更新. 这部分的完整示例程序请见 :ref:`tutorial-t60` . .. _quickstart_5: 按照目标持仓自动交易 ------------------------------------------------- 在某些场景中, 我们可能会发现, 自己写代码管理下单撤单是一件很麻烦的事情. 在这种情况下, 你可以使用 :py:class:`tqsdk.TargetPosTask`. 你只需要指定账户中预期应有的持仓手数, TqSdk 会自动通过一系列指令调整仓位直到达成目标. 请看例子::  # 创建 ni2010 的目标持仓 task，该 task 负责调整 ni2010 的仓位到指定的目标仓位  target_pos_near = TargetPosTask(api, ""SHFE.ni2010"")  # 创建 ni2011 的目标持仓 task，该 task 负责调整 ni2011 的仓位到指定的目标仓位  target_pos_deferred = TargetPosTask(api, ""SHFE.ni2011"")  while True:   api.wait_update()   if api.is_changing(quote_near) or api.is_changing(quote_deferred):    spread = quote_near.last_price - quote_deferred.last_price    print(""当前价差:"", spread)    if spread > 200:     print(""目标持仓: 空近月，多远月"")     # 设置目标持仓为正数表示多头，负数表示空头，0表示空仓     target_pos_near.set_target_volume(-1)     target_pos_deferred.set_target_volume(1)    elif spread < 150:     print(""目标持仓: 空仓"")     target_pos_near.set_target_volume(0)     target_pos_deferred.set_target_volume(0) 这部分的完整示例程序请见 :ref:`tutorial-t80` . .. _quickstart_backtest: 策略回测 ------------------------------------------------- 自己的交易程序写好以后, 我们总是希望在实盘运行前, 能先进行一下模拟测试. 要进行模拟测试, 只需要在创建TqApi实例时, 传入一个backtest参数::  api = TqApi(backtest=TqBacktest(start_dt=date(2018, 5, 1), end_dt=date(2018, 10, 1)), auth=TqAuth(""信易账户"", ""账户密码"")) 这样, 程序运行时就会按照 TqBacktest 指定的时间范围进行模拟交易测试, 并输出测试结果. 此外 TqSdk 同时还支持股票的回测交易，请见 :ref:`security_backtest` 更多关于策略程序回测的详细信息, 请见 :ref:`backtest` .. _real_trading: 实盘交易 ------------------------------------------------- 要让策略程序在实盘账号运行, 请在创建TqApi时传入一个 :py:class:`~tqsdk.TqAccount` , 填入 期货公司, 账号, 密码 和信易账户信息(使用前请先 import TqAccount):: from tqsdk import TqApi, TqAuth, TqAccount api = TqApi(TqAccount(""H海通期货"", ""412432343"", ""123456""), auth=TqAuth(""信易账户"", ""账户密码"")) 更多关于实盘交易细节，请点击 :ref:`trade` 目前支持的期货公司列表, 请点击查看: `TqSdk支持的期货公司列表 <https://www.shinnytech.com/blog/tq-support-broker/>`_ 注册信易账户，请点击 `登录用户管理中心 <https://www.shinnytech.com/register-intro/>`_ .. _sim_trading: 模拟交易和论坛 ------------------------------------------------- 如果您需要使用能保存账户资金及持仓信息的模拟交易功能, 请点击 `注册信易账号 <https://www.shinnytech.com/register-intro/>`_ ，填写完对应信息之后，并验证成功即可进入 `用户论坛 <https://www.shinnytech.com/qa>`_ . .. figure:: images/tq_register.png 刚刚注册完成的信易账户的【手机号】/【邮箱地址】/【用户名】和【密码】可以作为 快期模拟 账号，通过 :py:class:`~tqsdk.TqKq` 对 auth 传入参数进行登录，这个 快期模拟 账户在快期APP、快期V3 pro 和天勤量化上是互通的 快期模拟的资金可以通过快期APP、快期专业版的模拟银行进行出入金:: from tqsdk import TqApi, TqAuth, TqKq api = TqApi(TqKq(), auth=TqAuth(""信易账户"", ""账户密码"")) 特别的，如果创建TqApi实例时没有提供任何 TqAcccount 账户或 TqKq 模块，则每次会自动创建一个临时模拟账号，当程序运行结束时，临时账号内的记录将全部丢失:: api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) TqSdk 学习视频 ------------------------------------------------- TqSdk 提供简单易懂的十分钟上手视频 `供用户学习 <https://www.shinnytech.com/tqsdkquickstart/>`_ 更多内容 ------------------------------------------------- * 要完整了解TqSdk的使用, 请阅读 :ref:`usage` * 更多TqSdk的示例, 请见 :ref:`demo_strategy` "
8,n\doc\version,"n\doc\version. .. _version: 版本变更 ============================= 3.2.12 (2022/10/20) * 优化: :py:meth:`~tqsdk.TqApi.query_all_level_finance_options` 增加 ETF 期权标的，文档补充完整 ETF 基金名称 * docs：修正文档，添加上交所和深交所中证1000ETF和深交所创业板ETF代码示例 3.2.11 (2022/07/27) * 增加：下载数据时 csv_file_name 参数支持 str / asyncio.StreamWriter 两种类型 * 修复：vwap_table 手数计算错误的问题 3.2.10 (2022/07/20) * 增加：增加中证 1000 指数，免费用户可获取该指数行情，参考文档 :ref:`mddatas` * 修复：回测中没有正常更新 quotes 下的 expire_rest_days 字段的问题 * 修复：回测 web_gui 图表没有显示成交标注、持仓线的问题 3.2.9 (2022/07/07) * 增加：下载 tick 数据时增加 average 列 * 增加：:py:meth:`~tqsdk.TqApi.get_tick_data_series` 接口返回值中增加 average 列 * 优化：下载数据时优化 cpu 占用 * 优化：tqsdk 内部各个模块使用统一的时间处理函数 * 修复：:py:class:`~tqsdk.TargetPosTask` 及 :py:class:`~tqsdk.algorithm.twap` 增加添加普麦、早籼稻、粳稻及晚籼稻期货暂不支持的提示 * 修复：:py:meth:`~tqsdk.TqApi.query_symbol_ranking` 接口某些情况可能报错的问题 3.2.8 (2022/04/29) * 修复：下载多合约 klines 时数据可能未完全收全的问题 * 修复：支持多进程下使用 :py:meth:`~tqsdk.TqApi.get_kline_data_series`、:py:meth:`~tqsdk.TqApi.get_tick_data_series` 接口 3.2.7 (2022/04/22) * 优化：对多线程用例，增加可能的错误提示 * 优化：TqApi 的 debug 默认值修改为 None，且 debug 为 None 情况下在磁盘剩余空间大于 3G 时才可能开启日志 * docs：增加 ETF 期权本地计算卖方保证金示例 o74，完善 targetpostask 的示例文档，完善 Position 下 orders 定义，统一修正文档大小写、变量命名等 3.2.6 (2022/03/09) * 修复：修正深交所 ETF 期权的昨结算（pre_settlement）字段未正确显示的问题 3.2.5 (2022/03/09) * 修复：修正上交所 ETF 期权的昨结算（pre_settlement）字段未正确显示的问题 * 修复：:py:class:`~tqsdk.TargetPosTask` 及 :py:class:`~tqsdk.algorithm.twap` 添加强麦期货暂不支持的提示 * 修复：api.insert_order 没有检查 advanced 参数 3.2.4 (2022/03/07) * 优化：某些情况下启用 web_gui 后网页卡顿的问题 * 修复：修正上交所 ETF 期权的昨结算（pre_settlement）字段 * 修复：:py:class:`~tqsdk.TargetPosTask` 及 :py:class:`~tqsdk.algorithm.twap` 添加动力煤期货暂不支持的提示 * docs：修正文档，增加 tqkq() 的示例，增加 :ref:`tqsdk2ctptest` 文档 3.2.3 (2022/02/16) * 修复：query_all_level_options 接口查询 ETF 期权可能报错的问题 * 修复：提升程序在连续订阅 K 线时的运行速度 * 修复：使用快期模拟账户交易，在断线重连后程序可能报错的问题 * docs：修正文档 3.2.2 (2022/01/26) * 增加：支持在回测中使用本地风控模块 * 优化：规范化测试脚本，能尽早发现由于依赖库版本升级，而导致部分代码写法不兼容的错误 * docs：修正文档字体显示格式，增加股票回测文档 :ref:`security_backtest` 3.2.1 (2022/01/11) * 优化：打印通知时，显示期货账户，改善多账户下用户使用体验 * 优化：**免费用户** 每日回测 3 次，支持其回测时交易股票；**专业版用户** 回测次数及交易品种不受限制，专业版购买网址：https://account.shinnytech.com。 * 修复：linux 下使用多进程时，报单号可能重复的问题 * docs：修改交易相关的 get 系列函数文档及示例代码 * **TqSdk 计划在 20220601 之后放弃支持 Python 3.6 版本，请尽快升级 Python 版本。** 建议升级到 3.8 及以上，以保证所有依赖库都可以使用最新版。 3.2.0 (2021/12/31) * 新增：:py:class:`~tqsdk.TqSimStock` 类实现本地股票模拟交易，同时支持在实盘/回测模式下使用。 **专业版用户** 可用，专业版购买网址：https://account.shinnytech.com。 * web_gui：修复回测时不能正常显示结果报告的问题 * 修复：windows 下调用 :py:meth:`~tqsdk.TqApi.get_kline_data_series` 时，可能出现缓存文件不允许重复重命的问题 3.1.1 (2021/12/24) * 修复：穿管采集文件读取失败 3.1.0 (2021/12/24) * 新增：为各种账户类型增加接口调用，支持 IDE 更好的提供代码提示。TqSdk 目前支持以下账户类型 :py:class:`~tqsdk.TqAccount`、:py:class:`~tqsdk.TqKq`、 :py:class:`~tqsdk.TqKqStock`、:py:class:`~tqsdk.TqSim`，本次重构为以上账户类型分别添加了 ``get_account``、``get_position``、``get_order``、``get_trade`` 几个接口，明确了其返回值的类型。 例如：:py:class:`~tqsdk.TqKq` 实例调用 :py:meth:`~tqsdk.TqKq.get_account` ，返回 :py:class:`~tqsdk.objs.Account` 类型实例； :py:class:`~tqsdk.TqKqStock` 实例调用 :py:meth:`~tqsdk.TqKqStock.get_account` ，返回 :py:class:`~tqsdk.objs.SecurityAccount` 类型实例。 * 修复：:py:class:`~tqsdk.TargetPosTask` 及 :py:class:`~tqsdk.algorithm.twap` 增加添加红枣期货暂不支持的提示 * docs：更新开盘抢单示例代码 3.0.3 (2021/12/10) * 修复：从服务器更新节假日表，修复 :py:meth:`~tqsdk.TqApi.get_trading_calendar` 接口文档及报错信息 3.0.2 (2021/12/07) * 修复：调用 :py:meth:`~tqsdk.TqApi.get_kline_serial` 接口获取股票前复权 Kline 时，复权计算结果可能出错的问题 * 新增：节假日表添加 2022 年节假日信息 * 新增：支持在 python 3.10 下使用 TqApi * web_gui：支持多账户下使用 * docs：更新示例合约代码 3.0.1 (2021/11/26) * 修复：调用 :py:meth:`~tqsdk.TqApi.query_symbol_info`，当参数中包含主连/指数合约会报错的问题 * 修复：在某些情况下，回测时获取期权及标的合约的多合约 Kline 可能报错的问题 * 修复：回测时取主连合约，如果用 ``quote.underlying_quote`` 直接读取标的合约，在标的合约变更时，可能未重新订阅行情的问题 * 优化：取消网络连接关闭时屏幕输出，改为存入日志文件 * docs：完善 :py:meth:`~tqsdk.TqApi.get_account`、:py:meth:`~tqsdk.TqApi.get_position`、:py:meth:`~tqsdk.TqApi.get_order`、 :py:meth:`~tqsdk.TqApi.get_trade` 函数返回值类型文档说明，完善专业版 :ref:`profession_tqkqstock` 文档，完善 :ref:`tqrohon` 融航接入文档 3.0.0 (2021/11/12) * 增加：:py:class:`~tqsdk.TqKqStock` **快期股票模拟** 账户类型，支持股票模拟交易。**专业版用户** 可用，专业版购买网址：https://account.shinnytech.com。 * 增加：:py:class:`~tqsdk.risk_rule.TqRuleAccOpenVolumesLimit` 类，日内累计开仓手数限制 * 优化：使用 sgqlc 库生成合约服务的 graphql 查询 2.9.4 (2021/11/04) * 增加：:py:meth:`~tqsdk.TqApi.query_symbol_info` 接口返回值中增加 ``upper_limit``, ``lower_limit`` 这两个字段 * 优化: 多账户模式支持回测模块 * 优化: query 系列函数，发送的查询请求中合约列表长度不能大于 8192 * 优化: 网络连接优化断线重连机制 2.9.3 (2021/10/28) * 增加：:py:class:`~tqsdk.risk_rule.TqRuleOpenCountsLimit`、:py:class:`~tqsdk.risk_rule.TqRuleOpenVolumesLimit` 类， 以及 :py:meth:`~tqsdk.TqApi.add_risk_rule`、:py:meth:`~tqsdk.TqApi.delete_risk_rule` 接口，支持本地风控功能 * 增加：:py:class:`~tqsdk.exceptions.TqRiskRuleError` 错误类型，可以捕获风控触发的错误 2.9.2 (2021/10/20) * 修复：实盘账户无法使用 :py:meth:`~tqsdk.TqApi.get_trading_status` 接口的问题 * docs：完善专业版文档 2.9.1 (2021/10/19) * 增加：:py:meth:`~tqsdk.TqApi.get_trading_status` 接口，支持开盘抢单功能 * 增加：:py:meth:`~tqsdk.TqApi.query_symbol_info` 接口返回值中增加 ``product_id``, ``expire_rest_days``, ``trading_time_day``, ``trading_time_night`` 几个字段 * 优化：TqSim 回测报告增加部分字段，和 web_gui 显示回测报告一致 * 优化：:py:meth:`~tqsdk.TqApi.get_kline_data_series`、:py:meth:`~tqsdk.TqApi.get_tick_data_series` 接口报错 2.9.0 (2021/09/29) * 增加：:py:meth:`~tqsdk.TqApi.query_symbol_info` 接口返回值中增加 ``pre_open_interest``, ``pre_settlement``, ``pre_close`` 这三个字段 * 优化：重构网络连接，增加多账户测试用例 * 优化：简化回测结束后用户依然需要查看 web_gui 时的代码，详情参考 :ref:`backtest_with_web_gui` * 优化：网络连接失败时，优化对用户的提示信息 * 优化：实盘账户实盘不支持主连和指数交易，提前抛错提示用户 * docs：更新文档，专业版承诺提供A股股票行情 2.8.6 (2021/09/16) * 增加：TqApi 增加 :py:meth:`~tqsdk.TqApi.query_his_cont_quotes` 接口，可以获取过去 n 个交易日的历史主连信息 * 增加：通知模块 :py:class:`~tqsdk.TqNotify`，帮助用户收集通知信息并做定制化处理 * docs：完善风控文档，增加专业版权限函数说明 2.8.5 (2021/09/06) * 增加：TqApi 增加 :py:meth:`~tqsdk.TqApi.query_symbol_ranking` 接口，支持查询合约成交排名/持仓排名。 * 增加：TqApi 增加 :py:meth:`~tqsdk.TqApi.query_option_greeks` 接口，返回指定期权的希腊指标。 * 修复：pyinstaller 工具由于缺少初始合约文件导致打包失败 * 优化：:py:meth:`~tqsdk.tafunc.get_delta`、:py:meth:`~tqsdk.tafunc.get_theta`、:py:meth:`~tqsdk.tafunc.get_rho`、 :py:meth:`~tqsdk.tafunc.get_bs_price`、:py:meth:`~tqsdk.tafunc.get_impv` 接口中 ``option_class`` 参数支持类型扩展为 ``str 或者 pandas.Series``，详情见文档 2.8.4 (2021/08/31) * 修复：由于缺少初始合约文件，TqApi 初始化可能失败的问题 2.8.3 (2021/08/30) * 增加：is_changing 接口增加对于委托单 :py:meth:`~tqsdk.objs.Order.is_dead`、:py:meth:`~tqsdk.objs.Order.is_online`、 :py:meth:`~tqsdk.objs.Order.is_error`、:py:meth:`~tqsdk.objs.Order.trade_price` 字段支持判断是否更新 * 修复：TqApi 初始化可能失败的问题 * 优化：将已知下市合约直接打包在代码中，缩短 TqApi 初始化时间 * docs：完善主力切换规则说明，将阿里源替换为清华源 2.8.2 (2021/08/17) * 增加：is_changing 接口增加对于合约 :py:meth:`~tqsdk.objs.Quote.expire_rest_days`，持仓 :py:meth:`~tqsdk.objs.Position.pos_long`、 :py:meth:`~tqsdk.objs.Position.pos_short`、:py:meth:`~tqsdk.objs.Position.pos` 字段支持判断是否更新 * 修复：2.8.1 版本重构后，不支持多线程运行的问题 * docs：更新合约字段示例说明 2.8.1 (2021/08/12) * 增加：增强在协程中的支持，以下接口 :py:meth:`~tqsdk.TqApi.query_quotes`，:py:meth:`~tqsdk.TqApi.query_cont_quotes`， :py:meth:`~tqsdk.TqApi.query_options`，:py:meth:`~tqsdk.TqApi.query_atm_options`， :py:meth:`~tqsdk.TqApi.query_symbol_info`，:py:meth:`~tqsdk.TqApi.query_all_level_options`， :py:meth:`~tqsdk.TqApi.query_all_level_finance_options`，支持协程中 ``in_options, at_options, out_options = await api.query_all_level_finance_options(""SSE.510300"", 4.60, ""CALL"", nearbys = 1)`` 写法，参考文档：:ref:`multi_async_task` * 修复：target_pos_task 优化报错提示，已经结束的 TargetPosTask 实例再调用 set_target_volume 设置手数会报错。参考文档：:py:meth:`~tqsdk.TargetPosTask.cancel` * 修复：下载历史数据时，某些数据未按照最小价格变动单位保留相应小数位数的问题 * 重构：优化 wait_update、is_changing 接口的实现，增强对协程的支持 * docs：完善回测字段规则文档说明 2.8.0 (2021/08/05) * 增加：**支持免费用户每日回测 3 次** 2.7.2 (2021/07/30) * 增加：**支持在回测中使用 query 系列函数，查询结果为回测当天的合约信息** * 增加：Quote 对象增加 underlying_quote 属性，值是一个 Quote 对象（为 underlying_symbol 属性对应的合约引用）或者是 None * web_gui：修复在 safari 和 firefox 无法正常显示的问题 * docs：完善支持用户自助购买文档 2.7.1 (2021/07/21) * 修复：query 系列查询看跌期权时，未返回指定的实值、平值、虚值序列的问题 * docs：完善 position 文档说明 * docs：补充期权示例 2.7.0 (2021/07/15) * 增加：**去除 Cython 编译，本地代码全部开源** * 增加：**支持 ARM 架构下 CPU 的安装使用** * 增加：TqApi 增加 :py:meth:`~tqsdk.TqApi.query_all_level_finance_options` 接口，支持查询指定当月、下月、季月等到期月份的金融期权。 * 增加：支持上期能源下载 ticks 5 档行情 * 修复：某些参数可能造成 twap 无法执行的问题 * 修复：客户端发送的 variables 中变量值不支持空字符串、空列表或者列表中包括空字符串 * 删除：为期权持仓、成交、委托单对象添加部分期权合约信息的功能（2.6.5 增加功能） * doc：添加隔夜开盘抢单示例，不再建议用户自定义次席连接 2.6.6 (2021/07/05) * 修复：支持 pandas 1.3.0 版本 * 修复：回测中某些有夜盘的合约，报夜盘时间不在可交易时间段的问题 * web_gui：成交列表中成交价格默认显示4位小数 * doc：完善钉钉推送文档 2.6.5 (2021/06/30) * 增加：为期权持仓、成交、委托单对象添加部分期权合约信息，方便用户查看 * 增加：回测时，Quote 对象支持读取 expired 值 * 修复：TargetPosScheduler 最后一项等到目标持仓完成退出，最后一项设置的超时时间无效 * 修复：回测时如果先订阅日线，可能出现无法成交的问题 * doc：完善期权文档、增加 :ref:`enterprise` 文档说明 2.6.4 (2021/06/23) * 增加：:py:class:`~tqsdk.objs.Quote` 增加 :py:class:`~tqsdk.objs.Quote.expire_rest_days` 属性，表示距离到期日天数 * 增加：TqApi 增加 :py:meth:`~tqsdk.TqApi.query_symbol_info` 接口，支持批量查询合约信息 * 增加：TqApi 增加 :py:meth:`~tqsdk.TqApi.query_all_level_options` 接口，返回标的对应的全部的实值、平值、虚值期权 * 增加：TqApi 中 :py:meth:`~tqsdk.TqApi.query_atm_options` 接口，扩大参数 price_level 支持范围 * 增加：sim.tqsdk_stat 增加总手续费字段 * 修复：回测中某些有夜盘的合约，报夜盘时间不在可交易时间段的问题 * 修复：回测报告中，在有期权交易时，每日收益值有错误 * 修复：回测中限制 :py:meth:`~tqsdk.TqApi.get_quote_list` 参数列表长度，最多支持 100 合约 * web_gui：修复部分成交记录箭头标注位置不对的问题 * web_gui：修复报告页面日期没有显示的问题 * web_gui：支持代码运行中可以修改指标颜色 * web_gui：成交列表中，部分成交价格没有按照最小变动价格保留小数位数的问题 * doc：完善期权文档 * doc：完善回测文档 2.6.3 (2021/06/11) * 修复：twap 策略某些参数组合无法执行的问题，修改后生成随机手数可能最后一笔的下单手数小于设置的最小手数 * 修复：TqSim 模拟交易期权时，某些情况下标的行情不更新的问题 * 完善文档：增加指数、主连行情、期权使用文档说明 * web_gui：增加回测报告图表页面（增加每日资金、每日盈亏、滚动夏普比率、滚动索提诺比率图表） * web_gui：指标线可以绘制虚线 2.6.2 (2021/06/03) * 修复：在回测某些时间段时，指数无法交易的问题 * 重构：TqSim 回测统计函数重构，增加 sortino_ratio 索提诺比率指标 * 重构：算法模块中产生随机序列的方法 * 优化：target_pos_task 报错提示文字 * 优化：网络链接建立、断连时的报错提示文字 * 优化：单线程创建多个异步任务文档完善，参考文档：:ref:`multi_async_task` * web_gui：修复成交量图在高分屏下高度错误的问题 * web_gui：k线文字标注为开高低收 * web_gui：图表不显示 BoardId 2.6.1 (2021/05/27) * 增加：增强在协程中的支持，以下接口 :py:meth:`~tqsdk.TqApi.get_quote`，:py:meth:`~tqsdk.TqApi.get_quote_list`， :py:meth:`~tqsdk.TqApi.get_kline_serial`，:py:meth:`~tqsdk.TqApi.get_tick_serial` 支持协程中 ``quote = await api.get_quote('SHFE.cu2106')`` 写法，参考文档：:ref:`multi_async_task` * 增加：:py:meth:`~tqsdk.algorithm.time_table_generater.vwap_table` 的示例代码，参考链接 :ref:`demo-algorithm-vwap` * 优化：:py:meth:`~tqsdk.algorithm.time_table_generater.twap_table` 的示例代码，参考链接 :ref:`demo-algorithm-twap` * 优化：在网络链接开始尝试重连时，增加通知和日志 * 修复：多次创建同合约 TargetPosTask 实例，可能抛错的问题 * 完善文档：补充期权示例文档 2.6.0 (2021/05/20) * 增加：``tqsdk.algorithm`` 模块提供 :py:meth:`~tqsdk.algorithm.time_table_generater.vwap_table` 帮助用户完成 vwap 算法下单。 * 增加：:py:class:`~tqsdk.exceptions.TqTimeoutError` 错误类型，方便用于捕获此错误 * 增加：:py:class:`~tqsdk.TargetPosTask` 实例提供 :py:meth:`~tqsdk.TargetPosTask.cancel`、:py:meth:`~tqsdk.TargetPosTask.is_finished` 方法 * 修复：在异步代码中调用 get_quote 函数时，可能遇到 Task 未被引用而引发的错误 * 修复：Windows 中下载数据时，文件已经被占用而无法继续下载时，TqSdk 没有正常退出的错误 * 优化：针对初始化时的可能出现超时退出的问题，增加错误收集和提示 2.5.1 (2021/05/13) * 增加：负责策略执行工具 :py:class:`~tqsdk.TargetPosScheduler`，帮助用户完成复杂的下单策略，同时提供给用户极大的调整空间。文档参考 :ref:`target_pos_scheduler` * 增加：TqSim 支持用户设置期权手续费 * 修复：协程中调用 get_quote 可能超时的问题 * 修复：首次登录期货账户可能会抛错的问题 * 优化：修改文档，增加测试脚本日志输出 2.5.0 (2021/04/27) + 增加：:py:meth:`~tqsdk.TqApi.get_quote_list` 接口，支持批量订阅合约。注意其参数和返回值都是 list 类型。 + 增加：版本通知功能，后续版本升级将在 TqSdk 版本大于等于 2.5.0 以上版本做通知 + 优化：TqApi 初始化逻辑，减少了一大半 TqApi 初始化时间 2.4.1 (2021/04/16) * 增加：TqSim 支持 BEST / FIVELEVEL 市价单 * 修复：回测情况下可能遇到单个合约行情回退的问题 * 修复：get_position 获取持仓添加默认的 exchange_id, instrument_id * 修复：回测时用到多合约 Kline 且其中某个合约在回测区间内下市，可能导致程序崩溃 * 重构：合约服务模块独立为一个模块，增加了查询合约服务等待时间，减少了api初始化创建失败的概率 * 完善文档 2.4.0 (2021/03/30) * 增加：:py:class:`~tqsdk.algorithm.twap` 增加 trades，average_trade_price 属性，用于获取成交记录和成交均价 * 增加：query_cont_quotes 接口增加 has_night 参数，详情参考 :py:meth:`~tqsdk.TqApi.query_cont_quotes` * 增加：**支持用户回测中设置 TqSim 的保证金和手续费**，详情参考 :py:meth:`~tqsdk.TqSim.set_margin`、:py:meth:`~tqsdk.TqSim.set_commission`、:py:meth:`~tqsdk.TqSim.get_margin`、:py:meth:`~tqsdk.TqSim.get_commission` * 增加：**支持用户回测中使用 quote.underlying_symbol 获取主连对应的主力合约**，详情参考 :ref:`backtest_underlying_symbol` * 修复：回测时大于日线周期的 K 线的收盘时间错误 2.3.5 (2021/03/19) * 增加：:py:class:`~tqsdk.algorithm.twap` 支持在多账户下使用 * 重构： TqSim 模拟交易模块，修复了 TqSim 模拟交易期权时部分字段计算错误的问题，增加测试用例覆盖，提高 TqSim 模块准确性 * 修复：:py:class:`~tqsdk.TargetPosTask` 能支持多账户下使用 * 修复：之前版本下载无任何成交的合约会显示在 0% 卡住或退出程序，修改为超时（30s）之后跳过该无成交合约下载后续合约 * 完善文档：增加 TargetPosTask 大单拆分模式用法示例，修改完善期权文档等 * 依赖库升级：pandas 版本要求为 >= 1.1.0 2.3.4 (2021/03/11) * 增加：**TargetPosTask 增加 min_volume, max_volume 参数，支持大单拆分模式**，详情参考 :py:class:`~tqsdk.TargetPosTask` * 重构：TqSim 模拟交易模块，修复了 TqSim 模拟交易时账户、持仓部分资金字段计算错误的 bug * 修复：:py:meth:`~tqsdk.TqApi.query_options`, :py:meth:`~tqsdk.TqApi.query_atm_options` 接口中 `has_A` 参数不生效的 bug * 修复：在使用 TargetPosTask 时，主动调用 api.close() 程序不能正常退出的错误的 bug * 修复：回测时使用多合约 Kline 可能引起的 bug * 修复：在节假日时回测，由于节假日当日无夜盘而导致部分夜盘品种的交易时间段错误 * 修复：web_gui 在切换合约/周期时未更新用户绘图数据的 bug * 修复：web_gui 幅图数据默认保留两位小数显示 2.3.3 (2021/02/19) * 修复获取交易日历接口在低版本 pandas 下结果可能出错的问题 2.3.2 (2021/02/08) * 增加 :py:meth:`~tqsdk.TqApi.get_trading_calendar` 接口，支持用户获取交易日历 * 增加 :py:meth:`~tqsdk.TqApi.query_atm_options` 接口，支持用户获取指定档位期权 * 修复在回测时订阅当天上市的合约可能出现报错的情况 * 修复 web_gui 回测时某些情况下定位不准确的问题 * 优化 :py:meth:`~tqsdk.TqApi.query_quotes` , 支持用户查询交易所的全部主连或指数 * 优化 TqSim 交易失败的提示 * 优化客户端发送的数据包量，降低流量占用 2.3.1 (2021/02/01) * 增加 t96.py macd 绘图示例，详情参考 :ref:`tutorial-t96` * 修复获取大量合约的多合约Kline，有可能等待超时的问题 * web 优化图表，回测时图表跳转到回测时间段 * 优化测试用例、文档 2.3.0 (2021/01/20) * 股票实盘交易即将上线 * 回测增加支持获取多合约 Kline，现在可以在回测中使用期权相关函数 * TqSim 增加属性 tqsdk_stat，提供给用户查看回测交易统计信息，详情参考 :ref:`backtest` * 修复 twap 可能少下单的问题，增加针对 twap 的测试用例 2.2.6 (2021/01/13) * 增加接口 :py:meth:`~tqsdk.TqApi.get_kline_data_series`、:py:meth:`~tqsdk.TqApi.get_tick_data_series`，支持 **专业版用户** 获取一段时间 K 线或 Tick 的用法 * 修复 web 需要拖拽才能更新 K 线的问题，支持自动更新 K 线 * 修复下载多合约 K 线，列名顺序错误的问题 * 修复 web 盘口总手数可能显示错误的问题 * 修复 draw_text 设置颜色无效的问题 2.2.5 (2020/12/29) * 复权统一命名规范 ""F"" 表示前复权，""B"" 表示后复权，请检查您的代码是否符合规范 * 修复下载复权数据时，由于下载时间段无复权信息，可能导致失败的问题 * 修复复盘时，下单可能会报错的问题 * 修复在 get_kline_serial / get_tick_serial 在 pandas=1.2.0 版本下用法不兼容的问题 * 完善期权相关文档 2.2.4 (2020/12/23) * 修复新用户第一次安装 TqSdk 可能遇到依赖库 pyJWT 版本不兼容的错误 * 修复 web_gui 拖拽不能缩小图表的问题 2.2.3 (2020/12/22) * 修复 twap 在退出时由于未等待撤单完成，可能造成重复下单的问题 * 修复 twap 未按时间随机，成交后立即退出的问题 * 修复在复盘模式下 TqSim 设置初始资金无效 * 修复 web 绘制线型无法设置颜色的问题 * 修复回测模式下连接老版行情服务器无法运行问题 2.2.2 (2020/12/17) * **支持获取复权后 klines/ticks**，详情请参考文档 :py:meth:`~tqsdk.TqApi.get_kline_serial`、:py:meth:`~tqsdk.TqApi.get_tick_serial` * **支持下载复权后 klines/ticks**，详情请参考文档 :py:class:`~tqsdk.tools.DataDownloader` * Quote 对象增加除权表(stock_dividend_ratio)，除息表(cash_dividend_ratio) 两个字段，详情请参考文档 :py:class:`~tqsdk.objs.Quote` * 修复 twap 算法在手数已经成交时状态没有变为已结束的 bug * 修复文档中 reference/tqsdk.ta 页面内不能跳转连接 2.2.1 (2020/12/14) * 修复用户使用 pyinstaller 打包文件，不会自动添加穿管认证文件和 web 资源文件的问题 2.2.0 (2020/12/08) * **更换 web_gui 绘图引擎，极大改善 web_gui 交互性能** * **由于后续行情服务器升级等原因，建议用户 2020/12/31 号前将 tqsdk 升级至 2.0 以上版本** * 修复发布包中缺失 demo 文件夹的问题 * 修改 lib 示例文档 2.1.4 (2020/11/26) * 增加计算波动率曲面函数，详情参考 :py:meth:`~tqsdk.ta.VOLATILITY_CURVE` * **TargetPosTask 支持 price 参数为函数类型**，详情参考 :py:class:`~tqsdk.TargetPosTask` * 优化下载数据体验，已下市无数据合约提前退出 * 修复在复盘情况下会持续重复发送订阅合约请求的问题，可以改善复盘连接成功率 * 修改优化文档 2.1.3 (2020/11/20) * 修复 twap 在某些边界条件下无法下单的 bug * 修复 linux 平台下 web_gui 可能因为端口占用无法启动网页 * DataDownloader.get_data_series() 函数使用可能导致内存泄漏，暂时下线修复 2.1.2 (2020/11/19) * 下载数据工具支持默认下载 ticks 五档行情 * 下载数据工具增加 get_data_series 接口，可以获取 dataframe 格式数据，详情请参考 :py:meth:`~tqsdk.tools.DataDownloader.get_data_series` * 优化下载数据体验，无数据合约提前退出 * 修复 twap 算法可能无法持续下单的 bug * web_gui 替换新版 logo * web_gui 支持 K 线图放大显示 2.1.1 (2020/11/18) * 增加 psutil 依赖包 2.1.0 (2020/11/17) * **增加多账户功能**，详情请参考 :py:class:`~tqsdk.multiaccount` * 优化日志模块，明确区分屏幕输出、日志文件中的日志格式，并在 TqApi 中提供参数 `disable_print`，可以禁止 TqApi 在屏幕输出内容，详情请参考 :py:class:`~tqsdk.TqApi` * 修复复盘时 web_gui 时间显示错误 * 优化测试用例执行流程，支持并行运行测试 * 修改、优化优化文档 * Python >=3.6.4, 3.7, 3.8, 3.9 才能支持 TqSdk 2.1.0 及以上版本 2.0.5 (2020/11/03) * 优化：Quote 对象增加若干字段：instrument_name、 exercise_year、exercise_month、last_exercise_datetime、exercise_type、public_float_share_quantity，详情请参考文档 :py:class:`~tqsdk.objs.Quote` * 修改：query_options 接口参数名调整，兼容之前的用法 * 修复：CFFEX.IO 指数回测可能报错的bug * 修复：快期模拟在 web_gui 中优化用户名显示 * 修复：未设置过 ETF 期权风控规则的账户首次设置风控规则时可能报错 * 优化文档：增加 query 系列函数返回数据类型的注释 2.0.4 (2020/10/13) * 增加 Python 支持版本说明(3.6/3.7/3.8) * 修复指数不能正常回测问题 * 修复 2020/08/03-2020/09/15 时间内下市合约查询失败的问题 2.0.3 (2020/09/23) * 修复 api 对不存在合约名称的错误处理 * 增加下载委托单和成交记录的示例 :ref:`tutorial-downloader-orders` * 增加 algorithm 算法模块，增加 :py:class:`~tqsdk.algorithm.twap` 算法以及对应的 demo 示例 :ref:`demo-algorithm-twap` 2.0.2 (2020/09/18) * 2020/10/01 以后，免费版用户不再支持回测，下载数据等功能，`点击了解专业版和免费版区别 <https://www.shinnytech.com/tqsdk_professional/>`_ * 修改中证 500 的合约名称为 SSE.000905 * 修改 TqAccount 检查参数类型并提示用户 2.0.1 (2020/09/17) * 股票行情正式上线，点击查看详情 :ref:`mddatas` * 发布 TqSdk 专业版，点击查看详情 :ref:`profession` * 支持 ETF 期权交易，支持的期货公司名单参见 `点击查看详细说明 <https://www.shinnytech.com/blog/tq-support-broker/>`_ * 提供新版合约接口服务 :py:meth:`~tqsdk.TqApi.query_quotes`、:py:meth:`~tqsdk.TqApi.query_cont_quotes`、:py:meth:`~tqsdk.TqApi.query_options`，替代原有 _data 用法，建议尽早换用 * 增加设置、读取 ETF 期权风控规则的接口，:py:meth:`~tqsdk.TqApi.set_risk_management_rule`、:py:meth:`~tqsdk.TqApi.get_risk_management_rule` * 增加 TqAuth 用户认证类，使用 TqApi 时 auth 为必填参数，:py:class:`~tqsdk.TqAuth`，兼容原有 auth 用法。 * 增加权限校验，提示用户限制信息 * 修改为默认不开启 debug 记录日志 * 修复 TqKq 登录失败的问题 * 修改、优化文档及测试用例 1.8.3 (2020/07/29) * 修复：pandas 的 consolidate 函数调用可能会造成 K 线数据不更新 * 修复：api.insert_order 没有检查大商所期权不支持市价单 * 优化用户 import pandas 遇到 ImportError 时问题提示 * 更新优化文档，增加股票相关示例，更新示例中的期货合约，标注文档中 objs 对象类型说明 1.8.2 (2020/07/07) * 增加提供高级委托指令 FAK、FOK，并增加相关文档说明 :ref:`advanced_order`、示例代码 * 本地模拟交易 sim 支持 FAK、FOK 交易指令，快期模拟暂不支持 * 优化登录请求流程 * 优化测试用例代码，增加关于交易指令的测试用例 * 完善文档内容 1.8.1 (2020/06/19) * 增加 :py:class:`~tqsdk.account.TqKq` 账户类型，可以使用统一的快期模拟账户登录，详情点击 :ref:`sim_trading` * 增加支持指数回测 * 支持 `with TqApi() as api` 写法 * quote 对象增加 exchange_id 字段，表示交易所代码 * 重构 sim 模块代码，便于接入新版行情服务器 * 修复 settargetpos 回测时，在一个交易时段内最后一根 K 线下单无法成交的 bug * 修复回测时某些品种夜盘无法交易的 bug * 修复 ticksinfo 函数在 pandas 版本低于 1.0.0 无法正常使用的 bug * 优化日志输出，实盘下默认启用日志 * 更新 logo，整理优化文档，增加股票行情、主连获取主力等文档说明，优化示例代码目录结构 * 修改、优化测试用例及 CI 流程 1.8.0 (2020/05/12) * 股票行情测试版发布，**_stock 参数设置为 True 可以连接测试行情服务器，提供股票数据** `详细说明请点击查看 <https://www.shinnytech.com/blog/%e5%a4%a9%e5%8b%a4%e9%87%8f%e5%8c%961-8-0_beta%ef%bc%8c%e6%94%af%e6%8c%81%e8%82%a1%e7%a5%a8%e8%a1%8c%e6%83%85%e8%8e%b7%e5%8f%96%ef%bc%81/>`_ * 增加计算 ticks 开平方向函数(详见: :py:meth:`~tqsdk.tafunc.get_ticks_info` ) * 修复 sim 撤单未检查单号是否可撤 * 重构代码，优化模块划分 * 修改测试脚本和测试用例，提高持续集成效率 1.7.0 (2020/04/16) * **支持期权模拟交易，支持期权回测** * 增加期权指标的计算公式 (希腊值、隐含波动率、理论价等) * 增加TqSim模拟交易成交时间判断 (非交易时间段下的委托单将被判定为错单，以减小模拟帐号与实盘的差距) * 增加账户、持仓中的市值字段 (如果交易了期权，则模拟帐号的账户、持仓字段的定义有一些改变(详见: :py:class:`tqsdk.objs.Account` )) * 修复一个可能导致复盘连接失败的问题 * 优化示例代码 * 优化文档 (增加 :ref:`option_trade` 文档内容、增加在 :ref:`unanttended` 教程内容、优化文档其他细节） 1.6.3 (2020/03/16) * 修复vscode 插件中不能登录交易的bug * 增加免责声明 * 增加、完善测试用例 * 修改文档 1.6.2 (2020/02/18) * 修改 web_gui 默认显示的 ip 地址为 127.0.0.1 * 修复 web_gui 不显示成交记录箭头的问题 * 策略结束后 api 将关闭所有 web 链接 * 优化对 vscode 的支持 * 增加 Quote 的 option_class (期权方向)和 product_id (品种代码)字段 * 优化文档 1.6.1 (2020/02/12) * 修复 web_gui 不显示成交记录的问题 * 修复 python3.8 下设置 web_gui 参数无效的问题 1.6.0 (2020/02/11) * 交易网关升级, **所有用户需升级至 1.6.0 版本以上** * 修复参数搜索时由于 TargetPosTask 单实例造成的内存泄漏 * web_gui 参数格式改成 [ip]:port, 允许公网访问 * 改进 web 界面，增加分时图，优化盘口显示内容，修复相关问题 * 修改 barlast() 的返回值为 pandas.Series 类型序列 * 优化回测的成交时间准确性 * 完善文档内容 1.5.1 (2020/01/13) * 优化 TqApi 参数 web_gui, 允许指定网页地址和端口(详见: :ref:`web_gui` ) * 更新优化 vscode 插件以及web 页面 * 简化画图函数color的参数 * 增加 barlast 功能函数(详见: :py:meth:`~tqsdk.tafunc.barlast` ) * 优化多合约k线报错提示及示例 * 修复 TargetPosTask 进行参数搜索时无法正确执行的bug * 修复可能触发的回测结果计算报错的问题 * 增加测试用例 * 完善文档内容 1.5.0 (2020/01/06) * 支持股票上线准备，增加天勤用户认证 * TqSim 的 trade_log 改为公开变量 * 完善文档内容 1.4.0 (2019/12/25) * 在 TqSdk 中直接支持复盘功能(详见: :ref:`replay` ) * 增加回测报告内容(胜率、每手盈亏额比例) * 从当前版本开始，不再支持天勤终端合约代码图形显示 * 修复 web_gui 功能中的部分已知问题 * 修复在一些情况无法输出回测报告的问题 * 修复使用 slave/master 多线程模式时的报错问题 * 修复回测结束前最后一条行情未更新的bug * 从 logger 中分离从服务器返回的通知信息(以便单独处理或屏蔽) * 修复使用 TargetPoseTask 实例时可能引发的报错 * 完善文档内容 1.3.2 (2019/12/19) * 修复在填写了画图的 color 参数时引起的报错 * 修复在 vscode 插件和天勤终端中不能运行策略的bug * 完善文档内容 1.3.1 (2019/12/18) * 支持通过 :py:class:`tqsdk.TqApi` 内 **设置 web_gui=True 参数以实现实盘/回测的图像化支持** , (详见: :ref:`web_gui` ) * 增加支持 Python3.8 * 完善 TqSdk 各公开函数的参数类型标注及函数返回值类型标注 * 将 api 中除业务数据以外的所有变量私有化 * 完善测试用例 * 完善文档内容 1.2.1 (2019/12/04) * 完善 insert_order() 函数返回的 order 的初始化字段：增加 limit_price、price_type、volume_condition、time_condition 字段 * 增加 quote 行情数据中的 trading_time、expire_datetime、delivery_month、delivery_year、ins_class 字段 * 删除 quote 行情数据中的 change、change_percent 字段 * 修复重复发送K线订阅指令给服务器的bug * 修复未订阅行情时回测不能立即结束的bug * 完善测试用例 * 完善文档内容 1.2.0 (2019/11/21) * 支持同时获取对齐的多合约 K 线 (详见 :py:meth:`~tqsdk.TqApi.get_kline_serial` ) * 修复回测时未将非 TqSim 账号转换为 TqSim 的 bug * 修复 wait_update() 填写 deadline 参数并等待超时后向服务器发送大量消息 * 完善测试用例 * 完善示例程序 * 完善文档内容 1.1.0 (2019/10/15) * 增加时间类型转换的功能函数 (详见 :py:meth:`~tqsdk.tafunc` ) * 修复与天勤连接时的一些bug * 完善测试用例及测试环境配置 * 修改回测log内容,去除回测时log中的当前本地时间 * 完善文档内容 1.0.0 (2019/09/19) * 修复: 各id生成方式 * 修复: 重复输出日志 * 修复: 命令行运行策略文件时,复盘模式下的参数返回值 * 添加持续集成功能 * 完善文档内容 0.9.18 (2019/09/11) * 修复: 断线重连时触发的一系列bug * 修复: register_update_notify 以 klines 作为参数输入时报错的bug * 修复: 因不能删除业务数据导致的内存泄漏bug * 部分修复: diff中的数据不是dict类型导致的bug * 增加gui相关示例程序及文档 * 增加单元测试用例 * 完善文档内容 0.9.17 (2019/08/27) * 修复: TqApi.copy()创建slave实例时工作不正常的bug * 改进行情订阅信息同步到天勤的机制 * 改进TqSdk运行错误传递给天勤的机制 * 将TqApi的私有成员名字前加前缀下划线 * 增加各公开函数的返回值类型标注 * 支持使用email地址作为模拟交易账号 * 增强TargetPosTask及指标函数等内容的说明文档 0.9.15 (2019/08/14) * 调整tqsdk与天勤的连接机制 * 去除get_order()及get_position()等函数的返回值中与业务无关的""_path"", ""_listener"" 数据, 使其只返回业务数据 * 添加对公开函数输入值类型及范围的检查 0.9.9 (2019/07/22) * 持仓对象 :py:class:`~tqsdk.objs.Position` 增加了实时持仓手数属性 pos_long_his, pos_long_today, pos_short_his, pos_short_today ，这些属性在成交时与成交记录同步更新 * 修正 :py:class:`~tqsdk.TargetPosTask` 因为持仓手数更新不同步导致下单手数错误的bug * 取消交易单元机制 0.9.8 (2019/06/17): * :py:class:`~tqsdk.TqApi` 增加 copy 函数，支持在一个进程中用master/slave模式创建多个TqApi实例 0.9.7 (2019/06/03): * 修正持仓数据不能 copy() 的问题 0.9.6 (2019/05/30): * :py:class:`~tqsdk.objs.Quote`, :py:class:`~tqsdk.objs.Account`, :py:class:`~tqsdk.objs.Position`, :py:class:`~tqsdk.objs.Order`, :py:class:`~tqsdk.objs.Trade` 的成员变量名在IDE中支持自动补全(Pycharm测试可用) * :py:class:`~tqsdk.objs.Order` 增加了 :py:meth:`~tqsdk.objs.Order.is_dead` 属性 - 用于判定委托单是否确定已死亡（以后一定不会再产生成交） * :py:class:`~tqsdk.objs.Order` 增加了 :py:meth:`~tqsdk.objs.Order.is_online` 属性 - 用于判定这个委托单是否确定已报入交易所（即下单成功，无论是否成交） * :py:class:`~tqsdk.objs.Order` 增加了 :py:meth:`~tqsdk.objs.Order.is_error` 属性 - 用于判定这个委托单是否确定是错单（即下单失败，一定不会有成交） * :py:class:`~tqsdk.objs.Order` 增加了 :py:meth:`~tqsdk.objs.Order.trade_price` 属性 - 委托单的平均成交价 * :py:class:`~tqsdk.objs.Order` 增加了 :py:meth:`~tqsdk.objs.Order.trade_records` 属性 - 委托单的成交记录 * 文档细节修正 0.9.5 (2019/05/24): * 加入期货公司次席支持, 创建 TqAccount 时可以通过 front_broker 和 front_url 参数指定次席服务器 0.9.4 (2019/05/22): * 修正穿透式监管采集信息编码问题 0.9.3 (2019/05/22): * (BREAKING) 模拟交易默认资金调整为一千万 * 加入穿透式监管支持. 用户只需升级 TqSdk 到此版本, 无需向期货公司申请AppId, 即可满足穿透式监管信息采集规范要求. 0.9.2 (2019/05/07): * 修正画图相关函数 0.9.1 (2019/04/15): * (BREAKING) TqApi.get_quote, get_kline_serial, get_account 等函数, 现在调用时会等待初始数据到位后才返回 * (BREAKING) k线序列和tick序列格式改用pandas.DataFrame * 支持上期所五档行情 * 增加 数十个技术指标 和 序列计算函数, 使用纯python实现. 加入ta和ta_func库 * 加入策略单元支持. 在一个账户下运行多个策略时, 可以实现仓位, 报单的相互隔离 * 加强与天勤终端的协作，支持策略程序在天勤中画图, 支持回测结果图形化显示与分析, 支持策略运行监控和手工下单干预 * 示例程序增加随机森林(random_forest)策略 * 示例程序增加菲阿里四价策略 0.8.9 (2019/01/21): * 加入双均线策略 * 加入网格交易策略 * 数据下载器支持按交易日下载数据 * 修正模拟交易数据不正确的问题 * 修正回测时出现“平仓手数不足""的问题 2018/12/12: * 加入直连行情交易服务器模式 * 模拟交易结束后输出交易报告 * 修正回测时账户资金计算错误的问题 2018/11/16: * 加入策略回测功能 2018/10/25: * 加入海龟策略 2018/10/17: * 加入 dual thrust 策略 * 加入 r-breaker 策略 2018/08/30: * 目标持仓模型(TargetPosTask)支持上期所的平今平昨和中金所禁止平今 * K线/Tick序列加入 to_dataframe 函数将数据转为 pandas.DataFrame * 加入 close 函数用于退出时清理各种资源 * wait_update 由设定超时秒数改为设定截止时间, 并返回是否超时 * 加入调试模式，将调试信息写入指定的文件中 * 修正和某些开发环境不兼容的问题 * 规范了各业务数据的类型 * register_update_notify 支持监控特定的业务数据 2018/08/10: * 目标持仓Task自动处理上期所平今/平昨 * 主力合约加入 underlying_symbol 字段用来获取标的合约 * 更新文档 "
9,n\doc\advanced\backtest,"n\doc\advanced\backtest. .. _batch_backtest: 批量回测, 参数搜索及其它 ================================================= 在阅读本文档前, 请确保您已经熟悉了 :ref:`backtest` 参数优化/参数搜索 ------------------------------------------------- TqSdk 并不提供专门的参数优化机制. 您可以按照自己的需求, 针对可能的每个参数值安排一个回测, 观察它们的回测结果, 以简单的双均线策略为例:: from tqsdk import TqApi, TqAuth, TqSim, TargetPosTask, BacktestFinished, TqBacktest from tqsdk.tafunc import ma from datetime import date LONG = 60 SYMBOL = ""SHFE.cu1907"" for SHORT in range(20, 40): # 短周期参数从20-40分别做回测  acc = TqSim()    # 每次回测都创建一个新的模拟账户  try:  api = TqApi(acc, backtest=TqBacktest(start_dt=date(2019, 5, 6), end_dt=date(2019, 5, 10)), auth=TqAuth(""信易账户"", ""账户密码""))  account = api.get_account()  klines = api.get_kline_serial(SYMBOL, duration_seconds=60, data_length=LONG + 2)  target_pos = TargetPosTask(api, SYMBOL)  while True:   api.wait_update()   if api.is_changing(klines.iloc[-1], ""datetime""):   short_avg = ma(klines.close, SHORT)   long_avg = ma(klines.close, LONG)   if long_avg.iloc[-2] < short_avg.iloc[-2] and long_avg.iloc[-1] > short_avg.iloc[-1]:    target_pos.set_target_volume(-1)   if short_avg.iloc[-2] < long_avg.iloc[-2] and short_avg.iloc[-1] > long_avg.iloc[-1]:    target_pos.set_target_volume(1)  except BacktestFinished:  api.close()  print(""SHORT="", SHORT, ""最终权益="", account[""balance""]) # 每次回测结束时, 输出使用的参数和最终权益 多进程并发执行多个回测任务 ------------------------------------------------- 如果您有大量回测任务想要尽快完成, 您首先需要一台给力的电脑(可以考虑到XX云上租一台32核的, 一小时几块钱). 然后您就可以并发执行N个回测了. 还是以上面的策略为例:: from tqsdk import TqApi, TqAuth, TqSim, TargetPosTask, BacktestFinished, TqBacktest from tqsdk.tafunc import ma from datetime import date import multiprocessing from multiprocessing import Pool def MyStrategy(SHORT):  LONG = 60  SYMBOL = ""SHFE.cu1907""  acc = TqSim()  try:  api = TqApi(acc, backtest=TqBacktest(start_dt=date(2019, 5, 6), end_dt=date(2019, 5, 10)), auth=TqAuth(""信易账户"", ""账户密码""))  data_length = LONG + 2  klines = api.get_kline_serial(SYMBOL, duration_seconds=60, data_length=data_length)  target_pos = TargetPosTask(api, SYMBOL)  while True:   api.wait_update()   if api.is_changing(klines.iloc[-1], ""datetime""):   short_avg = ma(klines.close, SHORT)   long_avg = ma(klines.close, LONG)   if long_avg.iloc[-2] < short_avg.iloc[-2] and long_avg.iloc[-1] > short_avg.iloc[-1]:    target_pos.set_target_volume(-3)   if short_avg.iloc[-2] < long_avg.iloc[-2] and short_avg.iloc[-1] > long_avg.iloc[-1]:    target_pos.set_target_volume(3)  except BacktestFinished:  api.close()  print(""SHORT="", SHORT, ""最终权益="", acc.account.balance) # 每次回测结束时, 输出使用的参数和最终权益  if __name__ == '__main__':  multiprocessing.freeze_support()  p = Pool(4)        # 进程池, 建议小于cpu数  for s in range(20, 40):  p.apply_async(MyStrategy, args=(s,)) # 把20个回测任务交给进程池执行  print('Waiting for all subprocesses done...')  p.close()  p.join()  print('All subprocesses done.') **注意: 由于服务器流控限制, 同时执行的回测任务请勿超过10个** "
10,n\doc\advanced\dingding,"n\doc\advanced\dingding. .. _dingding: 将程序信息推送到手机端 ================================================= TqSdk 并不提供专门的服务器来推送消息，但是你可以通过其他 SDK 来做到这个效果，在发生成交或者条件满足时，进行消息推送，以钉钉为例::  from datetime import datetime, time, timedelta  import requests  from json import dumps  from tqsdk import TqApi, TqAuth, TargetPosTask  def send_msg(content):   """"""钉钉消息提醒模块""""""   webhook = ""设置自己的钉钉 webhook""   # 钉钉安全规则将 天勤量化 设为关键字   msg = {""msgtype"": ""text"",    ""text"": {""content"": ""{}\n{}\n"".format(""天勤量化\n"" + content,              datetime.now().strftime(""%Y-%m-%d %H:%M:%S""))}, }   headers = {""content-type"": ""application/json;charset=utf-8""}   body = dumps(msg)   requests.post(webhook, data=body, headers=headers)   print(content)  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))  quote = api.get_quote(""SHFE.rb2109"")  target_pos = TargetPosTask(api, ""SHFE.rb2110"")  send_msg(""策略开始运行"")  a = 0  while True:   api.wait_update()   # 通过本地变量 a 来避免多次发送钉钉消息触发流控   if quote.last_price > 5110 and a == 0:    send_msg(""行情满足条件，开多头5手"")    target_pos.set_target_volume(5)    a = 1 具体说明，请参考 `钉钉操作手册 <https://developers.dingtalk.com/document/app/custom-robot-access>`_ "
11,n\doc\advanced\entry,"n\doc\advanced\entry. .. _entry: 策略程序的多种入口场景 ==================================================== 基于TqSdk开发的策略程序可能在多种场景下运行 用户自己在独立python环境下执行策略程序 ---------------------------------------------------- 一种常见的运行方式是用户自己运行python策略程序, 象这样::  $python3 my_prog.py 在这种场景下，用户需要在TqApi创建时提供必要的参数 TqApi 独立运行模拟交易 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 创建 TqApi 实例时传入 TqSim ::  from tqsdk import TqApi, TqAuth, TqSim  api = TqApi(TqSim(), auth=TqAuth(""信易账户"", ""账户密码"")) 或者不填其他参数, 默认为使用TqSim::  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) TqApi 独立运行实盘交易 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 创建 TqApi 实例时传入 TqAccount ::  from tqsdk import TqApi, TqAuth, TqAccount  api = TqApi(TqAccount(""H海通期货"", ""022631"", ""123456""), auth=TqAuth(""信易账户"", ""账户密码"")) 特别的, 如果需要连接到期货公司的特定服务器, 可以在 TqAccount 中指定::  api = TqApi(TqAccount(""H海通期货"", ""022631"", ""123456"", front_broker=""8888"", front_url=""tcp://134.232.123.33:41205""), auth=TqAuth(""信易账户"", ""账户密码"")) 如果要连接到自己架设的交易网关, 可以使用::  api = TqApi(TqAccount(""H海通期货"", ""022631"", ""123456""), url=""ws://202.33.21.34:7878/"", auth=TqAuth(""信易账户"", ""账户密码"")) TqApi 独立运行回测 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 创建 TqApi 实例时传入 TqBacktest ::  from tqsdk import TqApi, TqAuth, TqSim, TqBacktest  api = TqApi(TqSim(), backtest=TqBacktest(start_dt=date(2018, 5, 1), end_dt=date(2018, 10, 1)), auth=TqAuth(""信易账户"", ""账户密码"")) 由天勤拉起策略进程 ---------------------------------------------------- 策略程序由天勤拉起执行时, TqApi始终使用默认构造函数, 由天勤提供命令行参数设定策略程序运行方式. 命令行参数包括这些: * _action : run/backtest/mdreplay, 指定运行方式 * _tq_pid : int, 天勤进程ID. 策略进程会监控天勤进程的存活情况, 天勤进程退出时所有由天勤创建的策略进程都会自行终止 * _tq_url : str, 天勤ws入口. 策略进程通过此端口与天勤通讯 当 _action == run 时, 策略程序按正常交易模式运行, 其它参数: * _broker_id : str, 期货公司代码 * _account_id : str, 用户账号 * _password : str, 用户密码 当 _action == backtest 时, 策略程序按回测模式运行, 其它参数: * _dt_start : YYYYMMDD, 回测起始日期 * _dt_end : YYYYMMDD, 回测结束日期 当 _action == mdreplay 时, 策略程序按复盘模式运行, 其它参数: * _ins_url : url, 合约服务地址 * _md_url : url, 行情服务地址 天勤发起实盘运行(含快期模拟) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 天勤通过命令行参数传递交易账户信息给策略进程::  $ python3 my_prog.py --_action=run --_tq_pid=3233 --_tq_url=ws://127.0.0.1:7777 --_broker_id=快期模拟 --_account_id=13012345678 --_password=123456 天勤发起回测 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 天勤通过命令行参数传递交易账户信息给策略进程::  $ python3 my_prog.py --_action=backtest --_tq_pid=3233 --_tq_url=ws://127.0.0.1:7777 --_dt_start=20180101 --_dt_end=20180630 天勤发起复盘 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 天勤先创建好复盘服务器, 再传递::  $ python3 my_prog.py --_action=mdreplay --_tq_pid=3233 --_tq_url=ws://127.0.0.1:7777 --_md_url=ws://239.12.212.34:43232/... --ins_url=http://123.23.12.34/... 更复杂的情形 ---------------------------------------------------- 将独立运行的策略进程连接到天勤作监控 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 暂未支持 "
12,n\doc\advanced\evolution,"n\doc\advanced\evolution. 使用逐步完善的方式构建交易策略 ================================================= `TqSdk`_ 的目标是能尽可能减少编码环节引入的坑，而交易逻辑本身的坑则需要用户自己填，如果每次调整交易逻辑都需要大规模的代码重构会严重阻碍交易系统的演化。 `TqSdk`_ 鼓励使用线性的编码风格，因此可以做到小调交易逻辑只需小改，只有大调交易逻辑时才需要大改。以 `R-Breaker`_ 策略为例， 第一版是留仓过夜，回测下来可能发现留仓过夜引入了很大的风险，却没有获得与风险对应的收益，因此修改交易策略，收盘前清仓离场， 对应代码的修改只需在主循环中加入判断是否接近收盘并平仓::  if api.is_changing(quote, ""datetime""):   now = datetime.strptime(quote.datetime, ""%Y-%m-%d %H:%M:%S.%f"")   if now.hour == close_hour and now.minute >= close_minute: # 到达平仓时间: 平仓    print(""临近本交易日收盘: 平仓"")    target_pos.set_target_volume(0) # 平仓    deadline = time.time() + 60    while api.wait_update(deadline=deadline): # 等待60秒     pass    api.close()    break 上述代码在行情时间变化时判断是否接近收盘，如果是的话则将目标持仓设为0(即空仓)。由于下单之后不一定能立即成交，价格变化后可能还需撤单重下， 因此等待一分钟后再退出，通常交易的合约不是太冷门的话一分钟应该足够了，如果不放心的话可以改为判断持仓手数是否为0。 更多的用例可以参见: https://doc.shinnytech.com/pysdk/latest/demo.html  .. _TqSdk: https://doc.shinnytech.com/pysdk/latest/index.html .. _TqSim: https://doc.shinnytech.com/pysdk/latest/reference.html#tqsdk.sim.TqSim .. _get_kline_serial: https://doc.shinnytech.com/pysdk/latest/reference.html#tqsdk.api.TqApi.get_kline_serial .. _TargetPosTask: https://doc.shinnytech.com/pysdk/latest/reference.html#tqsdk.lib.TargetPosTask .. _wait_update: https://doc.shinnytech.com/pysdk/latest/reference.html#tqsdk.api.TqApi.wait_update .. _DIFF: https://doc.shinnytech.com/diff/latest/index.html .. _get_account: https://doc.shinnytech.com/pysdk/latest/reference.html#tqsdk.api.TqApi.get_account .. _get_quote: https://doc.shinnytech.com/pysdk/latest/reference.html#tqsdk.api.TqApi.get_quote .. _is_changing: https://doc.shinnytech.com/pysdk/latest/reference.html#tqsdk.api.TqApi.is_changing .. _TqBacktest: https://doc.shinnytech.com/pysdk/latest/reference.html#tqsdk.backtest.TqBacktest .. _R-Breaker: https://github.com/shinnytech/tqsdk-python/blob/master/tqsdk/demo/example/rbreaker.py "
13,n\doc\advanced\for ctp user,"n\doc\advanced\for ctp user. .. _for_ctp_user: TqSdk与使用Ctp接口开发策略程序有哪些差别 ================================================= 如果您曾经直接使用CTP接口开发过交易策略程序, 目前刚开始接触 TqSdk, 下面的信息将帮助您尽快理解 TqSdk. 系统整体架构 ------------------------------------------------- CTP接口直接连接到期货公司交易系统, 从期货公司系统获取行情并执行交易指令. TqSdk 则使用基于网络协作的组件设计. 如下图: .. raw:: html <svg xmlns=""http://www.w3.org/2000/svg"" xmlns:xlink=""http://www.w3.org/1999/xlink"" version=""1.1"" width=""761px"" viewBox=""-0.5 -0.5 761 261"" style=""max-width:100%;max-height:261px;""><defs/><g><path d=""M 620 60 L 620 40"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><a xlink:href=""https://github.com/shinnytech/open-md-gateway""><rect x=""480"" y=""60"" width=""280"" height=""40"" fill=""#fff2cc"" stroke=""#d6b656""/><g transform=""translate(569.5,66.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""100"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 102px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><div><a href=""https://github.com/shinnytech/open-md-gateway"">Open Md Gateway</a></div><div><a href=""https://github.com/shinnytech/open-md-gateway"">行情网关</a></div></div></div></foreignObject><text x=""50"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a><a xlink:href=""https://github.com/shinnytech/open-trade-gateway""><rect x=""0"" y=""60"" width=""280"" height=""40"" fill=""#fff2cc"" stroke=""#d6b656""/><g transform=""translate(82.5,66.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""114"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 116px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><a href=""https://github.com/shinnytech/open-trade-gateway"">Open Trade Gateway<br />交易中继网关</a><br /></div></div></foreignObject><text x=""57"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a><rect x=""0"" y=""0"" width=""280"" height=""40"" fill=""#eeeeee"" stroke=""#36393d""/><g transform=""translate(84.5,6.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""110"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 110px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">期货公司交易系统<br />CTP / FEMAS / UFX<br /></div></div></foreignObject><text x=""55"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">期货公司交易系统&lt;br&gt;CTP / FEMAS / UFX&lt;br&gt;</text></switch></g><rect x=""480"" y=""0"" width=""280"" height=""40"" fill=""#eeeeee"" stroke=""#36393d""/><g transform=""translate(577.5,13.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""84"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 85px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">交易所行情系统<br /></div></div></foreignObject><text x=""42"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">交易所行情系统&lt;br&gt;</text></switch></g><path d=""M 140 60 L 140 40"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10""/><path d=""M 380 120 L 140 100"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10""/><path d=""M 380 120 L 620 100"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10""/><a xlink:href=""http://doc.shinnytech.com/diff/latest/""><rect x=""0"" y=""120"" width=""760"" height=""40"" rx=""6"" ry=""6"" fill=""#f8cecc"" stroke=""#b85450""/><g transform=""translate(352.5,133.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""54"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 55px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><a href=""https://github.com/shinnytech/diff"">DIFF 协议</a></div></div></foreignObject><text x=""27"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a><path d=""M 380 180 L 380 160"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10""/><a xlink:href=""http://www.shinnytech.com/tianqin""><rect x=""320"" y=""180"" width=""120"" height=""40"" fill=""#dae8fc"" stroke=""#6c8ebf""/><g transform=""translate(355.5,193.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""48"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 49px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><a href=""http://www.tq18.cn"">天勤终端</a></div></div></foreignObject><text x=""24"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a><a xlink:href=""https://github.com/shinnytech/tqsdk-python""><rect x=""320"" y=""220"" width=""120"" height=""40"" fill=""#dae8fc"" stroke=""#6c8ebf""/><g transform=""translate(362.5,233.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""34"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 36px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><a href=""https://github.com/shinnytech/tqsdk-python"">TqSdk</a><br /></div></div></foreignObject><text x=""17"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a></g></svg> 如图所示, 整个系统结构包括这些关键组件: * 行情网关 (Open Md Gateway) 负责提供实时行情和历史数据 * 交易中继网关 (Open Trade Gateway) 负责连接到期货公司交易系统 * 上面两个网关统一以 Diff 协议对下方提供服务 * 天勤终端和TqSdk按照Diff协议连接到行情网关和交易中继网关, 实现行情和交易功能 这样的结构可以给用户带来一些好处: * TqSdk 很小, 安装也很方便, 只要简单 pip install tqsdk 即可 * 官方专门运维行情数据库, 用户可以直接使用, 不需要自己接收和存储数据 * 交易相关接口被大幅度简化, 不再需要处理CTP接口的复杂回调, 也不需要发起任何查询请求 * 任何语言只要支持websocket协议, 都可以用来进行策略开发 也有一些不如直接使用CTP接口方便的地方: * 由于交易指令经交易网关转发, 用户无法直接指定CTP服务器地址. 用户如果需要连接到官方交易网关不支持的期货公司, 需要自行部署交易网关. K线数据与指标计算 ------------------------------------------------- Ctp接口不提供K线数据. 在TqSdk中, K线数据和其它行情数据一样是由行情网关生成并推送的: * 用户不再需要维护K线数据库. 用户电脑实时行情中断后, 也不再需要补历史数据 * 行情服务器生成K线时, 采用了按K线时间严格补全对齐的算法. 这与其它软件有明显区别, 详见 https://www.shinnytech.com/blog/why-our-kline-different/ * 行情数据只在每次程序运行时通过网络获取, 不在用户硬盘保存. 如果策略研究工作需要大量静态历史数据, 我们推荐使用数据下载工具, 另行下载csv文件使用. TqSdk中的K线序列采用 pandas.DataFrame 格式. pandas 提供了 `非常丰富的数据处理函数 <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html>`_ , 使我们可以非常方便的进行数据处理, 例如:: ks = api.get_kline_serial(""SHFE.cu1901"", 60) print(ks.iloc[-1])   # <- 最后一根K线 print(ks.close)    # <- 收盘价序列 ks.high - ks.high.shift(1) # <- 每根K线最高价-前一根K线最高价, 形成一个新序列  TqSdk 也通过 :py:mod:`tqsdk.tafunc` 提供了一批行情分析中常用的计算函数, 例如::  from tqsdk import tafunc ks = api.get_kline_serial(""SHFE.cu1901"", 60) ms = tafunc.max(ks.open, ks.close)   # <- 取每根K线开盘价和收盘价的高者构建一个新序列 median3 = tafunc.median(ks.close, 100)  # <- 求最近100根K线收盘价的中间值 ss = tafunc.std(ks.close, 5)     # <- 每5根K线的收盘价标准差 数据接收和更新 ------------------------------------------------- Ctp接口按照事件回调模型设计, 使用 CThostFtdcTraderSpi 的 OnXXX 回调函数进行行情数据和回单处理:: class MySpiHandler  : public CThostFtdcTraderSpi { public:  ///当客户端与交易后台建立起通信连接时（还未登录前），该方法被调用。  virtual void OnFrontConnected();  ///报单通知  virtual void OnRtnOrder(CThostFtdcOrderField *pOrder);  ///成交通知  virtual void OnRtnTrade(CThostFtdcTradeField *pTrade); }  TqSdk则不使用事件回调机制. :py:meth:`~tqsdk.TqApi.wait_update` 函数设计用来获取任意数据更新, 像这样:: api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) x = api.insert_order(""SHFE.cu1901"", direction=""BUY"", offset=""OPEN"", volume=1, limit_price=50000)  while True:  api.wait_update()  # <- 这个 wait_update 将尝试更新所有数据. 如果没有任何新信息, 程序会阻塞在这一句. 一旦有任意数据被更新, 程序会继续往下执行  print(x)    # <- 显示委托单最新状态 一次 wait_update 可能更新多个实体, 在这种情况下, :py:meth:`~tqsdk.TqApi.is_changing` 被用来判断某个实体是否有变更:: api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) q = api.get_quote(""SHFE.cu1901"") ks = api.get_kline_serial(""SHFE.cu1901"", 60) x = api.insert_order(""SHFE.cu1901"", direction=""BUY"", offset=""OPEN"", volume=1, limit_price=50000)  while True:  api.wait_update()  # <- 这个 wait_update 将尝试更新所有数据. 如果没有任何新信息, 程序会阻塞在这一句. 一旦有任意数据被更新, 程序会继续往下执行  if api.is_changing(q): # <- 这个 is_changing 用来判定这次更新是否影响到了q  print(q)   if api.is_changing(x, ""status""): # <- 这个 is_changing 用来判定这次更新是否影响到了报单的status字段  print(x) TqSdk针对行情数据和交易信息都采用相同的 wait_update/is_changing 方案. 用户需要记住的要点包括: * get_quote, get_kline_serial, insert_order 等业务函数返回的是一个引用(refrence, not value), 它们的值总是在 wait_update 时更新. * 用户程序除执行自己业务逻辑外, 需要反复调用 wait_update. 在两次 wait_update 间, 所有数据都不更新 * 用 insert_order 函数下单, 报单指令实际是在 insert_order 后调用 wait_update 时发出的. * 用户程序中需要避免阻塞, 不要使用 sleep 暂停程序 关于 wait_update 机制的详细说明, 请见 :ref:`framework` "
14,n\doc\advanced\for vnpy user,"n\doc\advanced\for vnpy user. .. _for_vnpy_user: TqSdk 与 vn.py 有哪些差别 ================================================= TqSdk 与 vn.py 有非常多的差别. 如果您是一位有经验的 vn.py 用户, 刚开始接触 TqSdk, 下面的信息将帮助您尽快理解 TqSdk. 系统整体架构 ------------------------------------------------- vn.py 是一套 all-in-one 的结构, 在一个Python软件包中包含了数据库, 行情接收/存储, 交易接口, 图形界面等功能. TqSdk 则使用基于网络协作的组件设计. 如下图: .. raw:: html <svg xmlns=""http://www.w3.org/2000/svg"" xmlns:xlink=""http://www.w3.org/1999/xlink"" version=""1.1"" width=""761px"" viewBox=""-0.5 -0.5 761 261"" style=""max-width:100%;max-height:261px;""><defs/><g><path d=""M 620 60 L 620 40"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><a xlink:href=""https://github.com/shinnytech/open-md-gateway""><rect x=""480"" y=""60"" width=""280"" height=""40"" fill=""#fff2cc"" stroke=""#d6b656""/><g transform=""translate(569.5,66.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""100"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 102px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><div><a href=""https://github.com/shinnytech/open-md-gateway"">Open Md Gateway</a></div><div><a href=""https://github.com/shinnytech/open-md-gateway"">行情网关</a></div></div></div></foreignObject><text x=""50"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a><a xlink:href=""https://github.com/shinnytech/open-trade-gateway""><rect x=""0"" y=""60"" width=""280"" height=""40"" fill=""#fff2cc"" stroke=""#d6b656""/><g transform=""translate(82.5,66.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""114"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 116px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><a href=""https://github.com/shinnytech/open-trade-gateway"">Open Trade Gateway<br />交易中继网关</a><br /></div></div></foreignObject><text x=""57"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a><rect x=""0"" y=""0"" width=""280"" height=""40"" fill=""#eeeeee"" stroke=""#36393d""/><g transform=""translate(84.5,6.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""110"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 110px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">期货公司交易系统<br />CTP / FEMAS / UFX<br /></div></div></foreignObject><text x=""55"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">期货公司交易系统&lt;br&gt;CTP / FEMAS / UFX&lt;br&gt;</text></switch></g><rect x=""480"" y=""0"" width=""280"" height=""40"" fill=""#eeeeee"" stroke=""#36393d""/><g transform=""translate(577.5,13.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""84"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 85px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">交易所行情系统<br /></div></div></foreignObject><text x=""42"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">交易所行情系统&lt;br&gt;</text></switch></g><path d=""M 140 60 L 140 40"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10""/><path d=""M 380 120 L 140 100"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10""/><path d=""M 380 120 L 620 100"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10""/><a xlink:href=""http://doc.shinnytech.com/diff/latest/""><rect x=""0"" y=""120"" width=""760"" height=""40"" rx=""6"" ry=""6"" fill=""#f8cecc"" stroke=""#b85450""/><g transform=""translate(352.5,133.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""54"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 55px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><a href=""https://github.com/shinnytech/diff"">DIFF 协议</a></div></div></foreignObject><text x=""27"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a><path d=""M 380 180 L 380 160"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10""/><a xlink:href=""http://www.shinnytech.com/tianqin""><rect x=""320"" y=""180"" width=""120"" height=""40"" fill=""#dae8fc"" stroke=""#6c8ebf""/><g transform=""translate(355.5,193.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""48"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 49px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><a href=""http://www.tq18.cn"">天勤终端</a></div></div></foreignObject><text x=""24"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a><a xlink:href=""https://github.com/shinnytech/tqsdk-python""><rect x=""320"" y=""220"" width=""120"" height=""40"" fill=""#dae8fc"" stroke=""#6c8ebf""/><g transform=""translate(362.5,233.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""34"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 36px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;""><a href=""https://github.com/shinnytech/tqsdk-python"">TqSdk</a><br /></div></div></foreignObject><text x=""17"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">[Not supported by viewer]</text></switch></g></a></g></svg> 如图所示, 整个系统结构包括这些关键组件: * 行情网关 (Open Md Gateway) 负责提供实时行情和历史数据 * 交易中继网关 (Open Trade Gateway) 负责连接到期货公司交易系统 * 上面两个网关统一以 Diff 协议对下方提供服务 * 天勤终端和TqSdk按照Diff协议连接到行情网关和交易中继网关, 实现行情和交易功能 这样的结构可以给用户带来一些好处: * TqSdk 很小, 安装也很方便, 只要简单 pip install tqsdk 即可 * 官方专门运维行情数据库, 用户可以直接使用, 不需要自己接收和存储数据 * 交易相关接口被大幅度简化, 不再需要处理CTP接口的复杂回调, 也不需要发起任何查询请求 也有一些不如vn.py方便的地方: * 由于交易指令经交易网关转发, 用户无法直接指定CTP服务器地址. 用户如果需要连接到官方交易网关不支持的期货公司, 需要自行部署交易网关. 每个策略是一个单独运行的py文件 ------------------------------------------------- 在 vn.py 中, 要实现一个策略程序, 通常是从 CtaTemplate 等基类派生一个子类, 像这样:: class DoubleMaStrategy(CtaTemplate):  parameters = [""fast_window"", ""slow_window""]  variables = [""fast_ma0"", ""fast_ma1"", ""slow_ma0"", ""slow_ma1""]  def __init__(self, cta_engine, strategy_name, vt_symbol, setting):  ...    def on_tick(self, tick: TickData):  ...  def on_bar(self, bar: BarData):  ... 这个 DoubleMaStrategy 类写好以后, 由vn.py的策略管理器负责加载运行. 整个程序结构中, vn.py作为调用方, 用户代码作为被调用方, 结构图是这样的: .. raw:: html <svg xmlns=""http://www.w3.org/2000/svg"" xmlns:xlink=""http://www.w3.org/1999/xlink"" version=""1.1"" width=""689px"" viewBox=""-0.5 -0.5 689 208"" style=""max-width:100%;max-height:208px;""><defs/><g><rect x=""0"" y=""87"" width=""680"" height=""40"" rx=""6"" ry=""6"" fill=""#f8cecc"" stroke=""#b85450"" pointer-events=""none""/><g transform=""translate(297.5,100.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""84"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 86px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">Vnpy cta runner</div></div></foreignObject><text x=""42"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">Vnpy cta runner</text></switch></g><path d=""M 126 160.63 L 126 127"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 126 165.88 L 122.5 158.88 L 126 160.63 L 129.5 158.88 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(77.5,140.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""96"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">调用事件响应函数</div></div></foreignObject><text x=""48"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">调用事件响应函数</text></switch></g><rect x=""110"" y=""167"" width=""120"" height=""40"" fill=""#dae8fc"" stroke=""#6c8ebf"" pointer-events=""none""/><g transform=""translate(154.5,180.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""30"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 32px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">策略1</div></div></foreignObject><text x=""15"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">策略1</text></switch></g><path d=""M 334.47 83.84 L 200 7"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 339.03 86.45 L 331.22 86.01 L 334.47 83.84 L 334.69 79.93 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(227.5,40.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""84"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">接收行情和回单</div></div></foreignObject><text x=""42"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">接收行情和回单</text></switch></g><path d=""M 474.47 10.16 L 340 87"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 479.03 7.55 L 474.69 14.07 L 474.47 10.16 L 471.22 7.99 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(373.5,40.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""72"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">发送交易指令</div></div></foreignObject><text x=""36"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">发送交易指令</text></switch></g><path d=""M 222 136.37 L 222 167"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 222 131.12 L 225.5 138.12 L 222 136.37 L 218.5 138.12 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(185.5,142.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""72"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">调用下单函数</div></div></foreignObject><text x=""36"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">调用下单函数</text></switch></g><path d=""M 336 160.63 L 336 127"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 336 165.88 L 332.5 158.88 L 336 160.63 L 339.5 158.88 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(287.5,140.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""96"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">调用事件响应函数</div></div></foreignObject><text x=""48"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">调用事件响应函数</text></switch></g><rect x=""320"" y=""167"" width=""120"" height=""40"" fill=""#dae8fc"" stroke=""#6c8ebf"" pointer-events=""none""/><g transform=""translate(364.5,180.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""30"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 32px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">策略2</div></div></foreignObject><text x=""15"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">策略2</text></switch></g><path d=""M 432 136.37 L 432 167"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 432 131.12 L 435.5 138.12 L 432 136.37 L 428.5 138.12 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(395.5,142.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""72"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">调用下单函数</div></div></foreignObject><text x=""36"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">调用下单函数</text></switch></g><path d=""M 556 160.63 L 556 127"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 556 165.88 L 552.5 158.88 L 556 160.63 L 559.5 158.88 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(507.5,140.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""96"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">调用事件响应函数</div></div></foreignObject><text x=""48"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">调用事件响应函数</text></switch></g><rect x=""540"" y=""167"" width=""120"" height=""40"" fill=""#dae8fc"" stroke=""#6c8ebf"" pointer-events=""none""/><g transform=""translate(584.5,180.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""30"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 32px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">策略3</div></div></foreignObject><text x=""15"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">策略3</text></switch></g><path d=""M 652 136.37 L 652 167"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 652 131.12 L 655.5 138.12 L 652 136.37 L 648.5 138.12 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(615.5,142.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""72"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">调用下单函数</div></div></foreignObject><text x=""36"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">调用下单函数</text></switch></g></g></svg> 而在 TqSdk 中, 策略程序并没有一个统一的基类. TqSdk只是提供一些行情和交易函数, 用户可以任意组合它们来实现自己的策略程序, 还是以双均线策略为例:: ''' 双均线策略 ''' from tqsdk import TqApi, TqAuth, TqSim, TargetPosTask from tqsdk.tafunc import ma SHORT = 30 LONG = 60 SYMBOL = ""SHFE.bu1912"" api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) data_length = LONG + 2 klines = api.get_kline_serial(SYMBOL, duration_seconds=60, data_length=data_length) target_pos = TargetPosTask(api, SYMBOL) while True:  api.wait_update()  if api.is_changing(klines.iloc[-1], ""datetime""): # 产生新k线:重新计算SMA   short_avg = ma(klines.close, SHORT) # 短周期   long_avg = ma(klines.close, LONG) # 长周期   # 均线下穿，做空   if long_avg.iloc[-2] < short_avg.iloc[-2] and long_avg.iloc[-1] > short_avg.iloc[-1]:    target_pos.set_target_volume(-3)    print(""均线下穿，做空"")   # 均线上穿，做多   if short_avg.iloc[-2] < long_avg.iloc[-2] and short_avg.iloc[-1] > long_avg.iloc[-1]:    target_pos.set_target_volume(3)    print(""均线上穿，做多"")    以上代码文件单独运行, 即可执行一个双均线交易策略. 整个程序结构中, 用户代码作为调用方, TqSdk库代码作为被调用方, 每个策略是完全独立的. 结构是这样: .. raw:: html <svg xmlns=""http://www.w3.org/2000/svg"" xmlns:xlink=""http://www.w3.org/1999/xlink"" version=""1.1"" width=""576px"" viewBox=""-0.5 -0.5 576 209"" style=""max-width:100%;max-height:209px;""><defs/><g><rect x=""7"" y=""80"" width=""160"" height=""40"" rx=""6"" ry=""6"" fill=""#f8cecc"" stroke=""#b85450"" pointer-events=""none""/><g transform=""translate(69.5,93.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""34"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 36px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">TqSdk<br /></div></div></foreignObject><text x=""17"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">TqSdk&lt;br&gt;</text></switch></g><rect x=""7"" y=""0"" width=""160"" height=""40"" fill=""#dae8fc"" stroke=""#6c8ebf"" pointer-events=""none""/><g transform=""translate(71.5,13.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""30"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 32px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">策略1</div></div></foreignObject><text x=""15"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">策略1</text></switch></g><path d=""M 82.5 124.5 L 7 200"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 86.21 120.79 L 83.73 128.22 L 82.5 124.5 L 78.78 123.27 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(4.5,153.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""84"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">接收行情和回单</div></div></foreignObject><text x=""42"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">接收行情和回单</text></switch></g><path d=""M 162.5 195.5 L 87 120"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 166.21 199.21 L 158.78 196.73 L 162.5 195.5 L 163.73 191.78 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(90.5,153.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""72"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">发送交易指令</div></div></foreignObject><text x=""36"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">发送交易指令</text></switch></g><path d=""M 87 73.63 L 87 40"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 87 78.88 L 83.5 71.88 L 87 73.63 L 90.5 71.88 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(62.5,53.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""48"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">调用函数</div></div></foreignObject><text x=""24"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">调用函数</text></switch></g><rect x=""207"" y=""80"" width=""160"" height=""40"" rx=""6"" ry=""6"" fill=""#f8cecc"" stroke=""#b85450"" pointer-events=""none""/><g transform=""translate(269.5,93.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""34"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 36px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">TqSdk<br /></div></div></foreignObject><text x=""17"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">TqSdk&lt;br&gt;</text></switch></g><rect x=""207"" y=""0"" width=""160"" height=""40"" fill=""#dae8fc"" stroke=""#6c8ebf"" pointer-events=""none""/><g transform=""translate(271.5,13.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""30"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 32px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">策略2</div></div></foreignObject><text x=""15"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">策略2</text></switch></g><path d=""M 282.5 124.5 L 207 200"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 286.21 120.79 L 283.73 128.22 L 282.5 124.5 L 278.78 123.27 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(204.5,153.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""84"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">接收行情和回单</div></div></foreignObject><text x=""42"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">接收行情和回单</text></switch></g><path d=""M 362.5 195.5 L 287 120"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 366.21 199.21 L 358.78 196.73 L 362.5 195.5 L 363.73 191.78 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(290.5,153.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""72"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">发送交易指令</div></div></foreignObject><text x=""36"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">发送交易指令</text></switch></g><path d=""M 287 73.63 L 287 40"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 287 78.88 L 283.5 71.88 L 287 73.63 L 290.5 71.88 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(262.5,53.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""48"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">调用函数</div></div></foreignObject><text x=""24"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">调用函数</text></switch></g><rect x=""407"" y=""80"" width=""160"" height=""40"" rx=""6"" ry=""6"" fill=""#f8cecc"" stroke=""#b85450"" pointer-events=""none""/><g transform=""translate(469.5,93.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""34"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 36px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">TqSdk<br /></div></div></foreignObject><text x=""17"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">TqSdk&lt;br&gt;</text></switch></g><rect x=""407"" y=""0"" width=""160"" height=""40"" fill=""#dae8fc"" stroke=""#6c8ebf"" pointer-events=""none""/><g transform=""translate(471.5,13.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""30"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 32px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;"">策略3</div></div></foreignObject><text x=""15"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">策略3</text></switch></g><path d=""M 482.5 124.5 L 407 200"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 486.21 120.79 L 483.73 128.22 L 482.5 124.5 L 478.78 123.27 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(404.5,153.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""84"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">接收行情和回单</div></div></foreignObject><text x=""42"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">接收行情和回单</text></switch></g><path d=""M 562.5 195.5 L 487 120"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 566.21 199.21 L 558.78 196.73 L 562.5 195.5 L 563.73 191.78 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(490.5,153.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""72"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">发送交易指令</div></div></foreignObject><text x=""36"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">发送交易指令</text></switch></g><path d=""M 487 73.63 L 487 40"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 487 78.88 L 483.5 71.88 L 487 73.63 L 490.5 71.88 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(462.5,53.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""all"" width=""48"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">调用函数</div></div></foreignObject><text x=""24"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""11px"" font-family=""Helvetica"">调用函数</text></switch></g></g></svg> TqSdk将每个策略作为一个独立进程运行, 这样就可以: * 在运行多策略时可以充分利用多CPU的计算能力 * 每个策略都可以随时启动/停止/调试/修改代码, 而不影响其它策略程序的运行 * 可以方便的针对单个策略程序进行调试 在策略程序中, 用户代码可以随意调用 TqSdk 包中的任意函数, 这带来了更大的自由度, 比如: * 在一个策略程序中使用多个合约或周期的K线数据, 盘口数据和Tick数据. 对于某些类型的策略来说这是很方便的 * 对多个合约的交易指令进行精细管理 * 管理复杂的子任务 * 方便策略程序跟其它库或框架集成 以一个套利策略的代码为例:: ''' 价差回归 当近月-远月的价差大于200时做空近月，做多远月 当价差小于150时平仓 ''' api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) quote_near = api.get_quote(""SHFE.rb1910"") quote_deferred = api.get_quote(""SHFE.rb2001"") # 创建 rb1910 的目标持仓 task，该 task 负责调整 rb1910 的仓位到指定的目标仓位 target_pos_near = TargetPosTask(api, ""SHFE.rb1910"") # 创建 rb2001 的目标持仓 task，该 task 负责调整 rb2001 的仓位到指定的目标仓位 target_pos_deferred = TargetPosTask(api, ""SHFE.rb2001"") while True:  api.wait_update()  if api.is_changing(quote_near) or api.is_changing(quote_deferred):   spread = quote_near.last_price - quote_deferred.last_price   print(""当前价差:"", spread)   if spread > 250:    print(""目标持仓: 空近月，多远月"")    # 设置目标持仓为正数表示多头，负数表示空头，0表示空仓    target_pos_near.set_target_volume(-1)    target_pos_deferred.set_target_volume(1)   elif spread < 200:    print(""目标持仓: 空仓"")    target_pos_near.set_target_volume(0)    target_pos_deferred.set_target_volume(0)    在这个程序中, 我们同时跟踪两个合约的行情信息, 并为两个合约各创建一个调仓任务, 可以方便的实现套利策略 K线数据与指标计算 ------------------------------------------------- 使用vn.py时, K线是由vn.py接收实时行情, 并在用户电脑上生成K线, 存储于用户电脑上的数据库中. 而在TqSdk中, K线数据和其它行情数据一样是由行情网关生成并推送的. 这带来了一些差别: * 用户不再需要维护K线数据库. 用户电脑实时行情中断后, 也不再需要补历史数据 * 行情服务器生成K线时, 采用了按K线时间严格补全对齐的算法. 这与vn.py或其它软件有明显区别, 详见 https://www.shinnytech.com/blog/why-our-kline-different/ * 行情数据只在每次程序运行时通过网络获取, 不在用户硬盘保存. 如果策略研究工作需要大量静态历史数据, 我们推荐使用数据下载工具, 另行下载csv文件使用. TqSdk中的K线序列采用 pandas.DataFrame 格式. pandas 提供了 `非常丰富的数据处理函数 <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html>`_ , 使我们可以非常方便的进行数据处理, 例如:: ks = api.get_kline_serial(""SHFE.cu1901"", 60) print(ks.iloc[-1])   # <- 最后一根K线 print(ks.close)    # <- 收盘价序列 ks.high - ks.high.shift(1) # <- 每根K线最高价-前一根K线最高价, 形成一个新序列  TqSdk 也通过 :py:mod:`tqsdk.tafunc` 提供了一批行情分析中常用的计算函数, 例如::  from tqsdk import tafunc ks = api.get_kline_serial(""SHFE.cu1901"", 60) ms = tafunc.max(ks.open, ks.close)   # <- 取每根K线开盘价和收盘价的高者构建一个新序列 median3 = tafunc.median(ks.close, 100)  # <- 求最近100根K线收盘价的中间值 ss = tafunc.std(ks.close, 5)     # <- 每5根K线的收盘价标准差 数据接收和更新 ------------------------------------------------- vn.py按照事件回调模型设计, 使用 CtaTemplate 的 on_xxx 回调函数进行行情数据和回单处理:: class DoubleMaStrategy(CtaTemplate):  def on_tick(self, tick: TickData):  ...  def on_bar(self, bar: BarData):  ...  def on_order(self, order: OrderData):  pass  def on_trade(self, trade: TradeData):  self.put_event() TqSdk则不使用事件回调机制. :py:meth:`~tqsdk.TqApi.wait_update` 函数设计用来获取任意数据更新, 像这样:: api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) ks = api.get_kline_serial(""SHFE.cu1901"", 60)  while True:  api.wait_update()  # <- 这个 wait_update 将尝试更新所有数据. 如果没有任何新信息, 程序会阻塞在这一句. 一旦有任意数据被更新, 程序会继续往下执行  print(ks.close.iloc[-1])  # <- 最后一根K线的收盘价 一次 wait_update 可能更新多个实体, 在这种情况下, :py:meth:`~tqsdk.TqApi.is_changing` 被用来判断某个实体是否有变更:: api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) q = api.get_quote(""SHFE.cu1901"") ks = api.get_kline_serial(""SHFE.cu1901"", 60) x = api.insert_order(""SHFE.cu1901"", direction=""BUY"", offset=""OPEN"", volume=1, limit_price=50000)  while True:  api.wait_update()  # <- 这个 wait_update 将尝试更新所有数据. 如果没有任何新信息, 程序会阻塞在这一句. 一旦有任意数据被更新, 程序会继续往下执行  if api.is_changing(q): # <- 这个 is_changing 用来判定这次更新是否影响到了q  print(q)   if api.is_changing(x, ""status""): # <- 这个 is_changing 用来判定这次更新是否影响到了报单的status字段  print(x) TqSdk针对行情数据和交易信息都采用相同的 wait_update/is_changing 方案. 用户需要记住的要点包括: * get_quote, get_kline_serial, insert_order 等业务函数返回的是一个引用(refrence, not value), 它们的值总是在 wait_update 时更新. * 用户程序除执行自己业务逻辑外, 需要反复调用 wait_update. 在两次 wait_update 间, 所有数据都不更新 * 用 insert_order 函数下单, 报单指令实际是在 insert_order 后调用 wait_update 时发出的. * 用户程序中需要避免阻塞, 不要使用 sleep 暂停程序 关于 wait_update 机制的详细说明, 请见 :ref:`framework` 图形界面 ------------------------------------------------- TqSdk 提供 :ref:`web_gui` 来供有图形化需求的用户使用: * 策略运行时, 交易记录和持仓记录自动在行情图上标记, 可以快速定位跳转, 可以跨周期缩放定位 * 策略回测时, 提供回测报告/图上标记和对应的回测分析报告. * 策略运行和回测信息自动保存, 可事后随时查阅显示 TqSdk配合web_gui使用时, 还支持自定义绘制行情图表, 像这样:: api = TqApi(auth=TqAuth(""信易账户"",""账户密码""), web_gui=True) # 获取 cu1905 和 cu1906 的日线数据 klines = api.get_kline_serial(""SHFE.cu1905"", 86400) klines2 = api.get_kline_serial(""SHFE.cu1906"", 86400) # 算出 cu1906 - cu1905 的价差，并以折线型态显示在副图 klines[""dif""] = klines2[""close""] - klines[""close""] klines[""dif.board""] = ""DIF"" klines[""dif.color""] = 0xFF00FF00 klines[""dif.width""] = 3  回测 ------------------------------------------------- 使用TqSdk开发的策略可以回测: * 提供Tick及K线级别的回测. * TqSdk 允许在一个策略中使用任意多个数据序列. 回测框架将正确识别并处理这种情况. * 回测前不需要准备数据 关于策略回测的详细说明, 请见 :ref:`backtest` 其它区别 ------------------------------------------------- 此外, 还有一些差别值得注意 * TqSdk 要求 Python 3.6.4 以上版本, 不支持 Python 2.x * TqSdk 使用了Python3的async框架, 某些 IDE 不支持, 需要使用支持 async 的IDE, 例如 pycharm 要学习使用 TqSdk, 推荐从 :ref:`quickstart` 开始 "
15,n\doc\advanced\gui,"n\doc\advanced\gui. .. _gui: 与Gui库共同工作 ================================================= 某些情况下, 我们可能需要在一个 Python GUI 程序中使用TqSdk库. TqSdk 可以与Tkinter, PyQt, WxPython, PySimpleGui 等大多数常见 Python Gui 库配合工作. 下面以 PySimpleGui 为例, 介绍 Gui 库与 TqSdk 组合使用的方式. 先后使用GUI库和TqSdk ------------------------------------------------- 参见示例程序 param_input.py. 这个程序先使用 PySimpleGui 创建一个参数输入对话框, 用户输入参数后, 关闭对话框, 开始使用 TqSdk: .. literalinclude:: ../../tqsdk/demo/gui/param_input.py :language: python 在两个线程中分别运行Gui和TqSdk ------------------------------------------------- 参见示例程序 multi_thread.py. .. literalinclude:: ../../tqsdk/demo/gui/multi_thread.py :language: python 在TqSdk任务中驱动Gui消息循环 ------------------------------------------------- 参见示例程序 loop_integrate.py. .. literalinclude:: ../../tqsdk/demo/gui/loop_integrate.py :language: python "
16,n\doc\advanced\index,"n\doc\advanced\index. .. _advanced: 进阶主题 ======================================== 这一部分内容提供给有经验的 TqSdk 用户, 主要讲解将 TqSdk 用于实际工作时的一些重要问题的处理方案和最佳实践. .. toctree::  :maxdepth: 2  order.rst  backtest.rst  multi_strategy.rst  gui.rst  dingding.rst  for_vnpy_user.rst  for_ctp_user.rst  unanttended.rst  targetpostask2.rst  scheduler.rst  tqsdk2ctptest.rst "
17,n\doc\advanced\multi strategy,"n\doc\advanced\multi strategy. .. _multi_instance: 交易策略的多实例运行 ================================================= 我们可能会将一个策略应用于不同的目标品种, 不同品种使用的策略参数也不同. 以简单的双均线策略为例. 一个简单的双均线策略代码大致是这样::  SYMBOL = ""SHFE.bu1912"" # 合约代码  SHORT = 30 # 短周期  LONG = 60 # 长周期  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))  klines = api.get_kline_serial(SYMBOL, duration_seconds=60, data_length=LONG + 2)  target_pos = TargetPosTask(api, SYMBOL)  while True:   api.wait_update()   if api.is_changing(klines.iloc[-1], ""datetime""):    short_avg = ma(klines[""close""], SHORT)    long_avg = ma(klines[""close""], LONG)    if long_avg.iloc[-2] < short_avg.iloc[-2] and long_avg.iloc[-1] > short_avg.iloc[-1]:     target_pos.set_target_volume(-3)     print(""均线下穿，做空"")    if short_avg.iloc[-2] < long_avg.iloc[-2] and short_avg.iloc[-1] > long_avg.iloc[-1]:     target_pos.set_target_volume(3)     print(""均线上穿，做多"") 我们可能需要将这个策略运行多份, 每份的 SYMBOL, LONG, SHORT 都不同. TqSdk 为这类需求提供两种解决方案, 您可任意选择一种. 每个进程执行一个策略实例 ------------------------------------------------- 最简单的办法是直接将上面的程序复制为N个文件, 手工修改每个文件中的 SYMBOL, SHORT, LONG 的值, 再把N个程序分别启动运行即可达到目的. 如果觉得代码复制N份会导致修改不方便, 可以简单的剥离一个函数文件, 每个策略实例文件引用它::  在函数文件 mylib.py 中:  def ma(SYMBOL, SHORT, LONG):   api = TqApi(TqSim())   klines = api.get_kline_serial(SYMBOL, duration_seconds=60, data_length=LONG + 2)   target_pos = TargetPosTask(api, SYMBOL)   while True:    api.wait_update()    if api.is_changing(klines.iloc[-1], ""datetime""):     short_avg = ma(klines[""close""], SHORT)     long_avg = ma(klines[""close""], LONG)     if long_avg.iloc[-2] < short_avg.iloc[-2] and long_avg.iloc[-1] > short_avg.iloc[-1]:      target_pos.set_target_volume(-3)      print(""均线下穿，做空"")     if short_avg.iloc[-2] < long_avg.iloc[-2] and short_avg.iloc[-1] > long_avg.iloc[-1]:      target_pos.set_target_volume(3)      print(""均线上穿，做多"")  --------------------------------------------------  在策略文件 ma-股指.py 中:  from mylib import ma  ma(""CFFEX.IF1906"", 30, 60)  --------------------------------------------------  在策略文件 ma-玉米.py 中:  from mylib import ma  ma(""DCE.c1906"", 10, 20) 习惯使用命令行的同学也可以做命令行参数::  import argparse  parser = argparse.ArgumentParser()  parser.add_argument('--SYMBOL')  parser.add_argument('--SHORT')  parser.add_argument('--LONG')  args = parser.parse_args()  api = TqApi(TqSim())  klines = api.get_kline_serial(args.SYMBOL, duration_seconds=60, data_length=args.LONG + 2)  target_pos = TargetPosTask(api, args.SYMBOL)  while True:   api.wait_update()   if api.is_changing(klines.iloc[-1], ""datetime""):    short_avg = ma(klines[""close""], args.SHORT)    long_avg = ma(klines[""close""], args.LONG)    if long_avg.iloc[-2] < short_avg.iloc[-2] and long_avg.iloc[-1] > short_avg.iloc[-1]:     target_pos.set_target_volume(-3)     print(""均线下穿，做空"")    if short_avg.iloc[-2] < long_avg.iloc[-2] and short_avg.iloc[-1] > long_avg.iloc[-1]:     target_pos.set_target_volume(3)     print(""均线上穿，做多"") 使用时在命令行挂参数::  python ma.py --SYMBOL=SHFE.cu1901 --LONG=30 --SHORT=20  python ma.py --SYMBOL=SHFE.rb1901 --LONG=50 --SHORT=10 优点: * 思路简单, 好学好做, 不易出错 * 每个单独策略可以分别启动/停止 * 策略代码最简单, 调试方便 缺点: * 每个策略进程要建立一个单独的服务器连接, 数量过大时可能无法连接成功 .. _multi_async_task: 单线程创建多个异步任务 ------------------------------------------------- TqSdk 内核支持以异步方式实现多任务。 如果用户策略代码实现为一个异步任务, 即可在单线程内执行多个策略。 TqSdk（2.6.1 版本）对几个常用接口 :py:meth:`~tqsdk.TqApi.get_quote`, :py:meth:`~tqsdk.TqApi.get_quote_list`, :py:meth:`~tqsdk.TqApi.get_kline_serial`, :py:meth:`~tqsdk.TqApi.get_tick_serial` 支持协程中调用。 对于 :py:meth:`~tqsdk.TqApi.get_quote` 接口，在异步代码中可以写为 ``await api.get_quote('SHFE.cu2110')``，代码更加紧凑，可读性更好。 示例代码如下::  # 协程示例，为每个合约创建 task  from tqsdk import TqApi  async def demo(SYMBOL):   quote = await api.get_quote(SYMBOL) # 支持 await 异步，这里会订阅合约，等到收到合约行情才返回   print(f""quote: {SYMBOL}"", quote.datetime, quote.last_price) # 这一行就会打印出合约的最新行情   ##############################################################################   # 以上代码和下面的代码是等价的，强烈建议在异步中用上面的写法   # quote = api.get_quote(SYMBOL) # 这里还是同步写法，仅仅返回 quote 的引用，还没有订阅合约，会在下次调用 api.wait_update() 时才发出订阅合约请求   # print(f""quote: {SYMBOL}"", quote.datetime, quote.last_price) # 这一行不会打印出合约的信息   #   # async with api.register_update_notify() as update_chan:   # async for _ in update_chan:   #  if quote.datetime != """": # 当收到 datetime 字段时，可以判断收到了合约行情   #   print(SYMBOL, quote.datetime, quote.last_price) # 此时会打印出行情   #   break   ##############################################################################   async with api.register_update_notify() as update_chan:    async for _ in update_chan:     if api.is_changing(quote):      print(SYMBOL, quote.datetime, quote.last_price)     # ... 策略代码 ...  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))  # 为每个合约创建异步任务  api.create_task(demo(""SHFE.rb2107""))  api.create_task(demo(""DCE.m2109""))  while True:   api.wait_update() 下面是一个更完整的示例，用异步方式实现为每个合约创建双均线策略，示例代码如下::  # 协程示例，为每个合约创建 task  from tqsdk import TqApi  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 构造 api 实例  async def demo(SYMBOL, SHORT, LONG):   """"""   双均线策略 -- SYMBOL: 合约, SHORT: 短周期, LONG: 长周期   """"""   data_length = LONG + 2 # k线数据长度   # get_kline_serial 支持 await 异步写法，这里会订阅 K 线，等到收到 k 线数据才返回   klines = await api.get_kline_serial(SYMBOL, duration_seconds=60, data_length=data_length)   target_pos = TargetPosTask(api, SYMBOL)   async with api.register_update_notify() as update_chan:    async for _ in update_chan:     if api.is_changing(klines.iloc[-1], ""datetime""):      short_avg = ma(klines[""close""], SHORT) # 短周期      long_avg = ma(klines[""close""], LONG) # 长周期      if long_avg.iloc[-2] < short_avg.iloc[-2] and long_avg.iloc[-1] > short_avg.iloc[-1]:       target_pos.set_target_volume(-3)       print(""均线下穿，做空"")      if short_avg.iloc[-2] < long_avg.iloc[-2] and short_avg.iloc[-1] > long_avg.iloc[-1]:       target_pos.set_target_volume(3)       print(""均线上穿，做多"")  # 为每个合约创建异步任务  api.create_task(demo(""SHFE.rb2107"", 30, 60))  api.create_task(demo(""DCE.m2109"", 30, 60))  api.create_task(demo(""DCE.jd2109"", 30, 60))  while True:   api.wait_update() 优点: * 单线程内执行多个策略, 只消耗一份网络连接 * 没有线程或进程切换成本, 性能高, 延时低, 内存消耗小, 性能最优 缺点: * 用户需熟练掌握 asyncio 异步编程, 学习成本高 example 中的 `gridtrading_async.py <https://github.com/shinnytech/tqsdk-python/blob/master/tqsdk/demo/example/gridtrading_async.py>`_ 就是一个完全按异步框架实现的网格交易策略. 有意学习的同学可以与 gridtrading.py 对比一下 "
18,n\doc\advanced\order,"n\doc\advanced\order. .. _advanced_order: 高级委托指令 ================================================= 在实盘交易中, 除常见的限价委托指令外, tqsdk 提供了 FAK / FOK 两种高级市价指令。 insert_order 为用户提供了 limit_price，advanced 两个参数指定下单指令，两个参数支持的值的组合为： =========== ======== ==================================== limit_price advanced memo =========== ======== ==================================== 指定价格  None  限价指令，即时成交，当日有效 指定价格  FAK  限价指令，即时成交剩余撤销 指定价格  FOK  限价指令，即时全部成交或撤销 None  None  市价指令，即时成交剩余撤销 None  FAK  市价指令，即时成交剩余撤销 None  FOK  市价指令，即时全部成交或撤销 BEST  None  最优一档即时成交剩余撤销指令 BEST  FAK  最优一档即时成交剩余撤销指令 FIVELEVEL None  最优五档即时成交剩余撤销指令 FIVELEVEL FAK  最优五档即时成交剩余撤销指令 =========== ======== ==================================== * limit_price 默认值为 ``None`` * advance 默认值为 ``None`` * 对于市价单、BEST、FIVELEVEL，``advanced=""FAK""`` 与默认参数 ``None`` 的实际报单请求一样。 例如:: from tqsdk import TqApi, TqAuth api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 当日有效限价单 api.insert_order(""SHFE.cu2009"", ""BUY"", ""OPEN"", 3, limit_price=14200) # FAK 限价单 api.insert_order(""SHFE.cu2009"", ""BUY"", ""OPEN"", 3, limit_price=14200, advanced=""FAK"") # FOK 限价单 api.insert_order(""SHFE.cu2009"", ""BUY"", ""OPEN"", 3, limit_price=14200, advanced=""FOK"") # 市价单 api.insert_order(""DCE.m2009"", ""BUY"", ""OPEN"", 3) # FOK 市价单 api.insert_order(""DCE.m2009"", ""BUY"", ""OPEN"", 3, advanced=""FOK"") # BEST api.insert_order(""CFFEX.T2003"", ""BUY"", ""OPEN"", 3, limit_price=""BEST"") # FIVELEVEL api.insert_order(""CFFEX.T2003"", ""BUY"", ""OPEN"", 3, limit_price=""FIVELEVEL"") 不同交易所支持的高级指令参数组合： ======== ============== ==================== ==================== 交易所 品种   limit_price   advance ======== ============== ==================== ==================== 郑商所 期货   指定价格 / None  None / FAK 郑商所 期权   指定价格 / None  None / FAK / FOK 大商所 期货   指定价格 / None  None / FAK / FOK 大商所 期权   指定价格    None / FAK / FOK 上期所 期货/期权  指定价格    None / FAK / FOK 中金所 期货/期权  指定价格    None / FAK / FOK 中金所 期货/期权  BEST / FIVELEVEL  None / FAK 上交所 ETF期权   指定价格    None / FOK 深交所 ETF期权   指定价格    None / FOK ======== ============== ==================== ==================== "
19,n\doc\advanced\pandas,n\doc\advanced\pandas. 与 pandas 配合使用 ================================================= This part of the documentation covers the installation of Requests. The first step to using any software package is getting it properly installed. 
20,n\doc\advanced\processing,n\doc\advanced\processing. 业务数据处理 ================================================= This part of the documentation covers the installation of Requests. The first step to using any software package is getting it properly installed. 
21,n\doc\advanced\scheduler,"n\doc\advanced\scheduler. .. _target_pos_scheduler: 基于时间维度目标持仓策略 ================================================= 本篇文档假设您已经了解 :py:class:`~tqsdk.TargetPosTask` 的用法，文档参考 :ref:`targetpostask`。 简单来说，:py:class:`~tqsdk.TargetPosTask` 会创建 task，负责将指定合约调整到目标头寸（默认为账户的该合约净持仓）。 对于简单的大单拆分功能，可以在 :py:class:`~tqsdk.TargetPosTask` 类中设置拆分手数的上下限，:py:class:`~tqsdk.TargetPosTask` 实例在下单过程中就会将下单手数随机的拆分，以减少对市场冲击。 但是，对于比较复杂的下单策略，例如 twap（基于时间拆分手数），vwap（基于成交量拆分手数）等，使用 :py:class:`~tqsdk.TargetPosTask` 来构造策略不是很方便。 我们提供 :py:class:`~tqsdk.TargetPosScheduler` 类帮助用户完成复杂的下单策略，同时提供给用户极大的调整空间。 time_table 目标持仓任务列表 ------------------------------------------------------------------ :py:class:`~tqsdk.TargetPosScheduler` 使用 ``time_table`` 参数来描述具体的下单策略。 ``time_table`` 为 ``pandas.DataFrame`` 类型。每一行表示一项目标持仓任务，每项任务按照顺序一个个执行。其应该包含以下几列： + interval: 当前这项任务的持续时间长度，单位为秒，经过这么多秒之后，此项任务应该退出，剩余未调整到的目标持仓，会留到下一项任务中  * 注意1：对于最后一项任务，会按照当前项参数，调整到目标持仓后立即退出（时间参数不对最后一项任务起作用）  * 注意2：时间长度可以跨非交易时间段（可以跨小节等待），但是不可以跨交易日 + target_pos: 当前这项任务的目标净持仓手数 + price: 当前这项任务的下单价格模式，此列中非 None 的项，会作为创建 TargetPosTask 实例的 price 参数，支持以下几种参数：  * None: 不下单，表示暂停一段时间  * ""PASSIVE"" : 排队价下单  * ""ACTIVE"": 对价下单  * Callable (direction: str) -> Union[float, int]: 传入函数作为价格参数，函数参数为下单方向，函数返回值是下单价格。如果返回 nan，程序会抛错。 TargetPosScheduler 执行目标持仓任务列表 ------------------------------------------------------------------ :py:class:`~tqsdk.TargetPosScheduler` 类创建 target_pos_scheduler 实例，首先会将 ``time_table`` 中 ``interval`` 间隔时间列转为 ``deadline``，即这项任务结束时间的纳秒数。 然后，依次为 ``time_table`` 中的每一项任务创建 :py:class:`~tqsdk.TargetPosTask` 实例，调整目标持仓，并在到达 ``deadline`` 时退出。每一项未完成的目标持仓都会留都下一项任务中。 需要注意的是，最后一项任务，是以手数达到目标的，会按照当前项参数，调整到目标持仓再退出。如果最后一项 ``price`` 参数为 ``None`` （表示不下单），由于无法调整持仓，那么会立即退出。 简单示例 ------------------------------------------------------------------ 简单示例及说明如下::  time_table = DataFrame([   [25, 10, ""PASSIVE""]   [5, 10, ""ACTIVE""]   [30, 18, ""PASSIVE""]   [5, 18, ""ACTIVE""]  ], columns=['interval', 'target_pos', 'price'])  target_pos_scheduler = TargetPosScheduler(api, ""SHFE.cu2112"", time_table)  # 这个 time_table 表示的下单策略依次是：  # 1. 使用排队价下单，调整 ""SHFE.cu2112"" 到 10 手，到达 25s 时退出（无论目标手数是否达到，都不会继续下单）  # 2. 使用对价下单，调整 ""SHFE.cu2112"" 到 10 手，到达 5s 时退出  # 如果上一步结束时目标持仓已经达到 10 手，这一步什么都不会做，等待 5s 到下一步；  # 如果上一步结束时目标持仓没有达到 10 手，这一步会继续调整目标持仓到 10 手  # 3. 使用排队价下单，调整 ""SHFE.cu2112"" 到 18 手，到达 30s 时退出（无论目标手数是否达到，都不会继续下单）  # 4. 使用对价下单，调整 ""SHFE.cu2112"" 到 18 手  # 如果上一步结束时目标持仓已经达到 18 手，这一步什么都不会做，立即退出；  # 如果上一步结束时目标持仓没有达到 18 手，这一步会继续调整目标持仓到 18 手后退出 到此为止，您可以根据您的具体策略构造出任意的 ``time_table`` 对象，然后调用 :py:class:`~tqsdk.TargetPosScheduler` 来执行。 为了方便用户使用，我们提供了 :py:meth:`~tqsdk.algorithm.time_table_generater.twap_table` 来生成一个默认的符合 twap 策略的 ``time_table`` 实例。 基于 TargetPosScheduler 的 twap 策略示例 ------------------------------------------------------------------ 我们在 :ref:`tqsdk.algorithm` 模块中提供了 :py:meth:`~tqsdk.algorithm.time_table_generater.twap_table`，可方便的生成一个基于 twap 策略的 ``time_table`` 实例。 在执行算法之前，您还可以定制化的调整 ``time_table`` 中的具体任务项。 一个完整的 twap 策略示例::  from tqsdk import TqApi, TargetPosScheduler  from tqsdk.algorithm import twap_table  api = TqApi(auth=""信易账户,用户密码"")  quote = api.get_quote(""CZCE.MA109"")  # 设置 twap 任务参数，  time_table = twap_table(api, ""CZCE.MA105"", -100, 600, 1, 5) # 目标持仓 -100 手，600s 内完成  # 定制化调整 time_table，例如希望第一项任务延迟 10s 再开始下单  # 可以在 time_table 的头部加一行  time_table = pandas.concat([   DataFrame([[10, 10, None]], columns=['interval', 'target_pos', 'price']),   time_table  ], ignore_index=True)  target_pos_sch = TargetPosScheduler(api, ""CZCE.MA105"", time_table)  while not target_pos_sch.is_finished():   api.wait_update()  # 获取 target_pos_sch 实例所有的成交列表  print(target_pos_sch.trades_df)  # 利用成交列表，您可以计算出策略的各种表现指标，例如：  average_trade_price = sum(scheduler.trades_df['price'] * scheduler.trades_df['volume']) / sum(scheduler.trades_df['volume'])  print(""成交均价:"", average_trade_price)  api.close() "
22,n\doc\advanced\targetpostask2,"n\doc\advanced\targetpostask2. .. _targetpostask2: TargetPosTask 高级功能 ==================================================== 本篇文档假设您已经了解 :py:class:`~tqsdk.TargetPosTask` 的用法，文档参考 :ref:`targetpostask`。 本篇文档主要介绍 :py:class:`~tqsdk.TargetPosTask` 的高级用法。如何使用\ :py:meth:`~tqsdk.TargetPosTask.cancel` 和 :py:meth:`~tqsdk.TargetPosTask.is_finished` 方法。 应用情景说明 ---------------------------------------------------- 任何时刻，每个账户下一个合约只能有一个 :py:class:`~tqsdk.TargetPosTask` 实例，并且其构造参数不能修改。 但是在某些情况下，用户会希望可以管理 :py:class:`~tqsdk.TargetPosTask` 实例。 比如说，用户使用 :py:class:`~tqsdk.TargetPosTask` 的 **PASSIVE** 模式进行下单，希望在收盘前取消所有挂单（包含 :py:class:`~tqsdk.TargetPosTask` 实例的未成委托单），并平仓。 如何实现这样的功能 ---------------------------------------------------- :py:class:`~tqsdk.TargetPosTask` 类提供了 :py:meth:`~tqsdk.TargetPosTask.cancel` 和 :py:meth:`~tqsdk.TargetPosTask.is_finished` 方法。 + :py:meth:`~tqsdk.TargetPosTask.cancel` 方法会取消当前 :py:class:`~tqsdk.TargetPosTask` 实例，会将该实例已经发出但还未成交的委托单撤单此实例的 set_target_volume 函数不会再生效，并且此实例的 set_target_volume 函数不会再生效。 + :py:meth:`~tqsdk.TargetPosTask.is_finished` 方法可以获取当前 :py:class:`~tqsdk.TargetPosTask` 实例是否已经结束。已经结束实例的 set_target_volume 函数不会再接受参数，此实例不会再下单或者撤单。 下面是一个例子::  from datetime import datetime, time  from tqsdk import TqApi, TargetPosTask  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))  quote = api.get_quote(""SHFE.rb2110"")  target_pos_passive = TargetPosTask(api, ""SHFE.rb2110"", price=""PASSIVE"")  while datetime.strptime(quote.datetime, ""%Y-%m-%d %H:%M:%S.%f"").time() < time(14, 50):   api.wait_update()   # ... 策略代码 ...  # 取消 TargetPosTask 实例  target_pos_passive.cancel()  while not target_pos_passive.is_finished(): # 此循环等待 target_pos_passive 处理 cancel 结束   api.wait_update() # 调用wait_update()，会对已经发出但还是未成交的委托单撤单  # 创建新的 TargetPosTask 实例  target_pos_active = TargetPosTask(api, ""SHFE.rb2110"", price=""ACTIVE"")  target_pos_active.set_target_volume(0) # 平所有仓位  while True:   api.wait_update()   # ... 策略代码 ...  api.close() "
23,n\doc\advanced\timer,n\doc\advanced\timer. 定时器 ================================================= This part of the documentation covers the installation of Requests. The first step to using any software package is getting it properly installed. 
24,n\doc\advanced\tqsdk2ctptest,"n\doc\advanced\tqsdk2ctptest. .. _tqsdk2ctptest: 在 TqSdk 中调用 TqSdk2 查询保证金 ================================================= TqSdk 没有直接提供查询保证金的接口，但是你可以通过使用 TqSdk2 的直连功能来做到这个效果。tqsdk和tqsdk2可以在一个py文件中同时运行。 该方法仅支持 TqSdk2 中直连CTP 柜台时使用。受限制于 CTP 柜台的流控机制(每秒 1 笔), 短时间发送大量查询指令后, 后续查询指令将会排队等待。 为了避免盘中的查询等待时间, 建议盘前启动程序, 对标的合约提前进行查询::  from tqsdk import TqApi, TqAuth, TqAccount  import tqsdk2  account = tqsdk2.TqCtp(front_url, front_broker, app_id, auth_code, account_id, password)  api_margin = tqsdk2.TqApi(account = account, auth=tqsdk2.TqAuth(""信易账户"", ""账户密码""))  rate = api_margin.get_margin_rates(""SHFE.cu2201"")  print(rate)  api = TqApi(TqAccount(""期货公司"",""账号"",""密码""),auth=TqAuth(""信易账户"", ""账户密码""))  quote = api.get_quote(""SHFE.cu2201"")  while True:   api.wait_update()   print(quote.datetime)   # 正常和tqsdk一样执行策略 TqSdk2 的直连功能需要企业版权限，有关企业版的具体费用和功能，请参考 `天勤官方网站 <https://www.shinnytech.com/tqsdk_professional/>`_ 如果想了解更多关于 TqSdk2 的直连功能TqCtp，请参考 `tqsdk2官方文档 <https://doc.shinnytech.com/tqsdk2/latest/reference/tqsdk2.ctp.html?highlight=tqctp#tqsdk2.TqCtp/>`_ "
25,n\doc\advanced\unanttended,"n\doc\advanced\unanttended. .. _unanttended: 在无人监控环境下执行策略 ================================================= 对于已经过充分测试, 十分成熟的策略程序, 也可以选择以无人值守方式运行. 准备环境 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ TqSdk可以在windows/linux或macosx环境下运行. 无论您选择使用windows或linux系统, 请确保 * 已经装有 Python 3.6+ * 安装 :ref:`TqSdk <tqsdk_install>` 创建一个目录, 放置你所有的策略文件. 在每个策略程序中设置实盘账号 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 将每个策略程序配置为独立直连实盘账号. 在创建 TqApi 时, 传入TqAccount实例. 注意期货公司名称需要与天勤中的名称一致:: api = TqApi(TqAccount(""H海通期货"", ""022631"", ""123456""), auth=TqAuth(""信易账户"", ""账户密码"")) 检查策略程序 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 将策略代码投入无人监控运行前, 除对策略代码进行全面测试外, 还应注意以下事项: * 使用 python 的 logging 模块输出日志信息到文件, 不要使用 print 打印日志信息 * 策略代码退出时记得调用 api.close() 函数, 或者用 with closing(api) 的格式确保退出时自动关闭 * 目前api在运行过程中抛出的异常, 默认处理都是整个策略进程直接退出. 如无特殊需求, 不要使用 expect: 的方式捕获异常并阻止程序退出, 这种情况如果没有正确处理, 可能产生难以预测的后果. 在 windows 环境下配置策略的定时启动/停止 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 在 windows 下, 通常使用计划任务来管理策略的定时启动/停止, 下面的说明以 Windows 10 为例, 其它 windows 版本操作可能有少许差异. 打开 windows 任务计划管理器 .. image:: ../images/win10_start_scheduled_task.png 点击 创建基本任务 .. image:: ../images/win10_start_scheduled_task_create.png 为每个策略添加一个策略启动任务, [程序或脚本]处填 python.exe, [添加参数]处填策略代码py文件名和参数, [起始于]处填策略代码目录 .. image:: ../images/win10_start_scheduled_task_python.png 最后添加一个任务, 用来停止所有策略进程. [程序或脚本]处填 taskkill, [添加参数]处填 /IM python.exe .. image:: ../images/win10_start_scheduled_task_taskkill.png 在 linux 环境下配置策略的定时启动/停止 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 在 linux 下, 通常使用 cron 服务来处理策略的定时启动/停止. 具体配置请参考您所使用linux发行版的相应文档. 将一个策略应用于多个合约或多个账户 ------------------------------------------------- 将一个策略应用于多个合约或多个账户是一个常见需求. 我们推荐使用 命令行参数 来传递合约或账户信息. 请看下面例子:: # -*- coding: utf-8 -*- from tqsdk import TqApi, TqAccount api = TqApi(TqAccount(""H海通期货"", ""0330203"", ""123456""), auth=TqAuth(""信易账户"", ""账户密码"")) # 开仓两手并等待完成 order = api.insert_order(symbol=""SHFE.rb1901"", direction=""BUY"", offset=""OPEN"", limit_price=4310,volume=2) while order.status != ""FINISHED"":  api.wait_update() print(""已开仓"")  上面的代码中固定了账户及合约代码 SHFE.rb1901. 我们可以利用 python 的 argparse 模块为这个程序添加一些参数:: # -*- coding: utf-8 -*- import argparse from tqsdk import TqApi, TqSim, TqAccount #解析命令行参数 parser = argparse.ArgumentParser() parser.add_argument('--broker') parser.add_argument('--user_name') parser.add_argument('--password') parser.add_argument('--symbol') args = parser.parse_args() print(""策略参数为: "", args.user_name, args.symbol) api = TqApi(TqAccount(args.broker, args.user_name, args.password), auth=TqAuth(""信易账户"", ""账户密码"")) # 开仓两手并等待完成 order = api.insert_order(symbol=args.symbol, direction=""BUY"", offset=""OPEN"", limit_price=4310,volume=2) while order.status != ""FINISHED"":  api.wait_update() print(""已开仓"") 要通过命令行运行此策略, 可以输入:: python args.py --broker=H海通期货 --user_name=0330203 --password=123456 --symbol=SHFE.cu1901 要在 PyCharm 中同时执行此程序的多种参数版本, 可以通过 PyCharm 的 Run Configuration 实现. 先在 Edit Configuration 中, 为每组参数创建一个运行项 .. image:: ../images/pycharm_edit_configuration_entry.png .. image:: ../images/pycharm_edit_configuration.png 在 Edit Configuration 中配置好以后, 通过 Run... 菜单选择保存好的运行项, 即可实现带参数运行 .. image:: ../images/pycharm_run_configuration.png "
26,n\doc\demo\algorithm,n\doc\demo\algorithm. .. _demo_algorithm: 算法模块示例 ==================================================== .. contents:: 目录 .. _demo-algorithm-twap: twap_table - 时间平均加权算法 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/algorithm/twap.py :language: python .. _demo-algorithm-vwap: vwap_table - 交易量平均加权算法 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/algorithm/vwap.py :language: python
27,n\doc\demo\base,n\doc\demo\base. .. _demo_base: 基本使用 ==================================================== .. contents:: 目录 .. _tutorial-t10: t10 - 获取实时行情 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t10.py :language: python .. _tutorial-t20: t20 - 识别行情更新 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t20.py :language: python .. _tutorial-t30: t30 - 使用K线/Tick数据 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t30.py :language: python .. _tutorial-t40: t40 - 下单/撤单 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t40.py :language: python .. _tutorial-t41: t41 - 开仓/平仓 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t41.py :language: python .. _tutorial-t60: t60 - 单均线策略 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t60.py :language: python .. _tutorial-t70: t70 - 简单均线策略(目标持仓模型) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t70.py :language: python .. _tutorial-t71: t71 - 简单趋势策略 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t71.py :language: python .. _tutorial-t72: t72 - 隔夜开盘抢单 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t72.py :language: python .. _tutorial-t80: t80 - 价差回归策略 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t80.py :language: python .. _tutorial-t90: t90 - 在主图中画指标线 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t90.py :language: python .. _tutorial-t91: t91 - 在附图中画指标线 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t91.py :language: python .. _tutorial-t92: t92 - 主图中画信号线及文字标注 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t92.py :language: python .. _tutorial-t93: t93 - 在主图中画线和方框 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t93.py :language: python .. _tutorial-t94: t94 - 在附图中画K线 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t94.py :language: python .. _tutorial-t95: t95 - 附图中画K线、线段和方框 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t95.py :language: python .. _tutorial-t96: t96 - 附图中画MACD ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/t96.py :language: python .. _underlying_symbol: underlying_symbol - 获取主连映射主力合约 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/underlying_symbol.py :language: python .. _tutorial-backtest: backtest - 回测 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/backtest.py :language: python .. _tutorial-downloader: downloader - 下载数据 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/tutorial/downloader.py :language: python .. _tutorial-downloader-orders: downloader_orders - 下载委托单和成交记录 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/download_orders.py :language: python .. _tutorial-ta: ta - 指标计算 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/ta.py :language: python .. _tutorial-ta-option: ta_option - 期权指标计算 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/ta_option.py :language: python .. _tutorial-multiaccount: multiaccount - 多账户 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/multiaccount.py :language: python 
28,n\doc\demo\index,n\doc\demo\index. .. _demo: 示例程序 ==================================================== .. toctree::  :maxdepth: 2  base.rst  option_base.rst  algorithm.rst  strategy.rst 
29,n\doc\demo\option base,n\doc\demo\option base. .. _demo_options: 期权基本使用 ==================================================== .. contents:: 目录 .. _option_tutorial-t10: o10 - 获取期权实时行情 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/option_tutorial/o10.py :language: python .. _option_tutorial-t20: o20 - 查询符合要求的期权 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/option_tutorial/o20.py :language: python .. _option_tutorial-t30: o30 - 查询平值/虚值/实值期权 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/option_tutorial/o30.py :language: python .. _option_tutorial-t40: o40 - 计算期权的希腊字母 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/option_tutorial/o40.py :language: python .. _option_tutorial-t41: o41 - 计算期权隐含波动率和历史波动率 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/option_tutorial/o41.py :language: python .. _option_tutorial-t60: o60 - 获取期权波动率曲面 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/option_tutorial/o60.py :language: python .. _option_tutorial-t70: o70 - 期权套利策略 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/option_tutorial/o70.py :language: python o71 - 获取一组期权和其对应行权价 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/option_tutorial/o71.py :language: python o72 - 查询标的对应期权按虚值平值实值分类方法一 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/option_tutorial/o72.py :language: python o73 - 查询标的对应期权按虚值平值实值分类方法二 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/option_tutorial/o73.py :language: python o74 - 本地计算ETF期权卖方开仓保证金 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/option_tutorial/o74.py :language: python
30,n\doc\demo\strategy,n\doc\demo\strategy. .. _demo_strategy: 交易策略示例 ==================================================== .. contents:: 目录 Aberration 策略 (难度：初级) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 策略说明 https://www.shinnytech.com/blog/aberration/ .. literalinclude:: ../../tqsdk/demo/example/aberration.py :language: python Doublema 双均线策略 (难度：初级) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/example/doublema.py :language: python 价格动量策略 (难度：初级) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 策略说明 https://www.shinnytech.com/blog/momentum-strategy/ .. literalinclude:: ../../tqsdk/demo/example/momentum.py :language: python 自动扶梯策略 (难度：初级) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 策略说明 https://www.shinnytech.com/blog/escalator/ .. literalinclude:: ../../tqsdk/demo/example/escalator.py :language: python 菲阿里四价 策略 (难度：初级) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 策略说明 https://www.shinnytech.com/blog/fairy-four-price/ .. literalinclude:: ../../tqsdk/demo/example/fairy_four_price.py :language: python R-Breaker 交易策略 - 隔夜留仓 (难度：初级) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 策略说明 https://www.shinnytech.com/blog/r-breaker/ .. literalinclude:: ../../tqsdk/demo/example/rbreaker.py :language: python R-Breaker 交易策略 - 非隔夜留仓 (难度：初级) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 策略说明 https://www.shinnytech.com/blog/r-breaker/ .. literalinclude:: ../../tqsdk/demo/example/rbreaker2.py :language: python Dual Thrust 策略 (难度：中级) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 策略说明 https://www.shinnytech.com/blog/dual-thrust/ .. literalinclude:: ../../tqsdk/demo/example/dualthrust.py :language: python 网格交易策略 (难度：中级) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 策略说明 https://www.shinnytech.com/blog/grid-trading/ .. literalinclude:: ../../tqsdk/demo/example/gridtrading.py :language: python 网格交易策略 - 异步代码 (难度：中级) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 策略说明 https://www.shinnytech.com/blog/grid-trading/ .. literalinclude:: ../../tqsdk/demo/example/gridtrading_async.py :language: python 随机森林 (难度：中级) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. literalinclude:: ../../tqsdk/demo/example/random_forest.py :language: python 海龟交易策略 (难度：中级) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 策略说明 https://www.shinnytech.com/blog/turtle/ .. literalinclude:: ../../tqsdk/demo/example/turtle.py :language: python Volume Weighted Average Price 策略 (难度：高级) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 策略说明 https://www.shinnytech.com/blog/vwap/ .. literalinclude:: ../../tqsdk/demo/example/vwap.py :language: python 
31,n\doc\dev\async tool,n\doc\dev\async tool. .. _dev_async_tool: 异步工具 ==================================================== @todo: 待写 
32,n\doc\dev\backtest,n\doc\dev\backtest. .. _dev_backtest: 策略回测框架 ================================================= @todo: 待写 
33,n\doc\dev\framework,"n\doc\dev\framework. .. _dev_framework: TqSdk整体结构 ==================================================== 文件结构 ---------------------------------------------------- ========================== ========================================= File      Description ========================== ========================================= api.py      TqApi 接口主文件 tqhelper.py    TqApi 辅助代码 exception.py    异常类型定义 objs.py     主要业务数据结构定义 sim.py      本地模拟交易 backtest.py    回测支持 lib.py      交易辅助工具 ta.py      技术指标 tafunc.py     技术分析函数 ctpse/*     穿透式监管信息采集模块 test/*      单元测试用例 demo/*      示例程序 ========================== ========================================= 数据流 ---------------------------------------------------- TqSdk中以数据流的方式连接各组件。TqChan(本质是一个asyncio.Queue)被用作两个组件间的单向数据流管道，一个组件向 TqChan 中放入数据包，另一个组件从 TqChan 中依次取出数据包。 实盘运行时，整个数据流结构如下图: .. raw:: html <svg xmlns=""http://www.w3.org/2000/svg"" xmlns:xlink=""http://www.w3.org/1999/xlink"" version=""1.1"" width=""484px"" viewBox=""-0.5 -0.5 484 281"" style=""max-width:100%;max-height:281px;""><defs/><g><rect x=""0"" y=""0"" width=""200"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(37.5,6.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""124"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 124px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">Websocket Client<br />To OpenTradeGateway</div></div></foreignObject><text x=""62"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">Websocket Client&lt;br&gt;To OpenTradeGateway</text></switch></g><rect x=""280"" y=""0"" width=""200"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(324.5,6.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""110"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 110px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">Websocket Client<br />To OpenMdGateway</div></div></foreignObject><text x=""55"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">Websocket Client&lt;br&gt;To OpenMdGateway</text></switch></g><rect x=""0"" y=""120"" width=""480"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(210.5,133.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""58"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 58px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">TqAccount</div></div></foreignObject><text x=""29"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">TqAccount</text></switch></g><path d=""M 115 160.5 L 125 160.5 L 125 220.5 L 135.5 220.5 L 120 239.5 L 104.5 220.5 L 115 220.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(79.5,183.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""78"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">api_recv_chan</div></div></foreignObject><text x=""39"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">api_recv_chan</text></switch></g><path d=""M 365 239.5 L 355 239.5 L 355 179.5 L 344.5 179.5 L 360 160.5 L 375.5 179.5 L 365 179.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(321.5,205.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""81"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">api_send_chan</div></div></foreignObject><text x=""41"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">api_send_chan</text></switch></g><rect x=""0"" y=""240"" width=""480"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(223.5,253.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""32"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 32px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">TqApi</div></div></foreignObject><text x=""16"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">TqApi</text></switch></g><path d=""M 35 40.5 L 45 40.5 L 45 100.5 L 55.5 100.5 L 40 119.5 L 24.5 100.5 L 35 100.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(2.5,63.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""72"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">td_recv_chan</div></div></foreignObject><text x=""36"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">td_recv_chan</text></switch></g><path d=""M 165 119.5 L 155 119.5 L 155 59.5 L 144.5 59.5 L 160 40.5 L 175.5 59.5 L 165 59.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(124.5,85.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""75"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">td_send_chan</div></div></foreignObject><text x=""38"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">td_send_chan</text></switch></g><path d=""M 314.5 40.5 L 324.5 40.5 L 324.5 100.5 L 335 100.5 L 319.5 119.5 L 304 100.5 L 314.5 100.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(278.5,63.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""79"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">md_recv_chan</div></div></foreignObject><text x=""40"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">md_recv_chan</text></switch></g><path d=""M 444.5 119.5 L 434.5 119.5 L 434.5 59.5 L 424 59.5 L 439.5 40.5 L 455 59.5 L 444.5 59.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(400.5,85.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""82"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">md_send_chan</div></div></foreignObject><text x=""41"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">md_send_chan</text></switch></g></g></svg> 数据包上行流程(以报单为例): #. 用户程序调用 TqApi 中的某些需要发出数据包的功能函数, 以 TqApi.insert_order 为例 #. TqApi.insert_order 函数生成一个需要发出的数据包, 将此数据包放入 api_send_chan #. TqAccount 从 api_send_chan 中取出此数据包，根据 aid 字段，决定将此数据包放入 td_send_chan #. 连接到交易网关的 websocket client 从 td_send_chan 中取出此数据包，通过网络发出 数据包下行流程(以接收行情为例): #. 连接到行情网关的 websocket client 从网络收到一个数据包，将其放入 md_recv_chan #. TqAccount 从md_recv_chan中取出此数据包，将它放入 api_recv_chan #. TqApi 从api_recv_chan中取出此数据包，将数据包中携带的行情数据合并到内存存储区中 基于这样的数据流结构，可以通过简单更换部分组件的方式实现不同工作模式。例如模拟交易时，我们用 TqSim 替换 TqAccount: .. raw:: html <svg xmlns=""http://www.w3.org/2000/svg"" xmlns:xlink=""http://www.w3.org/1999/xlink"" version=""1.1"" width=""484px"" viewBox=""-0.5 -0.5 484 281"" style=""max-width:100%;max-height:281px;""><defs/><g><rect x=""280"" y=""0"" width=""200"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(324.5,6.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""110"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 110px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">Websocket Client<br />To OpenMdGateway</div></div></foreignObject><text x=""55"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">Websocket Client&lt;br&gt;To OpenMdGateway</text></switch></g><rect x=""0"" y=""120"" width=""480"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(222.5,133.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""34"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 36px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">TqSim</div></div></foreignObject><text x=""17"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">TqSim</text></switch></g><path d=""M 115 160.5 L 125 160.5 L 125 220.5 L 135.5 220.5 L 120 239.5 L 104.5 220.5 L 115 220.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(79.5,183.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""78"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">api_recv_chan</div></div></foreignObject><text x=""39"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">api_recv_chan</text></switch></g><path d=""M 365 239.5 L 355 239.5 L 355 179.5 L 344.5 179.5 L 360 160.5 L 375.5 179.5 L 365 179.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(321.5,205.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""81"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">api_send_chan</div></div></foreignObject><text x=""41"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">api_send_chan</text></switch></g><rect x=""0"" y=""240"" width=""480"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(223.5,253.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""32"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 32px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">TqApi</div></div></foreignObject><text x=""16"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">TqApi</text></switch></g><path d=""M 314.5 40.5 L 324.5 40.5 L 324.5 100.5 L 335 100.5 L 319.5 119.5 L 304 100.5 L 314.5 100.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(278.5,63.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""79"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">md_recv_chan</div></div></foreignObject><text x=""40"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">md_recv_chan</text></switch></g><path d=""M 444.5 119.5 L 434.5 119.5 L 434.5 59.5 L 424 59.5 L 439.5 40.5 L 455 59.5 L 444.5 59.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(400.5,85.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""82"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">md_send_chan</div></div></foreignObject><text x=""41"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">md_send_chan</text></switch></g></g></svg> 策略回测则是这样: .. raw:: html <svg xmlns=""http://www.w3.org/2000/svg"" xmlns:xlink=""http://www.w3.org/1999/xlink"" version=""1.1"" width=""484px"" viewBox=""-0.5 -0.5 484 401"" style=""max-width:100%;max-height:401px;""><defs/><g><rect x=""280"" y=""0"" width=""200"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(324.5,6.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""110"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 110px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">Websocket Client<br />To OpenMdGateway</div></div></foreignObject><text x=""55"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">Websocket Client&lt;br&gt;To OpenMdGateway</text></switch></g><rect x=""0"" y=""240"" width=""480"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(222.5,253.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""34"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 36px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">TqSim</div></div></foreignObject><text x=""17"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">TqSim</text></switch></g><path d=""M 115 280.5 L 125 280.5 L 125 340.5 L 135.5 340.5 L 120 359.5 L 104.5 340.5 L 115 340.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(79.5,303.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""78"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">api_recv_chan</div></div></foreignObject><text x=""39"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">api_recv_chan</text></switch></g><path d=""M 365 359.5 L 355 359.5 L 355 299.5 L 344.5 299.5 L 360 280.5 L 375.5 299.5 L 365 299.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(321.5,325.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""81"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">api_send_chan</div></div></foreignObject><text x=""41"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">api_send_chan</text></switch></g><rect x=""0"" y=""360"" width=""480"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(223.5,373.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""32"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 32px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">TqApi</div></div></foreignObject><text x=""16"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">TqApi</text></switch></g><path d=""M 314.5 40.5 L 324.5 40.5 L 324.5 100.5 L 335 100.5 L 319.5 119.5 L 304 100.5 L 314.5 100.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(278.5,63.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""79"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">md_recv_chan</div></div></foreignObject><text x=""40"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">md_recv_chan</text></switch></g><path d=""M 444.5 119.5 L 434.5 119.5 L 434.5 59.5 L 424 59.5 L 439.5 40.5 L 455 59.5 L 444.5 59.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(400.5,85.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""82"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">md_send_chan</div></div></foreignObject><text x=""41"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">md_send_chan</text></switch></g><rect x=""0"" y=""120"" width=""480"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(209.5,133.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""60"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 62px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">TqBacktest</div></div></foreignObject><text x=""30"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">TqBacktest</text></switch></g><path d=""M 115 160.5 L 125 160.5 L 125 220.5 L 135.5 220.5 L 120 239.5 L 104.5 220.5 L 115 220.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(64.5,183.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""107"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">backtest_recv_chan</div></div></foreignObject><text x=""54"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">backtest_recv_chan</text></switch></g><path d=""M 365 239.5 L 355 239.5 L 355 179.5 L 344.5 179.5 L 360 160.5 L 375.5 179.5 L 365 179.5 Z"" fill=""none"" stroke=""#000000"" stroke-linejoin=""round"" stroke-miterlimit=""10"" pointer-events=""none""/><g transform=""translate(307.5,205.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""110"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;background-color:#ffffff;"">backtest_send_chan</div></div></foreignObject><text x=""55"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">backtest_send_chan</text></switch></g></g></svg> 内存数据存储与更新 ---------------------------------------------------- 按照 DIFF 协议推荐的客户端最佳实践，TqApi 使用单一变量(TqApi._data)存储所有业务数据, 它的结构如下: .. raw:: html <svg xmlns=""http://www.w3.org/2000/svg"" xmlns:xlink=""http://www.w3.org/1999/xlink"" version=""1.1"" width=""581px"" viewBox=""-0.5 -0.5 581 882"" style=""max-width:100%;max-height:882px;""><defs/><g><path d=""M 40 40 L 40 880"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""0"" y=""0"" width=""80"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(37.5,13.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""4"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 4px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">/</div></div></foreignObject><text x=""2"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">/</text></switch></g><path d=""M 100 100 L 40 100"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 140 120 L 140 160 L 200 160"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""100"" y=""80"" width=""80"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(121.5,93.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""36"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 38px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">quotes</div></div></foreignObject><text x=""18"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">quotes</text></switch></g><path d=""M 240 180 L 240 210 L 300 210"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""200"" y=""140"" width=""80"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(202.5,153.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""74"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 76px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">SHFE.cu1901</div></div></foreignObject><text x=""37"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">SHFE.cu1901</text></switch></g><rect x=""300"" y=""200"" width=""80"" height=""20"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(313.5,203.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""52"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 52px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">last_price</div></div></foreignObject><text x=""26"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">last_price</text></switch></g><path d=""M 300 250 L 240 250 L 240 180"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""300"" y=""240"" width=""80"" height=""20"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(320.5,243.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""38"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 40px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">volume</div></div></foreignObject><text x=""19"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">volume</text></switch></g><path d=""M 200 300 L 140 300 L 140 120"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""200"" y=""280"" width=""80"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(202.5,293.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""74"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 76px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">SHFE.cu1902</div></div></foreignObject><text x=""37"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">SHFE.cu1902</text></switch></g><path d=""M 100 380 L 40 380 L 40 40"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""100"" y=""360"" width=""80"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(124.5,373.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""30"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 32px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">klines</div></div></foreignObject><text x=""15"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">klines</text></switch></g><path d=""M 100 440 L 40 440 L 40 40"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""100"" y=""420"" width=""80"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(127.5,433.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""24"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 25px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">ticks</div></div></foreignObject><text x=""12"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">ticks</text></switch></g><path d=""M 100 500 L 40 500 L 40 40"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""100"" y=""480"" width=""80"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(125.5,493.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""28"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 28px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">trade</div></div></foreignObject><text x=""14"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">trade</text></switch></g><path d=""M 200 560 L 140 560 L 140 520"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""200"" y=""540"" width=""80"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(224.5,553.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""30"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 32px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">user1</div></div></foreignObject><text x=""15"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">user1</text></switch></g><path d=""M 300 620 L 240 620 L 240 580"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""300"" y=""600"" width=""80"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(315.5,613.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""48"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 48px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">positions</div></div></foreignObject><text x=""24"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">positions</text></switch></g><path d=""M 400 680 L 340 680 L 340 640"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""400"" y=""660"" width=""80"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(402.5,673.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""74"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 76px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">SHFE.cu1901</div></div></foreignObject><text x=""37"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">SHFE.cu1901</text></switch></g><path d=""M 500 730 L 440 730 L 440 700"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""500"" y=""720"" width=""80"" height=""20"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(515.5,723.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""48"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 50px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">pos_long</div></div></foreignObject><text x=""24"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">pos_long</text></switch></g><path d=""M 500 770 L 440 770 L 440 700"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""500"" y=""760"" width=""80"" height=""20"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(513.5,763.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""52"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 54px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">pos_short</div></div></foreignObject><text x=""26"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">pos_short</text></switch></g></g></svg> 在每次收到数据包时，TqApi都会将数据包内容合并到 TqApi._data 中. 具体的代码流程如下: #. websocket client 收到数据包, 放入 TqApi._pending_diffs #. wait_update 函数发现 TqApi._pending_diffs 有待处理数据包, 中止异步循环以处理此数据包::  while not self._wait_timeout and not self._pending_diffs:  # 这里发现 self._pending_diffs 非空, 中止 while 循环   self._run_once() #. wait_update 调用 self._merge_diff 函数::  for d in self._diffs:   self._merge_diff(self._data, d, self._prototype, False) #. TqApi._merge_diff 函数将收到的数据包并入本地存储.   #. 对于k线之类的序列数据, 后续继续将更新的数据复制到 pandas dataframe 中 异步任务调度 ---------------------------------------------------- TqApi 在 wait_update 函数中完成所有异步任务的调度执行. 每当用户程序执行 api.wait_update 函数时, 会调度所有 task 运行, 直到收到新数据包或超时 wait_update函数返回, 继续执行后续用户代码 .. raw:: html <svg xmlns=""http://www.w3.org/2000/svg"" xmlns:xlink=""http://www.w3.org/1999/xlink"" version=""1.1"" width=""401px"" viewBox=""-0.5 -0.5 401 601"" style=""max-width:100%;max-height:601px;""><defs/><g><path d=""M 60 40 L 60 73.63"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 60 78.88 L 56.5 71.88 L 60 73.63 L 63.5 71.88 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""0"" y=""0"" width=""120"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(35.5,13.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""48"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 49px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">用户代码</div></div></foreignObject><text x=""24"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">用户代码</text></switch></g><path d=""M 60 120 L 60 153.63"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 60 158.88 L 56.5 151.88 L 60 153.63 L 63.5 151.88 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""0"" y=""80"" width=""120"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(17.5,93.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""84"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 86px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">api.wait_update</div></div></foreignObject><text x=""42"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">api.wait_update</text></switch></g><path d=""M 60 200 L 60 233.63"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 60 238.88 L 56.5 231.88 L 60 233.63 L 63.5 231.88 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""0"" y=""160"" width=""120"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(35.5,173.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""48"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 49px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">用户代码</div></div></foreignObject><text x=""24"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">用户代码</text></switch></g><path d=""M 60 280 L 60 313.63"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 60 318.88 L 56.5 311.88 L 60 313.63 L 63.5 311.88 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""0"" y=""240"" width=""120"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(17.5,253.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""84"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 86px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">api.wait_update</div></div></foreignObject><text x=""42"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">api.wait_update</text></switch></g><rect x=""280"" y=""180"" width=""120"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(295.5,186.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""88"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 90px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">websocket client<br />发送 task</div></div></foreignObject><text x=""44"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">websocket client&lt;br&gt;发送 task</text></switch></g><rect x=""280"" y=""220"" width=""120"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(295.5,226.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""88"" height=""26"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 90px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">websocket client<br />接收 task</div></div></foreignObject><text x=""44"" y=""19"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">websocket client&lt;br&gt;接收 task</text></switch></g><rect x=""280"" y=""300"" width=""120"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(286.5,313.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""106"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 108px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">用户创建的其它task</div></div></foreignObject><text x=""53"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">用户创建的其它task</text></switch></g><rect x=""280"" y=""260"" width=""120"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(289.5,273.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""100"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 100px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">TqSdk创建的tqsdk</div></div></foreignObject><text x=""50"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">TqSdk创建的tqsdk</text></switch></g><path d=""M 120 240 L 282.04 183"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" stroke-dasharray=""3 3"" pointer-events=""none""/><path d=""M 122.04 280 L 280 338"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" stroke-dasharray=""3 3"" pointer-events=""none""/><path d=""M 60 360 L 60 393.63"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 60 398.88 L 56.5 391.88 L 60 393.63 L 63.5 391.88 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""0"" y=""320"" width=""120"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(35.5,333.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""48"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 49px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">用户代码</div></div></foreignObject><text x=""24"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">用户代码</text></switch></g><path d=""M 60 440 L 60 473.63"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 60 478.88 L 56.5 471.88 L 60 473.63 L 63.5 471.88 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""0"" y=""400"" width=""120"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(17.5,413.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""84"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 86px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">api.wait_update</div></div></foreignObject><text x=""42"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">api.wait_update</text></switch></g><path d=""M 60 520 L 60 553.63"" fill=""none"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><path d=""M 60 558.88 L 56.5 551.88 L 60 553.63 L 63.5 551.88 Z"" fill=""#000000"" stroke=""#000000"" stroke-miterlimit=""10"" pointer-events=""none""/><rect x=""0"" y=""480"" width=""120"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(35.5,493.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""48"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 49px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">用户代码</div></div></foreignObject><text x=""24"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">用户代码</text></switch></g><rect x=""0"" y=""560"" width=""120"" height=""40"" fill=""#ffffff"" stroke=""#000000"" pointer-events=""none""/><g transform=""translate(17.5,573.5)""><switch><foreignObject style=""overflow:visible;"" pointer-events=""none"" width=""84"" height=""12"" requiredFeatures=""http://www.w3.org/TR/SVG11/feature#Extensibility""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 86px; white-space: nowrap; overflow-wrap: normal; text-align: center;""><div xmlns=""http://www.w3.org/1999/xhtml"" style=""display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"">api.wait_update</div></div></foreignObject><text x=""42"" y=""12"" fill=""#000000"" text-anchor=""middle"" font-size=""12px"" font-family=""Helvetica"">api.wait_update</text></switch></g></g></svg>  "
34,n\doc\dev\general,"n\doc\dev\general. .. _dev_general: 原则与规范 ==================================================== TqSdk设计原则 ---------------------------------------------------- 不预设用户策略模型 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 我们深刻认识到, 量化交易是一个充满竞争与创新的领域,成功的用户总是在不断构思和尝试全新的理念与模型. 在这方面, 用户比我们知道得更多, 走得也更快. 因此, 我们在设计TqSdk时, 总是尽力避免对用户的模型结构做限定, 而是专注于为用户提供通用性的资源和能力. 我们的以下设计决策遵循了此原则: * 不提供策略类模板, 只以示例程序方式展示各类策略应用 * 一个策略程序中可以任意获取数据和发出指令 * 允许用户在一个程序中使用任意多个TqApi实例 保持用户代码简单 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 我们对TqSdk的一个设计目标是尽量让用户的代码与需求方案保持一致(顺序相同, 篇幅相当). 我们的以下设计决策遵循了此原则: * 不使用多线程, 避免用户处理线程同步问题 * 不使用回调模型, 避免用户维护状态机状态变量 * 提供专门的调仓工具 * 实盘/模拟/回测/复盘 几种不同运行模式切换, 只需要在代码中做单点修改 行为可验证 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 作为TqSdk库质量管控的关键措施, 我们要求 TqSdk 在运行时可以记录完整的输入信息, 以确保发生问题时可以稳定重现问题和定位原因. 我们做了这些决定: * 以数据流衔接库中的各组件 * TqSdk 的日志文件完整记录收到的全部数据包 * 专门构建了一个单元测试框架, 可以直接用日志作为测试用例输入 相关知识与技能 ---------------------------------------------------- TqSdk 的开发涉及以下知识点，您可能需要先学习它们，才能更好的理解和改进TqSdk的代码 * 金融相关业务知识  TqSdk是用于金融交易领域的专用软件包。我们假定用户和开发者都已经具备相应的基础知识，在TqSdk的文档中不再详加解释。  * python asyncio  TqSdk 的代码大量依赖 python asyncio 机制. asyncio 的编程模型与传统 python 程序差异很大. 我们对于TqSdk的使用者尽量隐藏了 asyncio 相关概念, 允许用户在不了解 asyncio 的情况下实现绝大多数业务需求. 但是对于开发者, 若不了解 asyncio, 在理解 TqSdk 内部代码实现时会非常困难。  * Diff协议  TqSdk 并不是一个 all-in-one 的包, 它的能力有赖于一系列后台服务的支持. DIFF协议是 TqSdk 与后台服务间通讯的主要协议, 开发者需对 DIFF 有所理解, 才能掌握 TqSdk 的内部实现  * Pandas/Numpy   Pandas/Numpy 是非常优秀的 python 数值计算库. TqSdk 利用这些库完成K线序列数据的存储和操作. 代码风格 ---------------------------------------------------- TqSdk的代码风格遵循 PEP8 规范. 日志规范 ---------------------------------------------------- @todo: 待写 "
35,n\doc\dev\gui,n\doc\dev\gui. .. _dev_gui: Web Gui ==================================================== @todo: 待写 
36,n\doc\dev\index,n\doc\dev\index. .. _dev: 参与TqSdk开发 ======================================== .. toctree::  :maxdepth: 2  general.rst  framework.rst  async_tool.rst  gui.rst  backtest.rst  unittest.rst 
37,n\doc\dev\unittest,n\doc\dev\unittest. .. _dev_unittest: 单元测试 ==================================================== @todo: 待写 
38,n\doc\devtools\drawindex,"n\doc\devtools\drawindex. .. _draw_indicator: 技术指标绘图和使用示例 ========================================================================= 在TqSdk中我们提供了非常丰富的 :ref:`tqsdk.ta` ，下面我们以真实波幅均值（ATR average true range）为例，来讲解这个指标在策略中如何使用并在天勤终端和VS code插件版中进行画图 ATR的计算比较简单，首先我们要算出当前真实的波幅.这里不单单考虑当前的价格波动，同时也要考虑到前一个时间点收盘价和当前开盘价之间的价格缺口.而ATR则是真实波幅一段时间窗口（一般取14天）的简单移动平均.计算公式如下： 1.真实波幅（TR）： TR = MAX（∣最高价-最低价∣，∣最高价-昨收∣，∣昨收-最低价∣） 2.真实波幅均值（ATR）： ATR = TR的N日简单移动平均 在天勤中我们可以很方便的计算出以上两个数据::  # 获取 SHFE.au1912 合约的平均真实波幅，导入TqApi和对应的技术指标函数ATR  from tqsdk import TqApi, TqAuth  from tqsdk.ta import ATR  api = TqApi(TqAuth(""信易账户"", ""账户密码""))  klines = api.get_kline_serial(""SHFE.au1912"", 24 * 60 * 60)  atr = ATR(klines, 14)  print(atr.tr) # 真实波幅  print(atr.atr) # 真实波幅均值  # 预计的输出是这样的:  [..., 143.0, 48.0, 80.0, ...]  [..., 95.20000000000005, 92.0571428571429, 95.21428571428575, ...]  # 通过api.wait_update()将vs code信息发送给天勤终端  api.wait_update()  api.close() 	 如何在天勤终端和外部天勤IDE插件进行绘图？ -------------------------------------------------------------------------- 在得到这两个数据之后，我们可使用天勤终端内配置的IDE或 Vs Code插件版来进行绘图::  # 创建副图以折线显示art.art数据  klines[""ATR_atr""] = atr.atr  # ATR_atr.board为选择图版，可选，缺省为""MAIN""表示绘制在主图  klines[""ATR_atr.board""] = ""ATR_atr""  # 通过api.wait_update()将vs code信息发送给天勤终端  api.wait_update()  api.close() 	 以上代码运行之后，会在天勤内部绘制额外atr.atr副图 .. figure:: ../images/draw_index.png 设定color和width对应可选参数即可更改副图图像颜色和宽度属性::  # 在副图以折线形态显示atr.tr数据  klines[""ATR_tr""] = atr.tr  # ATR_tr.board为选择图版，可选，缺省为""MAIN""表示绘制在主图  klines[""ATR_tr.board""] = ""ATR_tr""  # ATR_tr.color为文本颜色，可选，缺省为红色  klines[""ATR_tr.color""] = 0xFF00FF00  # ATR_tr.width 为折线宽度，可选  klines[""ATR_tr.width""] = 3  # 创建另外副图显示art.art数据  klines[""ATR_atr""] = atr.atr  klines[""ATR_atr.board""] = ""ATR_atr""  # 通过api.wait_update()将vs code信息发送给天勤终端  api.wait_update()  api.close() 运行代码显示如下： .. figure:: ../images/indicate_index.png 更多的画图示例在示例程序 t90 - t95 ： :ref:`demo`"
39,n\doc\devtools\index,n\doc\devtools\index. .. _devtools: 开发支持工具 ========================================================================= TqSdk并不需要依赖任何IDE即可工作。对于习惯使用vscode/pycharm等IDE进行python开发的用户，我们通过IDE插件的方式提供了一些有用的附加功能。包括: * 复盘支持 * 交易监控及报告 * 在行情图上绘制指标和其它图形 .. toctree::  :maxdepth: 2   vscode.rst 
40,n\doc\devtools\vscode,"n\doc\devtools\vscode. .. _vscode: 天勤 Vs Code 插件 ==================================================== 天勤 Vs Code插件为在vscode中进行tqsdk相关程序提供一系列便利和支持。它可以帮助您： * 在策略运行时自动保存日志和成交记录 * 自动显示策略相关合约的K线图 * 一键打包 python 程序为独立可执行程序 安装天勤 Vs Code插件 ---------------------------------------------------- 在 Vs Code extension 中输入 ""天勤量化""或“tqsdk”, 点击【install】按钮，同时第一次使用Vs Code 还需配置安装 “Pyhton” 插件 .. figure:: ../images/vscode_install.png 插件安装好以后, 需要先配置账户参数才能使用,可以右键选项,选择【设置天勤参数】 .. figure:: ../images/vscode_setting_config.png 然后配置如下信息 * 实盘交易账号(选填) * 信易账号(必填，没有的话可以前往 :ref:`shinny_account` 注册) .. figure:: ../images/vscode_setting_account.png 配置完毕后，点击菜单栏上的【天勤量化】，将出现一个这样的面板: .. figure:: ../images/vscode_click_tianqinlianghua.png 祝贺你， Vs Code插件已经安装配置完毕，可以开始使用了, 程序运行后会在右侧自动显示图表 Vs Code插件策略运行 ---------------------------------------------------- 要运行策略程序，请在策略程序的右键菜单中选择【在实盘中运行】或【在模拟账户中运行】 .. figure:: ../images/vscode_click.png 一旦策略程序开始运行，右侧的天勤面板中将输出策略运行日志。如果策略程序中有绘图输出，也会输出到右侧面板中: 插件会自动保存用户策略的全部报单和print输出信息到硬盘文件，并可在reports目录下随时查看 .. figure:: ../images/vscode_strategy_picture.png 注意：当右键菜单已经设置了账户信息，但与代码中设置的不一致时，将以右键设置的账户信息为准::  api = TqApi(TqAccount(""快期模拟"", ""test001@qq.com"", ""123838"")) # 使用实盘交易账户 当我们使用右键菜单【实盘账户运行策略】时，程序会以菜单中设置的实盘账户运行，而不是代码中的账户 当我们想要停止正在运行/回测的策略时候，我们有两种方法：第一种直接在 Vs Code 下方的 Terminal 按住 Ctrl + C 键，第二种是直接在策略运行/回测时点击 Termial 右上方的垃圾桶键，终止程序运行 .. figure:: ../images/vscode_kill_terminal.png Vs Code插件回测策略 ---------------------------------------------------- 回测功能为 TqSdk 专业版功能，如果需要使用 `可以购买专业版或申请试用 <https://www.shinnytech.com/tqsdk_professional/>`_ ，在获得专业版权限后，设置正确的信易账户，我们即可回测自己的策略 右键菜单中提供默认【回测7天】和【回测30天】 同时我们也提供自定义回测区间功能，右键选择【设置天勤参数】，即可进入设置自定义回测区间 .. figure:: ../images/vscode_setting_backtesttime.png 设置成功之后，菜单栏中的【回测策略（自定义回测区间）】即可以刚刚设置的自定义回测区间回测任何策略 .. figure:: ../images/vscode_backtest_setting_finished.png 回测策略程序时，策略交易记录和日志同样会在天勤面板中输出，同时策略报告图会在右侧显示 .. figure:: ../images/vscode_backtest_report.png .. figure:: ../images/vscode_backtest_report_detail.png Vs Code插件复盘行情 ---------------------------------------------------- 在Vs Code中提供和 TqSdk 中一样的复盘功能，首先右键进入天勤参数中选择复盘的具体日期 .. figure:: ../images/vscode_setting_config.png 复盘具体日期选择完毕后，右键选择 【复盘模式运行策略文件】 .. figure:: ../images/vscode_run_replay.png 图形界面上方可以选择暂停，加减速复盘运行 .. figure:: ../images/vscode_replay_speed.png 在Vs Code插件中绘图形 -------------------------------------------------------------------------- 策略在Vs Code插件版运行时，也可以进行自定义指标绘图，具体操作请参见 :ref:`demo` 中t90——t95 策略程序打包成独立应用程序 ---------------------------------------------------- 在Vs Code版本中我们提供了一键策略程序打包功能，可以将指定策略程序打包成exe文件，方便用户将自己私人策略打包加密之后提供他人使用 使用策略程序打包功能之前，建议先阅读 :ref:`gui` 以下面代码为例，我们来看看策略程序打包成独立应用程序，具体有什么表现效果 .. literalinclude:: ../../tqsdk/demo/gui/param_input.py :language: python 首先右键点击【策略程序打包成独立应用程序】 .. figure:: ../images/vscode_save_exe.png 打包完成之后，运行对应exe文件画面显示效果如下 .. figure:: ../images/vscode_gui_performance.png "
41,n\doc\devtools\tq\index,n\doc\devtools\tq\index. .. _tq: 天勤终端 ========================================================================= 天勤终端是一款基于TqSdk开发的外部GUI，TqSdk并不需要依赖天勤终端即可运行。 .. toctree::  :maxdepth: 2  quickstart.rst  strategybacktest.rst  strategyrun.rst  tqreplay.rst 
42,n\doc\devtools\tq\quickstart,"n\doc\devtools\tq\quickstart. .. _tq_quickstart: 下载天勤终端 ========================================================================= 天勤终端目前只支持 Windows 操作系统。要安装天勤软件，请点击 `天勤终端 <https://www.shinnytech.com/?smd_process_download=1&download_id=4279>`_ 下载 下载完毕后，双击安装包进行安装。 在安装过程中可以根据您的需求选择【最小安装】，【完整安装】或【自定义安装】 .. figure:: ../../images/custom_settings.png 最小安装 -------------------------------------------------------------------------- 【最小安装】为使用天勤终端的推荐方案 安装完成之后，建议配置天勤终端的python环境和IDE，方便终端使用，其中python环境需要安装TqSdk安装包 具体配置步骤如下 ● 点击终端【选项】按钮 ● 配置对应的python路径和IDE路径,注意配置为pythonw.exe文件 .. figure:: ../../images/config_ide_python.png 完整安装 -------------------------------------------------------------------------- 【完全安装】仅推荐用户电脑上无python环境下选择，存在python环境后选择该方案可能干扰之前的配置环境 选择【完整安装】，会默认帮助用户配置python环境，安装TqSdk开发包等，配置Nodepad++, 此方案下的天勤终端无需再额外配置即可进行策略编辑， .. figure:: ../../images/complete_config.png 注册模拟账号 -------------------------------------------------------------------------- 点击 `【申请模拟账号】 <https://www.shinnytech.com/registration>`_ 后，会自动打开【天勤量化】注册页，填写以下对应信息之后，并点击激活邮件，即可用【邮箱地址】登录天勤终端【快期模拟】和用户论坛 .. figure:: ../../images/tq_register.png 同时【快期模拟】，也可以在TqSdk中通过TqAccount函数进行登录，具体请参照 :ref:`real_trading` "
43,n\doc\devtools\tq\strategybacktest,"n\doc\devtools\tq\strategybacktest. .. _strategybacktest: 终端策略回测 ========================================================================= 在天勤终端，我们提供了便捷的方法让大家能够便捷的进行回测，【首页】左侧为回测运行管理区 .. figure:: ../../images/strategybacktest_begin.png 点击【回测】后，会出现一个弹出框, 让你填写具体回测区间 .. figure:: ../../images/input_backtest_date.png 回测时间输入完毕，然后点击【确定】做到这一步, 策略程序就正式执行回测了 要停止一个执行中的回测, 只需双击它. 再次双击, 会从头开始重新回测   回测结果 ------------------------------------------------------------------------- 天勤的回测报告, 是在整个回测过程中不断更新的 策略报告 ------------------------------------------------------------------------- 策略报告展示策略程序回测的收益情况和资金曲线, 如下 .. figure:: ../../images/strategy_backtest_report.png 策略日志 ------------------------------------------------------------------------- 策略程序中用 print 或 logging 输出的信息, 都会出现在这里 .. figure:: ../../images/strategy_output.png 策略交易图 ------------------------------------------------------------------------- 策略交易图展示一个合约的交易和持仓情况 .. figure:: ../../images/strategy_symbol_image.png 它包含了这些内容 ● 成交记录: 图上用红色和绿色的箭头标注实际发生的成交时间和成交价格 ● 持仓记录: 当策略在一段时间内有持仓时, 图上会用红绿色矩形框表示. 红色框表示这段时间的持仓方向与行情方向一致(盈利), 反之为绿色 ● 当前挂单: 如果策略当前还有挂单, 将在图上以横线虚线的形式显示 ● 当前持仓: 如果策略当前还有持仓, 将在图上以横线实线的形式显示 ● 成交记录定位: 如果你在策略日志中选中任意一条日志记录, 图上会用紫色竖条标出这条日志记录的具体时间 如果策略程序交易涉及多个合约, 可以在策略日志中选择一条, 策略交易图将切换到选中的合约 要改变图表K线周期, 请点击菜单右上方对应时间周期 如有需要, 你可以在策略交易图上添加技术指标或者手工画线 再次回测 ------------------------------------------------------------------------- 所有运行过的回测结果都会自动保存, 随时可以点击查看 当策略程序修改以后, 如需再次运行回测, 只需对回测任务再次双击即可, 再次回测依然使用前次回测的参数 回测与真实运行有哪些差别 ------------------------------------------------------------------------- 我们在设计复盘功能时, 已尽量模仿真实交易的场景. 但由于种种限制, 与实盘运行相比, 回测时在行情和交易方面依然有一些重要的差别 由于回测时使用模拟交易, 成交情况与实盘交易不可避免地存在一些区别 ● 模拟交易要求报单价格大于等于对手盘价格才会成交, 例如下买单, 要求价格大于等于卖一价才会成交, 如果不能立即成交则会等到下次行情更新再重新判断  回测模式下 quote 的更新频率由所订阅的 tick 和 k线周期确定 ● 只要策略程序订阅了tick, 则对应合约的 quote 就会使用 tick 生成, 更新频率也和 tick 一致, 但只有这些字段: datetime/ask&bid_price1/ask&bid_volume1/last_price/highest/lowest/average/volume/amount/open_interest/ price_tick/price_decs/volume_multiple/max&min_limit&market_order_volume/underlying_symbol/strike_price  ● 如果策略程序没有订阅tick, 但是订阅了 k线, 则对应合约的 quote 会使用 k线生成, 更新频率和 k线的周期一致. 如果订阅了某个合约的多个周期的 k线, 则任一个周期的 k线有更新时, quote 都会更新. 使用 k线生成的 quote 的盘口由收盘价分别加/减一个最小变动单位, 并且 highest/lowest/average/amount 始终为 nan, volume 始终为0  ● 如果策略程序既没有订阅tick, 也没有订阅 k线或订阅的k线周期大于分钟线, 则 TqBacktest 会自动订阅分钟线来生成 quote  回测模式下k线会在刚创建出来时和结束时分别更新一次, 在这之间 k线是不会更新的  回测模式下 wait_update 每次最多推进一个行情时间 用复盘模式测试策略程序 ------------------------------------------------------------------------- 除了回测以外, 你还可以选择用 :ref:`tqreplay` 下的模拟交易来测试你的策略程序 启动天勤复盘模式, 回到过去的某个时间. 详见 :ref:`tqreplay` 按照 :ref:`strategyrun` 的说明, 启动策略运行 "
44,n\doc\devtools\tq\strategyrun,"n\doc\devtools\tq\strategyrun. .. _strategyrun: 终端策略运行 ========================================================================= 在天勤终端中运行和停止一个策略 ------------------------------------------------------------------------- 页面左侧为策略运行管理区 .. figure:: ../../images/strategy_ready_run.png 要创建新策略, 点击 【创建新策略】 按钮. 然后输入新策略文件的文件名： .. figure:: ../../images/create_strategy.png 点击【保存】后，如果您当时选择的是天勤终端全即可在天勤内置的VS Code保存该策略 .. figure:: ../../images/save_strategy.png 编辑策略参数 ------------------------------------------------------------------------- 如果需要对指定策略进行参数修改，则右键点击需要修改策略，即可修改对应参数，如合约代码等，修改完毕之后点击保存，该策略即可以新参数运行 .. figure:: ../../images/input_parameter.png 策略运行监控 ------------------------------------------------------------------------- 天勤为策略运行提供全面监控. 在策略运行表中选中任一个策略, 页面会立即显示所选策略的运行情况 策略日志 ------------------------------------------------------------------------- 策略程序中用 print 或 logging 输出的信息, 都会出现在这里 .. figure:: ../../images/strategy_output.png 策略交易图 ------------------------------------------------------------------------- 策略交易图展示一个合约的交易和持仓情况 .. figure:: ../../images/strategy_symbol_image.png 它包含了这些内容 ● 成交记录: 图上用红色和绿色的箭头标注实际发生的成交时间和成交价格 ● 持仓记录: 当策略在一段时间内有持仓时, 图上会用红绿色矩形框表示. 红色框表示这段时间的持仓方向与行情方向一致(盈利), 反之为绿色 ● 当前挂单: 如果策略当前还有挂单, 将在图上以横线虚线的形式显示 ● 当前持仓: 如果策略当前还有持仓, 将在图上以横线实线的形式显示 ● 成交记录定位: 如果你在策略日志中选中任意一条日志记录, 图上会用紫色竖条标出这条日志记录的具体时间 如果策略程序交易涉及多个合约, 可以在策略日志中选择一条, 策略交易图将切换到选中的合约 要改变图表K线周期, 请点击菜单右上方对应时间周期 如有需要, 你可以在策略交易图上添加技术指标或者手工画线"
45,n\doc\devtools\tq\tqreplay,"n\doc\devtools\tq\tqreplay. .. _tqreplay: 终端历史复盘 ========================================================================= 天勤终端支持全面历史复盘. 您只需指定任一交易日，天勤终端将回到那一天，并完整重演全天的行情变化.在此过程中，您可以如常使用软件全部功能及扩展接口，一切都有如真正回到那天一样，您在回放过程中可以任意暂停或加减速. 使用历史复盘功能 ------------------------------------------------------------------------- 欲使用历史复盘功能, 请按以下步骤操作: ● 点击桌面上的 天勤终端-复盘 图标 启动 ● 在软件启动时, 先选择一个日期, 然后点击 【开始历史复盘】 .. figure:: ../../images/tq_mdreplay.png ● 软件将会以指定的交易日启动, 您可以如常使用软件功能. 复盘状态下默认登录一个 初始资金 100万 的模拟交易账户, 可以进行交易练习. ● 在复盘状态下, 屏幕上将始终有一个悬浮控制框, 可以调整行情回放速度 .. figure:: ../../images/change_speed_replay.png ● 要从复盘状态回到正常使用状态, 请退出软件, 重新启动 "
46,n\doc\reference\index,n\doc\reference\index. .. _tqsdk_apis: TqSdk 模块参考 ==================================================================== .. toctree::  :maxdepth: 1  tqsdk.api.rst  tqsdk.auth.rst  tqsdk.account.rst  tqsdk.tqkq.rst  tqsdk.sim.rst  tqsdk.multiaccount.rst  tqsdk.objs.rst  tqsdk.lib.rst  tqsdk.ta.rst  tqsdk.tafunc.rst  tqsdk.backtest.rst  tqsdk.algorithm.rst  tqsdk.risk_rule.rst  tqsdk.tools.download.rst  tqsdk.exceptions.rst 
47,n\doc\reference\tqsdk.account,n\doc\reference\tqsdk.account. .. _tqsdk.account: tqsdk.TqAccount - 实盘账户类 ------------------------------------------------------------------ .. autoclass:: tqsdk.TqAccount  :members:  :inherited-members: 
48,n\doc\reference\tqsdk.algorithm,n\doc\reference\tqsdk.algorithm. .. _tqsdk.algorithm: tqsdk.algorithm - 算法模块 ------------------------------------------------------------------ .. _tqsdk.algorithm.twap: tqsdk.algorithm.twap - Twap 算法 ================================================================== .. automodule:: tqsdk.algorithm.twap  :members: .. _tqsdk.algorithm.time_table_generater: tqsdk.algorithm.time_table_generater - 生成 time_table 辅助函数 ================================================================== .. automodule:: tqsdk.algorithm.time_table_generater  :members: 
49,n\doc\reference\tqsdk.api,n\doc\reference\tqsdk.api. .. _tqsdk.api: tqsdk.TqApi - 框架及核心业务 ------------------------------------------------------------------ .. autoclass:: tqsdk.TqApi  :members: 
50,n\doc\reference\tqsdk.auth,n\doc\reference\tqsdk.auth. .. _tqsdk.auth: tqsdk.TqAuth - 用户认证类 ------------------------------------------------------------------ .. autoclass:: tqsdk.TqAuth  :members: 
51,n\doc\reference\tqsdk.backtest,n\doc\reference\tqsdk.backtest. .. _tqsdk.backtest: tqsdk.TqBacktest - 策略回测 ------------------------------------------------------------------ .. autoclass:: tqsdk.TqBacktest  :members: 
52,n\doc\reference\tqsdk.exceptions,n\doc\reference\tqsdk.exceptions. .. _tqsdk.exceptions: tqsdk.exceptions - 抛出例外 ------------------------------------------------------------------ .. automodule:: tqsdk.exceptions  :members: 
53,n\doc\reference\tqsdk.lib,n\doc\reference\tqsdk.lib. .. _tqsdk.lib: tqsdk.lib - 业务工具库 ------------------------------------------------------------------ .. _tqsdk.lib.notify: tqsdk.TqNotify - 收集通知信息工具 ================================================================== .. autoclass:: tqsdk.TqNotify  :members: .. _tqsdk.target_pos_task: tqsdk.TargetPosTask - 目标持仓工具 ================================================================== .. autoclass:: tqsdk.TargetPosTask  :members: .. autoclass:: tqsdk.InsertOrderUntilAllTradedTask  :members: .. autoclass:: tqsdk.InsertOrderTask  :members: .. _tqsdk.lib.target_pos_scheduler: tqsdk.TargetPosScheduler - 基于时间维度的目标持仓工具 ================================================================== .. autoclass:: tqsdk.TargetPosScheduler  :members: 
54,n\doc\reference\tqsdk.multiaccount,n\doc\reference\tqsdk.multiaccount. .. _tqsdk.multiaccount: tqsdk.TqMultiAccount - 多账户 ------------------------------------------------------------------ .. autoclass:: tqsdk.TqMultiAccount  :members: 
55,n\doc\reference\tqsdk.objs,n\doc\reference\tqsdk.objs. .. _tqsdk.objs: tqsdk.objs - 业务对象 ------------------------------------------------------------------ .. automodule:: tqsdk.objs  :members: 
56,n\doc\reference\tqsdk.risk rule,n\doc\reference\tqsdk.risk rule. .. _tqsdk.risk_rule: tqsdk.risk_rule - 风控类模块 ------------------------------------------------------------------ .. automodule:: tqsdk.risk_rule  :members: 
57,n\doc\reference\tqsdk.sim,n\doc\reference\tqsdk.sim. .. _tqsdk.sim: tqsdk.TqSim - 本地模拟交易 ------------------------------------------------------------------ .. autoclass:: tqsdk.TqSim  :members:  :inherited-members: .. _tqsdk.sim_stock: tqsdk.TqSimStock - 本地股票模拟交易 ------------------------------------------------------------------ .. autoclass:: tqsdk.TqSimStock  :members:  :inherited-members: 
58,n\doc\reference\tqsdk.ta,n\doc\reference\tqsdk.ta. .. _tqsdk.ta: tqsdk.ta - 技术指标计算函数 ------------------------------------------------------------------ .. automodule:: tqsdk.ta  :members:  :autosummary:
59,n\doc\reference\tqsdk.tafunc,n\doc\reference\tqsdk.tafunc. .. _tqsdk.tafunc: tqsdk.tafunc - 序列计算函数 ------------------------------------------------------------------ .. automodule:: tqsdk.tafunc  :members:  :autosummary:
60,n\doc\reference\tqsdk.tools.download,n\doc\reference\tqsdk.tools.download. .. _tqsdk.tools.downloader: tqsdk.tools.DataDownloader - 数据下载工具 ------------------------------------------------------------------ .. autoclass:: tqsdk.tools.DataDownloader  :members: 
61,n\doc\reference\tqsdk.tqkq,n\doc\reference\tqsdk.tqkq. .. _tqsdk.tqkq: tqsdk.TqKq - 快期模拟交易类 ------------------------------------------------------------------ .. autoclass:: tqsdk.TqKq  :members:  :inherited-members: .. _tqsdk.tqkq_stock: tqsdk.TqKqStock - 快期股票模拟交易类 ------------------------------------------------------------------ .. autoclass:: tqsdk.TqKqStock  :members:  :inherited-members: 
62,n\doc\usage\backtest,"n\doc\usage\backtest. .. _backtest: 策略程序回测 ================================================= 策略程序回测是 TqSdk 专业版中的功能，能让用户在不改变代码的情况下去回测自己的策略在历史行情的表现 如果想使用策略回测该功能，可以点击 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_ 申请使用或购买 对于 TqSdk 免费版本的用户，每天可以进行3次回测，同时也可以申请模拟账户后模拟运行来检验策略 :ref:`sim_trading` 执行策略回测 ------------------------------------------------- 使用 TqSdk 编写的策略程序，不需要修改策略代码，只需要在创建 api 实例时给backtest参数传入 :py:class:`~tqsdk.TqBacktest` , 策略就会进入历史回测模式:: from datetime import date from tqsdk import TqApi, TqAuth, TqSim, TqBacktest api = TqApi(TqSim(), backtest=TqBacktest(start_dt=date(2018, 5, 1), end_dt=date(2018, 10, 1)), auth=TqAuth(""信易账户"", ""账户密码"")) 使用tqsdk在回测结束后会输出交易记录和每日收盘时的账户资金情况，以及最大回撤、夏普比率等指标，这些数据可以导入到 excel 中或使用其他分析工具进一步处理。 回测示例程序：:ref:`tutorial-backtest` 在回测结束时获取回测详细信息 ------------------------------------------------- 要在回测结束时调用您自己写的代码, 可以使用 try/except 机制捕获回测结束信号 BacktestFinished, 像这样:: from tqsdk import BacktestFinished acc = TqSim() try:  api = TqApi(acc, backtest=TqBacktest(start_dt=date(2018, 5, 1), end_dt=date(2018, 10, 1)), auth=TqAuth(""信易账户"", ""账户密码""))  #策略代码在这里  #... except BacktestFinished as e:  # 回测结束时会执行这里的代码  api.close()  print(acc.trade_log) # 回测的详细信息  print(acc.tqsdk_stat) # 回测时间内账户交易信息统计结果，其中包含以下字段  # init_balance 起始资金  # balance 结束资金  # max_drawdown 最大回撤  # profit_loss_ratio 盈亏额比例  # winning_rate 胜率  # ror 收益率  # annual_yield 年化收益率  # sharpe_ratio 年化夏普率  # tqsdk_punchline 天勤点评 回测的详细信息保存在回测所用的模拟账户 TqSim 中, 可以直接访问它的成员变量 trade_log(格式为 日期->交易记录及收盘时的权益及持仓). 同时我们也提供简单的图形化的回测报告功能供大家使用 :ref:`web_gui` ，使用效果参考下图 .. figure:: ../images/web_gui_backtest.png .. _backtest_with_web_gui: 回测结束在浏览器中查看绘图结果 ------------------------------------------------- 要在回测结束时，如果依然需要在浏览器中查看绘图结果，同时又需要打印回测信息，您应该这样做:: from tqsdk import BacktestFinished acc = TqSim() try:  api = TqApi(acc, backtest=TqBacktest(start_dt=date(2018, 5, 1), end_dt=date(2018, 10, 1)), auth=TqAuth(""信易账户"", ""账户密码""))  #策略代码在这里  #... except BacktestFinished as e:  print(acc.tqsdk_stat) # 回测时间内账户交易信息统计结果，其中包含以下字段  # 由于需要在浏览器中查看绘图结果，因此程序不能退出  while True:   api.wait_update() .. _backtest_underlying_symbol: 回测时获取主连合约标的 ------------------------------------------------- 在天勤中回测时，对于主连合约，我们支持用户使用 **quote.underlying_symbol** 获取回测当时的标的合约。 示例::  from datetime import date  from tqsdk import TqApi, TqAuth, TqBacktest, BacktestFinished  api = TqApi(backtest=TqBacktest(start_dt=date(2020, 1, 1), end_dt=date(2020, 10, 1)), auth=TqAuth(""信易账户"", ""账户密码""))  quote = api.get_quote(""KQ.m@CFFEX.T"")  print(quote.datetime, quote.underlying_symbol)  try:   while True:    api.wait_update()    if api.is_changing(quote, ""underlying_symbol""):     print(quote.datetime, quote.underlying_symbol)  except BacktestFinished:   api.close()  # 预期输出：  # 2019-12-31 15:14:59.999999 CFFEX.T2003  # 2020-02-19 09:15:00.000000 CFFEX.T2006  # 2020-05-14 09:15:00.000000 CFFEX.T2009  # 2020-08-19 09:30:00.000000 CFFEX.T2012 .. _backtest_rule: 回测时的成交规则和推进 ------------------------------------------------- 在天勤中回测时，除了期货、期权合约以外，我们还支持使用 **指数** 进行回测和在回测中交易，指数合约代码格式参见 :ref:`mddatas` 策略回测时使用内置模拟账户 :py:class:`~tqsdk.TqSim` , 默认回测资金为1000w , 如果需要修改初始回测资金，只需给 TqSim 传入需要设定的金额即可:: from datetime import date from tqsdk import TqApi, TqAuth, TqSim, TqBacktest api = TqApi(TqSim(10000), backtest=TqBacktest(start_dt=date(2018, 5, 1), end_dt=date(2018, 10, 1)), auth=TqAuth(""信易账户"", ""账户密码"")) 撮合成交规则为对价成交. 即限价单的价格达到对手盘价格时判定为成交. 不会出现委托单部分成交的情况. 回测时策略程序报单, 会立即做一次成交判定. 回测框架的规则是当没有新的事件需要用户处理时才推进到下一个行情, 也就是这样:: q = api.get_quote(""SHFE.cu1901"") api.wait_update()      # 这个 wait_update 更新了行情 api.insert_order(""SHFE.cu1901"", ...) # 程序下单 api.wait_update()      # 这个 wait_update 只会更新委托单状态, 行情还是停在原处 api.insert_order(""SHFE.cu1901"", ...) # 如果又下了一个单 api.wait_update()      # 这个 wait_update 还是只会更新委托单状态, 行情还是停在原处 api.wait_update()      # 这个 wait_update 更新了行情  .. _security_backtest: 对股票合约进行回测 ------------------------------------------------- TqSdk 在 3.2.0 版本后支持了对股票合约进行回测功能，在回测过程中用户需要初始化 :py:class:`~tqsdk.TqSimStock` 类，且该类只能支持股票模拟交易 由于股票市场 T+1 的规则, :py:class:`~tqsdk.lib.TargetPosTask` 函数目前还不支持在股票交易中使用，股票合约交易时只支持使用 :py:class:`~tqsdk.TqApi.insert_order` 如果您想要在回测中同时交易期货和股票合约，则可以使用 :py:class:`~tqsdk.TqMultiAccount` 来实现该需求::  # 同时使用 TqSim 交易期货，TqSimStock 交易股票  from tqsdk import TqApi, TqAuth, TqMultiAccount, TqSim, TqSimStock  tqsim_future = TqSim()  tqsim_stock = TqSimStock()  api = TqApi(account=TqMultiAccount([tqsim_future, tqsim_stock]), auth=TqAuth(""信易账户"", ""账户密码""))  # 多账户下单，需要指定下单账户  order1 = api.insert_order(symbol=""SHFE.cu2112"", direction=""BUY"", offset=""OPEN"", volume=10, limit_price=72250.0, account=tqsim_future)  order2 = api.insert_order(symbol=""SSE.603666"", direction=""BUY"", volume=300, account=tqsim_stock)  while order1.status != 'FINISHED' or order2.status != 'FINISHED':   api.wait_update()  # 打印账户可用资金  future_account = tqsim_future.get_account()  stock_account = tqsim_stock.get_account()  print(future_account.available, stock_account.available)  api.close() 回测使用多行情序列的策略程序 ------------------------------------------------- TqSdk 允许一个策略程序中使用多个行情序列, 比如这样:: #... 策略程序代码 ka1 = api.get_kline_serial(""SHFE.cu1901"", 60) ka2 = api.get_kline_serial(""SHFE.cu1901"", 3600) kb = api.get_kline_serial(""CFFEX.IF1901"", 3600) tsa = api.get_tick_serial(""CFFEX.IF1901"") qa = api.get_quote(""DCE.a1901"") #... 策略程序代码 TqSdk回测框架使用一套复杂的规则来推进行情： 规则1: tick 序列(例如上面例子中的tsa) 总是按逐 tick 推进:: tsa = api.get_tick_serial(""CFFEX.IF1901"") print(tsa.datetime.iloc[-1])    # 2018/01/01 09:30:00.000 api.wait_update()       # 推进一个tick print(tsa.datetime.iloc[-1])    # 2018/01/01 09:30:00.500 规则2: K线序列 (例如上面例子中的ka1, ka2) 总是按周期推进. 每根K线在创建时和结束时各更新一次:: ka2 = api.get_kline_serial(""SHFE.cu1901"", 3600) # 请求小时线 print(ka2.iloc[-1])       # 2018/01/01 09:00:00.000, O=35000, H=35000, L=35000, C=35000 小时线刚创建 api.wait_update()       # 推进1小时, 前面一个小时线结束, 新开一根小时线 print(ka2.iloc[-2])       # 2018/01/01 09:00:00.000, O=35000, H=35400, L=34700, C=34900 9点这根小时线完成了 print(ka2.iloc[-1])       # 2018/01/01 10:00:00.000, O=34900, H=34900, L=34900, C=34900 10点的小时线刚创建 规则3: quote按照以下规则更新:: if 策略程序中使用了这个合约的tick序列:  每次tick序列推进时会更新quote的这些字段 datetime/ask&bid_price1/ask&bid_volume1/last_price/highest/lowest/average/volume/amount/open_interest/price_tick/price_decs/volume_multiple/max&min_limit&market_order_volume/underlying_symbol/strike_price elif 策略程序中使用了这个合约的K线序列:  每次K线序列推进时会更新quote. 使用 k线生成的 quote 的盘口由收盘价分别加/减一个最小变动单位, 并且 highest/lowest/average/amount 始终为 nan, volume 始终为0.  每次K线序列推进时会更新quote的这些字段 datetime/ask&bid_price1/ask&bid_volume1/last_price/open_interest/price_tick/price_decs/volume_multiple/max&min_limit&market_order_volume/underlying_symbol/strike_price  if 策略程序使用的K线周期大于1分钟:  回测框架会隐式的订阅一个1分钟K线, 确保quote的更新周期不会超过1分钟 else:  回测框架会隐式的订阅一个1分钟K线, 确保quote的更新周期不会超过1分钟 规则4: 策略程序中的多个序列的更新, 按时间顺序合并推进. 每次 wait_update 时, 优先处理用户事件, 当没有用户事件时, 从各序列中选择下一次更新时间最近的, 更新到这个时间:: ka = api.get_kline_serial(""SHFE.cu1901"", 10)    # 请求一个10秒线 kb = api.get_kline_serial(""SHFE.cu1902"", 15)    # 请求一个15秒线 print(ka.iloc[-1].datetime, kb.iloc[-1].datetime) # 2018/01/01 09:00:00, 2018/01/01 09:00:00 api.wait_update()           # 推进一步, ka先更新了, 时间推到 09:00:10 print(ka.iloc[-1].datetime, kb.iloc[-1].datetime) # 2018/01/01 09:00:10, 2018/01/01 09:00:00 api.wait_update()           # 再推一步, 这次时间推到 09:00:15, kb更新了 print(ka.iloc[-1].datetime, kb.iloc[-1].datetime) # 2018/01/01 09:00:10, 2018/01/01 09:00:15 api.wait_update()           # 再推一步, 这次时间推到 09:00:20, ka更新了 print(ka.iloc[-1].datetime, kb.iloc[-1].datetime) # 2018/01/01 09:00:20, 2018/01/01 09:00:15 api.wait_update()           # 再推一步, 时间推到 09:00:30, ka, kb都更新了 print(ka.iloc[-1].datetime, kb.iloc[-1].datetime) # 2018/01/01 09:00:30, 2018/01/01 09:00:30 **注意** ：如果未订阅 quote，模拟交易在下单时会自动为此合约订阅 quote ，根据回测时 quote 的更新规则，如果此合约没有订阅K线或K线周期大于分钟线 **则会自动订阅一个分钟线** 。 另外，对 **组合合约** 进行回测时需注意：只能通过订阅 tick 数据来回测，不能订阅K线，因为K线是由最新价合成的，而交易所发回的组合合约数据中无最新价。 了解更多 ------------------------------------------------- * 如果你要做大量回测, 或者试图做参数优化/参数搜索, 请看 :ref:`batch_backtest` * 如果你在回测时需要图形化界面支持，我们提供 TqSdk 内置强大的图形化界面解决方案 :ref:`web_gui` "
63,n\doc\usage\framework,"n\doc\usage\framework. .. _framework: 策略程序结构 ==================================================== TqApi ---------------------------------------------------- :py:class:`tqsdk.TqApi` 是 TqSdk 的核心类. 通常情况下, 每个使用了 TqSdk 的程序都应该包括 **一个** TqApi 实例::  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) TqApi 实例负责: * 建立websocket连接到服务器. * 在内存中建立数据存储区, 接收行情和交易业务数据包, 并自动维护数据更新. * 发出交易指令. * 管理协程任务. * 执行策略回测. TqApi 创建时, 需要提供一个account参数. 它可以是: * 一个 :py:class:`tqsdk.TqAccount` 实例: 使用实盘帐号, 直连行情和交易服务器, 需提供期货公司/帐号/密码 * 一个 :py:class:`tqsdk.TqSim` 实例: 使用 Api 自带的模拟功能, 直连行情服务器接收行情数据 * 如果未提供 account 参数, 或者 account == None, 则会自动创建并使用一个 :py:class:`tqsdk.TqSim` 实例 此外还需要传入用户的信易账户，参见 :ref:`shinny_account` TqApi 的其它构建参数请见 :py:class:`tqsdk.TqApi` 关键函数: wait_update ---------------------------------------------------- :py:meth:`~tqsdk.TqApi.wait_update` 是 TqApi 中最重要的一个函数. 每次调用 :py:meth:`~tqsdk.TqApi.wait_update` 函数时将发生这些事: * 实际发出网络数据包. 例如, 策略程序用 insert_order 函数下单, 实际的报单指令是在 insert_order 后调用 :py:meth:`~tqsdk.TqApi.wait_update` 时发出的 * 让正在运行中的后台任务获得动作机会．例如, 策略程序中创建了一个后台调仓任务, 这个任务只会在 :py:meth:`~tqsdk.TqApi.wait_update` 时发出交易指令 * 尝试从服务器接收一个数据包, 并用收到的数据包更新内存中的业务数据截面. * 如果没有收到数据包，则挂起等待，如果要避免长时间挂起，可通过设置 :py:meth:`~tqsdk.TqApi.wait_update` 中的deadline参数，设置等待截止时间 .. figure:: ../images/wait_update.png 因此, TqSdk 要求策略程序必须反复调用 :py:meth:`~tqsdk.TqApi.wait_update`, 才能保证整个程序正常运行. 一般会将 :py:meth:`~tqsdk.TqApi.wait_update` 放在一个循环中反复调用 （注: 若跳出循环，程序结束前需调用 api.close() 释放资源)::  while True:    #一个循环   api.wait_update() #总是调用 wait_update, 当数据有更新时 wait_update 函数返回, 执行下一句   do_some_thing()  #每当数据有变更时, 执行自己的代码, 然后循环回去再做下一次 wait_update  #注：若跳出循环并运行到程序末尾，在结束运行前需调用 api.close() 函数以关闭天勤接口实例并释放相应资源，请见下文 “一个典型程序的结构” 内存数据及数据更新 ---------------------------------------------------- TqApi 实例内存中保存了一份完整业务数据截面, 包括行情/K线和交易账户数据. 这些数据可以通过 :py:class:`~tqsdk.TqApi` 提供的数据引用函数获取，以获取资金账户为例::  account = api.get_account() # 获取账户信息引用  print(account.balance) # 显示账户信息 值得注意的是, get_account 返回资金账户的一个动态引用, 而不是具体的数值. 因此只需调用一次 get_account 得到 account 引用，之后任何时刻都可以使用 account.balance 获得最新的账户权益. 当 :py:meth:`~tqsdk.TqApi.wait_update` 函数返回时业务截面即完成了从上一个时间截面推进到下一个时间截面。 :py:meth:`~tqsdk.TqApi.wait_update` 会在任何数据更新时返回. 如果想知道 :py:meth:`~tqsdk.TqApi.wait_update` 到底更新了哪些业务数据可以调用 :py:meth:`~tqsdk.TqApi.is_changing` 函数判断感兴趣的业务对象是否有更新，例如::  if api.is_changing(account):   print(""账户变化"")     #任何资金账户中任意信息变化的时候打出 ""账户变化""  if api.is_changing(account, ""balance""):   print(""账户权益变化"")     #只有资金账户中的权益值变化的时候打出 ""账户权益变化"" **建议跨交易日重启代码** ,否则可能导致:  1. 合约信息不能及时更新（如：有新上市的合约,保持登录的第二个交易日就没有这个合约信息)  2. 前一交易日的未成交委托单没有删除\更新  3. 如果使用了交易辅助工具 TargetPosTask 并且收盘后有挂单，导致 TargetPosTask 在下一交易日无法继续执行  4. 其他未知问题. 一个典型程序的结构 ---------------------------------------------------- 以一个通常的策略流程为例：判断开仓条件，开仓，判断平仓条件，平仓，使用 TqSdk 写出的代码::  from tqsdk import TqApi, TqAuth, TqSim, TargetPosTask  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))  klines = api.get_kline_serial(""SHFE.rb1901"", 60)  position = api.get_position(""SHFE.rb1901"")  target_pos = TargetPosTask(api, ""SHFE.rb1901"")  while True:             #判断开仓条件的主循环   api.wait_update()          #等待业务数据更新   if 开仓条件:    target_pos.set_target_volume(1)      #如果触发了，则通过 target_pos 将 SHFE.rb1901 的目标持仓设置为多头 1 手，具体的调仓工作则由 target_pos 在后台完成    break            #跳出开仓循环，进入下面的平仓循环  while True:             #判断平仓条件的主循环   api.wait_update()   if 平仓条件:    target_pos.set_target_volume(0)      #如果触发了，则通过 target_pos 将 SHFE.rb1901 的目标持仓设置为0手(即空仓)   if position.pos == 0:         #如果已经将仓位平掉则跳出循环    break  api.close()             #注意：程序结束运行前需调用此函数以关闭天勤接口实例并释放相应资源，同时此函数会包含发送最后一次wait_update信息传输  #至此就完成一次完整的开平仓流程，如果平仓后还需再判断开仓条件可以把开仓循环和平仓循环再套到一个大循环中。 "
64,n\doc\usage\index,n\doc\usage\index. .. _usage: 使用TqSdk ======================================== .. toctree::  :maxdepth: 2  framework.rst  shinny_account.rst  mddatas.rst  ta.rst  trade.rst  option_trade.rst  targetpostask.rst  backtest.rst  web_gui.rst 
65,n\doc\usage\mddatas,"n\doc\usage\mddatas. .. _mddatas: 合约, 行情和历史数据 ==================================================== 合约代码 ---------------------------------------------------- TqSdk中的合约代码, 统一采用 交易所代码.交易所内品种代码 的格式. 交易所代码为全大写字母, 交易所内品种代码的大小写规范, 遵从交易所规定, 大小写敏感. 其中 TqSdk 免费版本提供全部的期货、商品/金融期权和上证50、沪深300、中证500和中证1000的实时行情 购买或申请 TqSdk 专业版试用后可提供A股股票的实时和历史行情，具体免费版和专业版的区别，请点击 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_ 目前 TqSdk 支持的交易所包括: ================== ==================================================================== CODE    NAME ================== ==================================================================== SHFE    上海期货交易所 DCE    大连商品交易所 CZCE    郑州商品交易所 CFFEX    中国金融交易所 INE    上海能源中心(原油在这里) KQ     快期 (所有主连合约, 指数都归属在这里) SSWE    上期所仓单 SSE    上海证券交易所 SZSE    深圳证券交易所 ================== ==================================================================== 一些合约代码示例:: 	SHFE.cu1901 - 上期所 cu1901 期货合约 	DCE.m1901 - 大商所 m1901 期货合约 	CZCE.SR901 - 郑商所 SR901 期货合约 	CFFEX.IF1901 - 中金所 IF1901 期货合约 	INE.sc2109 - 上期能源 sc2109 期货合约 	CZCE.SPD SR901&SR903 - 郑商所 SR901&SR903 跨期合约 	DCE.SP a1709&a1801 - 大商所 a1709&a1801 跨期合约 	DCE.m1807-C-2450 - 大商所豆粕期权 	CZCE.CF003C11000 - 郑商所棉花期权 	SHFE.au2004C308 - 上期所黄金期权 	CFFEX.IO2002-C-3550 - 中金所沪深300股指期权 	INE.sc2109C450 - 上期能源原油期权 	KQ.m@CFFEX.IF - 中金所IF品种主连合约 	KQ.i@SHFE.bu - 上期所bu品种指数 	SSWE.CUH - 上期所仓单铜现货数据 	SSE.600000 - 上交所浦发银行股票编码 	SZSE.000001 - 深交所平安银行股票编码 	SSE.000016 - 上证50指数 	SSE.000300 - 沪深300指数 	SSE.000905 - 中证500指数 	SSE.000852 - 中证1000指数 	SSE.510050 - 上交所上证50ETF 	SSE.510300 - 上交所沪深300ETF 	SZSE.159919 - 深交所沪深300ETF 	SSE.10002513 - 上交所上证50ETF期权 	SSE.10002504 - 上交所沪深300ETF期权 	SZSE.90000097 - 深交所沪深300ETF期权 	SZSE.159915 - 易方达创业板ETF 	SZSE.90001277 - 创业板ETF期权 	SZSE.159922 - 深交所中证500ETF 	SZSE.90001355 - 深交所中证500ETF期权 	SSE.510500 - 上交所中证500ETF 	SSE.10004497 - 上交所中证500ETF期权 **注意：并非所有合约都是可交易合约.** 需要注意郑商所的期货合约格式为合约字母大写，并且只有三位数字位，同时不同家交易所的期权代码格式也各不相同 天勤指数的计算方式为根据在市期货合约的昨持仓量加权平均 天勤主力的选定标准为该合约持仓量和成交量均为最大后，在下一个交易日开盘后进行切换，且切换后不会再切换到之前的合约 .. image: ... 实时行情 ---------------------------------------------------- :py:meth:`~tqsdk.TqApi.get_quote` 函数提供实时行情和合约信息::  q = api.get_quote(""SHFE.cu2201"") 返回值为一个dict, 结构如下::  {   ""datetime"": ""2021-08-17 14:59:59.000001"", # 行情从交易所发出的时间(北京时间)   ""ask_price1"": 69750.0, # 卖一价   ""ask_volume1"": 1, # 卖一量   ""bid_price1"": 69600.0, # 买一价   ""bid_volume1"": 2, # 买一量   ""ask_price2"": 69920.0, # 卖二价   ""ask_volume2"": 3, # 卖二量   ""bid_price2"": 69500.0, # 买二价   ""bid_volume2"": 3, # 买二量   ""ask_price3"": 69940.0, # 卖三价   ""ask_volume3"": 1, # 卖三量   ""bid_price3"": 69450.0, # 买三价   ""bid_volume3"": 1, # 买三量   ""ask_price4"": 70010.0, # 卖四价   ""ask_volume4"": 1, # 卖四量   ""bid_price4"": 69400.0, # 买四价   ""bid_volume4"": 1, # 买四量   ""ask_price5"": 70050.0, # 卖五价   ""ask_volume5"": 1, # 卖五量   ""bid_price5"": 69380.0, # 买五价   ""bid_volume5"": 1, # 买五量   ""last_price"": 69710.0, # 最新价   ""highest"": 70050.0, # 当日最高价   ""lowest"": 69520.0, # 当日最低价   ""open"": 69770.0, # 开盘价   ""close"": 69710.0, # 收盘价   ""average"": 69785.019711, # 当日均价   ""volume"": 761, # 成交量   ""amount"": 265532000.0, # 成交额   ""open_interest"": 8850, # 持仓量   ""settlement"": 69780.0, # 结算价   ""upper_limit"": 75880.0, # 涨停价   ""lower_limit"": 64630.0, # 跌停价   ""pre_open_interest"": 8791, # 昨持仓量   ""pre_settlement"": 70260.0, # 昨结算价   ""pre_close"": 69680.0, # 昨收盘价   ""price_tick"": 10.0, # 合约价格变动单位   ""price_decs"": 0, # 合约价格小数位数   ""volume_multiple"": 5.0, # 合约乘数   ""max_limit_order_volume"": 500, # 最大限价单手数   ""max_market_order_volume"": 0, # 最大市价单手数   ""min_limit_order_volume"": 0, # 最小限价单手数   ""min_market_order_volume"": 0, # 最小市价单手数   ""underlying_symbol"": """", # 标的合约   ""strike_price"": NaN, # 行权价   ""ins_class"": ""FUTURE"", # 合约类型   ""instrument_id"": ""SHFE.cu2201"", # 合约代码   ""instrument_name"": ""沪铜2201"", # 合约中文名   ""exchange_id"": ""SHFE"", # 交易所代码   ""expired"": false, # 合约是否已下市   ""trading_time"": ""{'day': [['09:00:00', '10:15:00'], ['10:30:00', '11:30:00'], ['13:30:00', '15:00:00']], 'night': [['21:00:00', '25:00:00']]}"", # 交易时间段   ""expire_datetime"": 1642402800.0, # 到期具体日，以秒为单位的 timestamp 值   ""delivery_year"": 2022, # 期货交割日年份，只对期货品种有效。期权推荐使用最后行权日年份   ""delivery_month"": 1, # 期货交割日月份，只对期货品种有效。期权推荐使用最后行权日月份   ""last_exercise_datetime"": NaN, # 期权最后行权日，以秒为单位的 timestamp 值   ""exercise_year"": 0, # 期权最后行权日年份，只对期权品种有效。   ""exercise_month"": 0, # 期权最后行权日月份，只对期权品种有效。   ""option_class"": """", # 期权行权方式，看涨:'CALL'，看跌:'PUT'   ""exercise_type"": """", # 期权行权方式，美式:'A'，欧式:'E'   ""product_id"": ""cu"", # 品种代码   ""iopv"": NaN, # ETF实时单位基金净值   ""public_float_share_quantity"": 0, # 日流通股数，只对证券产品有效。   ""stock_dividend_ratio"": [], # 除权表 [""20190601,0.15"",""20200107,0.2""…]   ""cash_dividend_ratio"": [], # 除息表 [""20190601,0.15"",""20200107,0.2""…]   ""expire_rest_days"": 153, # 距离到期日的剩余天数（自然日天数），正数表示距离到期日的剩余天数，0表示到期日当天，负数表示距离到期日已经过去的天数   ""commission"": 17.565,   ""margin"": 31617.0  } 对于每个合约, 只需要调用一次 get_quote 函数. 如果需要监控数据更新, 可以使用 :py:meth:`~tqsdk.TqApi.wait_update`::  q = api.get_quote(""SHFE.cu1812"") # 获取SHFE.cu1812合约的行情  while api.wait_update():  print(q.last_price) # 收到新行情时都会执行这行 K线数据 ---------------------------------------------------- :py:meth:`~tqsdk.TqApi.get_kline_serial` 函数获取指定合约和周期的K线序列数据::  klines = api.get_kline_serial(""SHFE.cu1812"", 10) # 获取SHFE.cu1812合约的10秒K线 获取按照时间对齐的多合约K线::  klines = api.get_kline_serial([""SHFE.au1912"", ""SHFE.au2006""], 5) # 获取SHFE.au2006向SHFE.au1912对齐的K线 详细使用方法及说明请见 :py:meth:`~tqsdk.TqApi.get_kline_serial` 函数使用说明。 :py:meth:`~tqsdk.TqApi.get_kline_serial` 的返回值是一个 pandas.DataFrame, 包含以下列::  id: 1234 (k线序列号)  datetime: 1501080715000000000 (K线起点时间(按北京时间)，自unix epoch(1970-01-01 00:00:00 GMT)以来的纳秒数)  open: 51450.0 (K线起始时刻的最新价)  high: 51450.0 (K线时间范围内的最高价)  low: 51450.0 (K线时间范围内的最低价)  close: 51450.0 (K线结束时刻的最新价)  volume: 11 (K线时间范围内的成交量)  open_oi: 27354 (K线起始时刻的持仓量)  close_oi: 27355 (K线结束时刻的持仓量) 要使用K线数据, 请使用 pandas.DataFrame 的相关函数. 常见用法示例如下::  klines.iloc[-1].close # 最后一根K线的收盘价  klines.close   # 收盘价序列, 一个 pandas.Serial TqSdk中, K线周期以秒数表示，支持不超过1日的任意周期K线，例如::  api.get_kline_serial(""SHFE.cu1901"", 70) # 70秒线  api.get_kline_serial(""SHFE.cu1901"", 86400) # 86400秒线, 即日线  api.get_kline_serial(""SHFE.cu1901"", 86500) # 86500秒线, 超过1日，无效 TqSdk中最多可以获取每个K线序列的最后8000根K线，无论哪个周期。也就是说，你如果提取小时线，最多可以提取最后8000根小时线，如果提取分钟线，最多也是可以提取最后8000根分钟线。 对于每个K线序列, 只需要调用一次 :py:meth:`~tqsdk.TqApi.get_kline_serial` . 如果需要监控数据更新, 可以使用 :py:meth:`~tqsdk.TqApi.wait_update` ::  klines = api.get_kline_serial(""SHFE.cu1812"", 10) # 获取SHFE.cu1812合约的10秒K线  while api.wait_update():   print(klines.iloc[-1]) # K线数据有任何变动时都会执行这行 如果只想在新K线出现时收到信号, 可以配合使用 :py:meth:`~tqsdk.TqApi.is_changing`::  klines = api.get_kline_serial(""SHFE.cu1812"", 10)  # 获取SHFE.cu1812合约的10秒K线  while api.wait_update():   if api.is_changing(klines.iloc[-1], ""datetime""): # 判定最后一根K线的时间是否有变化    print(klines.iloc[-1])       # 当最后一根K线的时间有变(新K线生成)时才会执行到这里 Tick序列 ---------------------------------------------------- :py:meth:`~tqsdk.TqApi.get_tick_serial` 函数获取指定合约的Tick序列数据::  ticks = api.get_tick_serial(""SHFE.cu1812"") # 获取SHFE.cu1812合约的Tick序列 :py:meth:`~tqsdk.TqApi.get_tick_serial` 的返回值是一个 pandas.DataFrame, 常见用法示例如下::  ticks.iloc[-1].bid_price1  # 最后一个Tick的买一价  ticks.volume     # 成交量序列, 一个 pandas.Serial tick序列的更新监控, 与K线序列采用同样的方式. 关于合约及行情的一些常见问题 ---------------------------------------------------- **怎样同时监控多个合约的行情变化** TqSdk可以订阅任意多个行情和K线, 并在一个wait_update中等待更新. 像这样::  q1 = api.get_quote(""SHFE.cu1901"")  q2 = api.get_quote(""SHFE.cu1902"")  k1 = api.get_kline_serial(""SHFE.cu1901"", 60)  k2 = api.get_kline_serial(""SHFE.cu1902"", 60)  while api.wait_update():  print(""收到数据了"")  # 上面4项中的任意一项有变化, 都会到这一句. 具体是哪个或哪几个变了, 用 is_changing 判断  if api.is_changing(q1):   print(q1)    # 如果q1变了, 就会执行这句  if api.is_changing(q2):   print(q2)  if api.is_changing(k1):   print(k1)  if api.is_changing(k2):   print(k2) 关于 :py:meth:`~tqsdk.TqApi.wait_update` 和 :py:meth:`~tqsdk.TqApi.is_changing` 的详细说明, 请见 :ref:`framework` "
66,n\doc\usage\option trade,"n\doc\usage\option trade. .. _option_trade: 期权交易 & 交易所官方组合 ==================================================== TqSdk 中期权交易(商品期权、金融期权和 ETF 期权)和交易所官方组合交易，均是 TqSdk 专业版中的功能 用户如果想在 TqSdk 中进行上述操作，可以点击 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_ 申请使用或购买 TqSdk 中期权合和交易所官方组合的约代码格式参考如下:: 	DCE.m1807-C-2450 - 大商所豆粕期权 	CZCE.CF003C11000 - 郑商所棉花期权 	SHFE.au2004C308 - 上期所黄金期权 	CFFEX.IO2002-C-3550 - 中金所沪深300股指期权 	SSE.10002513 - 上交所上证50etf期权 	SSE.10002504 - 上交所沪深300etf期权 	SZSE.90000097 - 深交所沪深300etf期权 	CZCE.SPD SR901&SR903 - 郑商所 SR901&SR903 跨期合约 	DCE.SP a1709&a1801 - 大商所 a1709&a1801 跨期合约 对于交易所官方组合，目前 TqSdk 中只支持交易所官方组合进行实盘交易 期权指标计算&序列计算函数 ---------------------------------------------------- TqSdk 内提供了丰富的期权指标计算&序列计算函数，参考如下： * :py:meth:`~tqsdk.ta.OPTION_GREEKS` - 计算期权希腊指标 * :py:meth:`~tqsdk.ta.OPTION_IMPV` - 计算期权隐含波动率 * :py:meth:`~tqsdk.ta.BS_VALUE` - 计算期权 BS 模型理论价格 * :py:meth:`~tqsdk.ta.OPTION_VALUE` - 计算期权内在价值，期权时间价值 * :py:meth:`~tqsdk.tafunc.get_bs_price` - 计算期权 BS 模型理论价格 * :py:meth:`~tqsdk.tafunc.get_delta` - 计算期权希腊指标 delta 值 * :py:meth:`~tqsdk.tafunc.get_gamma` - 计算期权希腊指标 gamma 值 * :py:meth:`~tqsdk.tafunc.get_rho` - 计算期权希腊指标 rho 值 * :py:meth:`~tqsdk.tafunc.get_theta` - 计算期权希腊指标 theta 值 * :py:meth:`~tqsdk.tafunc.get_vega` - 计算期权希腊指标 vega 值 * :py:meth:`~tqsdk.tafunc.get_his_volatility` - 计算某个合约的历史波动率 * :py:meth:`~tqsdk.tafunc.get_t` - 计算 K 线序列对应的年化到期时间，主要用于计算期权相关希腊指标时，需要得到计算出序列对应的年化到期时间 期权查询函数 ---------------------------------------------------- TqSdk 内提供了完善的期权查询函数 :py:meth:`~tqsdk.TqApi.query_options` 和对应平值虚值期权查询函数 :py:meth:`~tqsdk.TqApi.query_atm_options` ，供用户搜索符合自己需求的期权::  from tqsdk import TqApi, TqAuth  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))  ls = api.query_options(""SHFE.au2012"")  print(ls) # 标的为 ""SHFE.au2012"" 的所有期权  ls = api.query_options(""SHFE.au2012"", option_class=""PUT"")  print(ls) # 标的为 ""SHFE.au2012"" 的看跌期权  ls = api.query_options(""SHFE.au2012"", option_class=""PUT"", expired=False)  print(ls) # 标的为 ""SHFE.au2012"" 的看跌期权, 未下市的  ls = api.query_options(""SHFE.au2012"", strike_price=340)  print(ls) # 标的为 ""SHFE.au2012"" 、行权价为 340 的期权  ls = api.query_options(""SSE.510300"", exchange_id=""CFFEX"")  print(ls) # 中金所沪深300股指期权  ls = api.query_options(""SSE.510300"", exchange_id=""SSE"")  print(ls) # 上交所沪深300etf期权  ls = api.query_options(""SSE.510300"", exchange_id=""SSE"", exercise_year=2020, exercise_month=12)  print(ls) # 上交所沪深300etf期权, 限制条件 2020 年 12 月份行权  "
67,n\doc\usage\replay,"n\doc\usage\replay. .. _replay: 策略程序复盘 ================================================= 执行策略复盘 ------------------------------------------------- 除了传统的回测模式以外，TqSdk 提供独具特色的复盘模式，它与回测模式有以下区别 1.复盘模式为时间驱动，回测模式为事件驱动 复盘模式下，你可以指定任意一天交易日，后端行情服务器会传输用户订阅合约的当天的所有历史行情数据，重演当天行情，而在回测模式下，我们采用 :ref:`backtest_rule` ,根据用户订阅的合约周期数据来进行推送 因此在复盘模式下K线更新和实盘一模一样，而回测模式下就算订阅了 Tick 数据，回测中任意周期 K 线最后一根的 close 和其他数据也不会随着 Tick 更新而更新，而是随着K线频率生成和结束时更新一次 2.复盘和回测的行情速度 因为两者的驱动机制不同，回测会更快，但是我们在复盘模式下也提供行情速度调节功能，可以结合 :ref:`web_gui_replay` 来实现 3.复盘目前只支持单日复盘 因为复盘提供对应合约全部的当日历史行情数据，对后端服务器会有较大压力，目前只支持复盘模式下选择单日进行复盘 使用 TqSdk 编写的策略程序，不需要修改策略代码，只需要在创建 api 实例时给 backtest 参数传入 :py:class:`~tqsdk.backtest.TqReplay` 指定复盘日期, 策略就会进入复盘模式:: from datetime import date from tqsdk import TqApi, TqReplay api = TqApi(backtest = TqReplay(date(2019,12,23)), auth=TqAuth(""信易账户"", ""账户密码"")) 此外我们认为复盘模式结合图形化界面会有更好的体验，可以参考 :ref:`web_gui` 同时在图形化界面下，你可以通过点击复盘速度控制按钮对复盘行情速度进行控制 .. figure:: ../images/replay.png **使用复盘模式时需要注意：** 1.指定复盘日期需要有行情，否则提示无法创建复盘服务器 2.订阅合约在复盘日期时已经上市或还未下市 "
68,n\doc\usage\shinny account,"n\doc\usage\shinny account. .. _shinny_account: 信易账户 ================================================= 在使用 TqSdk 之前，用户需要先注册自己的 **信易账户** ，传入信易账户是使用任何 TqSdk 程序的前提 如需注册，请点击 `注册信易账户 <https://account.shinnytech.com/>`_ ::  from tqsdk import TqApi, TqAuth  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) 用信易账户来模拟交易 ------------------------------------------------- 注册完成的信易账户的【手机号】/【邮箱地址】/【用户名】和【密码】可以作为 快期模拟 账号，通过 :py:class:`~tqsdk.api.TqKq` 对 auth 传入参数进行登录，这个 快期模拟 账户在快期APP、快期专业版 和天勤量化上是互通的::  from tqsdk import TqApi, TqAuth, TqKq  api = TqApi(TqKq(), auth=TqAuth(""信易账户"", ""账户密码"")) 用信易账户来实盘交易 ------------------------------------------------- 对于 TqSdk 免费版，每个信易账户支持最多绑定一个实盘账户，而天勤量化专业版支持一个信易账户绑定任意多个实盘账户 信易账户会在用户使用实盘账户时自动进行绑定，直到该信易账户没有能绑定实盘账户的名额(自动绑定功能需要 TqSdk 版本> 1.8.3)::  from tqsdk import TqApi, TqAccount, TqAuth, TqKq  api = TqApi(TqAccount(""H海通期货"", ""320102"", ""123456""), auth=TqAuth(""信易账户"", ""账户密码"")) 如果需要注册信易账户或者修改您的信易账户绑定的实盘账户请参见 :ref:`user_center` .. _user_center: 登录用户管理中心 ------------------------------------------------- 点击 `登录用户管理中心 <https://www.shinnytech.com/register-intro/>`_ ，可以注册信易账户或者修改您的信易账户绑定的实盘账户 登录成功后显示如下，在下方红框处,用户可以自行解绑/绑定实盘账户，其中解绑操作每天限定一次 .. figure:: ../images/user_web_management.png 如需一个信易账户支持更多的实盘账户，请联系工作人员进行批量购买 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_  "
69,n\doc\usage\ta,"n\doc\usage\ta. .. _ta: 技术指标与序列计算函数 ==================================================== 技术指标 ---------------------------------------------------- tqsdk.ta 模块中包含了大量技术指标. 每个技术指标是一个函数, 函数名为全大写, 第一参数总是K线序列, 以pandas.DataFrame格式返回计算结果. 以MACD为例::  from tqsdk.ta import MACD  klines = api.get_kline_serial(""SHFE.cu1812"", 60) # 提取SHFE.cu1812的分钟线  result = MACD(klines, 12, 26, 9)      # 计算MACD指标  print(result[""diff""])         # MACD指标中的diff序列 tqsdk.ta 中目前提供的技术指标详表，请见 :ref:`tqsdk.ta` 序列计算函数 ---------------------------------------------------- tqsdk.tafunc 模块中包含了一批序列计算函数. 它们是构成技术指标的基础. 在某些情况下, 您也可以直接使用这些序列计算函数以获取更大的灵活性. 例如, 技术指标MA(均线)总是按K线的收盘价来计算, 如果你需要计算最高价的均线, 可以使用ma函数::  from tqsdk.tafunc import ma  klines = api.get_kline_serial(""SHFE.cu1812"", 60) # 提取SHFE.cu1812的分钟线  result = ma(klines.high, 9)      # 按K线的最高价序列做9分钟的移动平均  print(result)          # 移动平均结果 tqsdk.tafunc 中目前提供的序列计算函数详表，请见 :ref:`tqsdk.tafunc` "
70,n\doc\usage\targetpostask,"n\doc\usage\targetpostask. .. _targetpostask: 交易辅助工具 ==================================================== :py:class:`~tqsdk.TargetPosTask` 是按照目标持仓手数自动调整 账户持仓中某合约的净持仓 的工具, 使用示例如下::  target_pos = TargetPosTask(api, ""SHFE.rb1901"")  #创建一个自动调仓工具, 负责调整SHFE.rb1901的持仓  target_pos.set_target_volume(5)      #要求自动调仓工具将持仓调整到5手  do_something_else()         #现在你可以做别的事了, 自动调仓工具将会在后台自动下单/撤单/跟单, 直到持仓手数达到5手为止 下面是一个更实际的价差交易例子::  from tqsdk import TqApi, TqAuth, TargetPosTask  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))  # 创建 rb1810 的目标持仓 task，该 task 负责调整 rb1810 的仓位到指定的目标仓位  target_pos_near = TargetPosTask(api, ""SHFE.rb1810"")  # 创建 rb1901 的目标持仓 task，该 task 负责调整 rb1901 的仓位到指定的目标仓位  target_pos_deferred = TargetPosTask(api, ""SHFE.rb1901"")  while True:   api.wait_update()   if api.is_changing(quote_near) or api.is_changing(quote_deferred):    spread = quote_near.last_price - quote_deferred.last_price    print(""当前价差:"", spread)    if spread > 200:     print(""目标持仓: 空近月，多远月"")     # 设置目标持仓为正数表示多头，负数表示空头，0表示空仓     target_pos_near.set_target_volume(-1)     target_pos_deferred.set_target_volume(1)    elif spread < 150:     print(""目标持仓: 空仓"")     target_pos_near.set_target_volume(0)     target_pos_deferred.set_target_volume(0) **使用 TargetPosTask 时, 需注意以下要点：** * 1. TargetPosTask 在 set_target_volume 时并不下单或撤单, 它的下单和撤单动作, 是在之后的每次 wait_update 时执行的. 因此, **需保证 set_target_volume 后还会继续调用wait_update()** * 2. 为每个合约只创建一个 TargetPosTask 实例. 一旦创建好后, 可以调用任意多次 set_target_volume 函数, **它总是以最后一次 set_target_volume 设定的手数为工作目标。** 如::   from tqsdk import TqApi, TqAuth, TargetPosTask   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   target_pos = TargetPosTask(api, ""SHFE.rb2001"")   # 设定目标净持仓为空头1手   target_pos.set_target_volume(-1)   # 目标净持仓由空头1手改为多头1手   target_pos.set_target_volume(1)   while True:    # 需在 set_target_volume 后调用 wait_update() 以发出指令    # 当调整到目标净持仓后, 账户中此合约的净持仓为多头1手    api.wait_update() * 3. TargetPosTask 在工作时, 会负责下单和追单, 直至持仓手数达到目标为止. * 4. 在将净持仓调整到目标值后, 可能只持有其中一个方向的手数, 也可能同时有多/空头两个方向的持仓(原因有两个: 初始就持有多/空两个方向, 调整持仓时未平完某一方向; 或在调整目标持仓时禁止""平今""或""平昨"",然后以开仓操作来调整净持仓).  以当前持仓为 多头方向 且目标净持仓为0 为例, 对净持仓的调整逻辑为:   * 如果 offset_priority 为默认值""今昨,开"", 则: 先平多头今仓, (若平完今仓后未达到目标手数)再平多头昨仓, (若平完昨仓后未达到目标手数)再在空头方向开仓.   * 如果 offset_priority 为""今开""(即禁止平昨仓), 则: 先平多头今仓, (若平完今仓后未达到目标手数)再在空头方向开仓. (禁止平今仓的""昨开""与此类似)   * 如果 offset_priority 为""开""(即禁止平仓), 则: 直接在空头方向开仓以达到目标净持仓.  **注意:**  对于上期所和上海能源交易中心合约, 平仓时则直接根据今/昨的手数进行下单. 对于非上期所和能源交易中心: ""今仓""和""昨仓"" 是服务器按照今/昨仓的定义(本交易日开始时的持仓手数为昨仓, 之后下单的都为今仓)来计算的, 在平仓时, 则根据计算的今昨仓手数进行下单.  如持有大商所某合约并且 offset_priority 为""今开"", 而本交易日未下单(在今昨仓的概念上这是""昨仓"", 则不进行平仓, 直接用开仓操作来调整净持仓以达到目标. * 5. 如需要取消当前 TargetPosTask 任务，请参考 :ref:`targetpostask2` 。 * 6. 请勿在使用 TargetPosTask 的同时使用 insert_order() 函数, 否则将导致 TargetPosTask 报错或错误下单。 :py:class:`~tqsdk.InsertOrderUntilAllTradedTask` 是追价下单task, 该task会在行情变化后自动撤单重下，直到全部成交. "
71,n\doc\usage\trade,"n\doc\usage\trade. .. _trade: 账户与交易 ==================================================== 信易账户和实盘账户 ---------------------------------------------------- 在使用 TqSdk 之前，用户需要先注册自己的 **信易账户** ，传入信易账户是使用任何 TqSdk 程序的前提 点击 `注册信易账户 <https://account.shinnytech.com/>`_ ::  from tqsdk import TqApi, TqAuth  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) 对于 TqSdk 免费版，每个信易账户支持最多绑定一个实盘账户，并且信易账户会在用户第一次使用实盘账户时自动进行绑定(自动绑定功能需要 TqSdk 版本> 1.8.3)::  from tqsdk import TqApi, TqAuth  api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) 如果需要注册信易账户或者修改您的信易账户绑定的实盘账户，请点击 `登录用户管理中心 <https://www.shinnytech.com/register-intro/>`_ ，登录成功后显示如下 在下方红框处,用户可以自行解绑/绑定实盘账户，其中解绑操作每天限定一次 .. figure:: ../images/user_web_management.png 如果需要让您的信易账户支持更多的实盘账户，可以购买或申请试用我们的 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_ 设定实盘交易账户 ---------------------------------------------------- TqSdk 要求在创建 TqApi 时指定交易账户。一旦TqApi创建成功，后续所有通过TqApi发出的交易指令均在此账户中进行. 要使用实盘交易账户, 请使用 :py:class:`~tqsdk.TqAccount` (注：使用前请先 import TqAccount)::  from tqsdk import TqAccount, TqApi, TqAuth  api = TqApi(TqAccount(""H海通期货"", ""320102"", ""123456""), auth=TqAuth(""信易账户"", ""账户密码"")) :py:class:`~tqsdk.TqAccount` 的三个参数分别为 <期货公司名>, <用户名> 和 <密码> (期货公司名前需加大写首字母). 目前TqSdk支持的期货公司列表请参见: `TqSdk支持的期货公司列表 <https://www.shinnytech.com/blog/tq-support-broker/>`_ TqApi 创建成功即代表相应账户已登录成功. 如果在60秒内无法完成登录, 会抛出超时异常, 用户代码可以此判定登录失败::  try:   api = TqApi(TqAccount(""H海通期货"", ""320102"", ""123456""), auth=TqAuth(""信易账户"", ""账户密码""))  except Exception as e:   print(""行情服务连不上, 或者期货公司服务器关了, 或者账号密码错了, 总之就是有问题"") 设定快期模拟交易账户 ---------------------------------------------------- 如果您需要使用快期模拟账户进行测试，只需在创建TqApi时传入一个 :py:class:`~tqsdk.TqKq` 的实例，同时需要传入信易账户 :ref:`sim_trading`。 此账户类型与快期 APP 、天勤官网论坛、快期专业版使用相同的模拟账户系统::  from tqsdk import TqApi, TqAuth, TqKq  api = TqApi(TqKq(), auth=TqAuth(""信易账户"", ""账户密码"")) 设定模拟交易账户 ---------------------------------------------------- 如果您需要使用模拟账户进行测试，只需在创建TqApi时传入一个 :py:class:`~tqsdk.TqSim` 的实例（不填写参数则默认为 TqSim() 模拟账号）::  api = TqApi(TqSim()，auth=TqAuth(""信易账户"", ""账户密码"")) 如果需要使用能保存账户资金及持仓信息的模拟账户，请使用 ""快期模拟"" 账号, 账户申请及使用方法请参考 :ref:`sim_trading` 部分内容。 获取账户情况 ---------------------------------------------------- TqApi 提供以下函数来获取交易账户相关信息: * :py:meth:`~tqsdk.TqApi.get_account` - 获取账户资金情况 * :py:meth:`~tqsdk.TqApi.get_position` - 获取持仓情况 * :py:meth:`~tqsdk.TqApi.get_order` - 获取委托单 以上函数返回的都是dict, 并会在 wait_update 时更新 交易指令 ---------------------------------------------------- 要在交易账户中发出一个委托单, 使用 :py:meth:`~tqsdk.TqApi.insert_order` 函数::  order = api.insert_order(symbol=""SHFE.rb1901"", direction=""BUY"", offset=""OPEN"", limit_price=4310, volume=2)  print(order) 这个函数调用后会立即返回一个指向此委托单的对象引用, 使用方法与dict一致, 内容如下::  {   ""order_id"": """", # ""123"" (委托单ID, 对于一个用户的所有委托单，这个ID都是不重复的)   ""exchange_order_id"": """", # ""1928341"" (交易所单号)   ""exchange_id"": """", # ""SHFE"" (交易所)   ""instrument_id"": """", # ""rb1901"" (交易所内的合约代码)   ""direction"": """", # ""BUY"" (下单方向, BUY=买, SELL=卖)   ""offset"": """", # ""OPEN"" (开平标志, OPEN=开仓, CLOSE=平仓, CLOSETODAY=平今)   ""volume_orign"": 0, # 10 (总报单手数)   ""volume_left"": 0, # 5 (未成交手数)   ""limit_price"": float(""nan""), # 4500.0 (委托价格, 仅当 price_type = LIMIT 时有效)   ""price_type"": """", # ""LIMIT"" (价格类型, ANY=市价, LIMIT=限价)   ""volume_condition"": """", # ""ANY"" (手数条件, ANY=任何数量, MIN=最小数量, ALL=全部数量)   ""time_condition"": """", # ""GFD"" (时间条件, IOC=立即完成，否则撤销, GFS=本节有效, GFD=当日有效, GTC=撤销前有效, GFA=集合竞价有效)   ""insert_date_time"": 0, # 1501074872000000000 (下单时间(按北京时间)，自unix epoch(1970-01-01 00:00:00 GMT)以来的纳秒数)   ""status"": """", # ""ALIVE"" (委托单状态, ALIVE=有效, FINISHED=已完)   ""last_msg"": """", # ""报单成功"" (委托单状态信息)  } 与其它所有数据一样, 委托单的信息也会在 api.wait_update() 时被自动更新::  order = api.insert_order(symbol=""SHFE.rb1901"", direction=""BUY"", offset=""OPEN"", limit_price=4310,volume=2)  while order.status != ""FINISHED"":   api.wait_update()   print(""委托单状态: %s, 未成交手数: %d 手"" % (order.status, order.volume_left)) 要撤销一个委托单, 使用 :py:meth:`~tqsdk.TqApi.cancel_order` 函数::  api.cancel_order(order) * **除 insert_order 和 cancel_order 外, TqSdk 提供了一些更强的交易辅助工具比如** :py:class:`~tqsdk.TargetPosTask`. **使用这些工具, 可以简化交易逻辑的编码工作.** .. _broker_list: TqSdk支持的期货公司列表 ----------------------------------------------------- 请点击查看: `TqSdk支持的期货公司列表 <https://www.shinnytech.com/blog/tq-support-broker/>`_ "
72,n\doc\usage\web gui,"n\doc\usage\web gui. .. _web_gui: 策略程序图形化界面 ==================================================== 要在 TqSdk 中实现图形化界面非常简单，在 :py:class:`~tqsdk.TqApi` 中传入参数 web_gui = True即可，一套方案满足实盘/回测需求 对于需要固定web_gui网址的同学，可以传入本机IP端口 web_gui = ""http://192.168.143.0:9876""（需填写本机IP端口） 来进行固定网址 实盘情况下的图形化界面 ---------------------------------------------------- 实盘下的示例代码::   # 引入TqSdk模块   from tqsdk import TqApi, TqAuth   # 创建api实例，设置web_gui=True生成图形化界面   api = TqApi(web_gui=True, auth=TqAuth(""信易账户"", ""账户密码""))   # 订阅 cu2002 合约的10秒线   klines = api.get_kline_serial(""SHFE.cu2002"", 10)   while True:    # 通过wait_update刷新数据    api.wait_update() 当你运行该程序后，预期会显示如下两条信息::   2019-12-13 10:45:26,468 - INFO - 您可以访问 http://127.0.0.1:62964 查看策略绘制出的 K 线图形。   2019-12-13 10:45:27,422 - INFO - 通知: 与 wss://openmd.shinnytech.com/t/md/front/mobile 的网络连接已建立 点击访问地址后，显示网址效果如下: .. figure:: ../images/web_gui_demo.png 回测情况下的图形化界面 ---------------------------------------------------- 回测情况下，设置完回测区间参数后传入web_gui=True，也可以用同样的方法来生成图形化地址::   from datetime import date   from tqsdk import TqApi, TqAuth, TqBacktest, TargetPosTask   # 在创建 api 实例时传入 TqBacktest 就会进入回测模式,设置web_gui=True开启图形化界面   api = TqApi(backtest=TqBacktest(start_dt=date(2018, 5, 2), end_dt=date(2018, 6, 2)),web_gui=True, auth=TqAuth(""信易账户"", ""账户密码""))   # 获得 m1901 5分钟K线的引用   klines = api.get_kline_serial(""DCE.m1901"", 5 * 60, data_length=15)   # 创建 m1901 的目标持仓 task，该 task 负责调整 m1901 的仓位到指定的目标仓位   target_pos = TargetPosTask(api, ""DCE.m1901"")   while True:    api.wait_update()    if api.is_changing(klines):     ma = sum(klines.close.iloc[-15:]) / 15     print(""最新价"", klines.close.iloc[-1], ""MA"", ma)     if klines.close.iloc[-1] > ma:      print(""最新价大于MA: 目标多头5手"")      # 设置目标持仓为多头5手      target_pos.set_target_volume(5)     elif klines.close.iloc[-1] < ma:      print(""最新价小于MA: 目标空仓"")      # 设置目标持仓为空仓      target_pos.set_target_volume(0) 点击访问地址后，显示网址效果如下: .. figure:: ../images/web_gui_klines.png 点击完整回测报告，显示更加详细的报告结果: .. figure:: ../images/web_gui_backtest_report.png 如何在 TqSdk 中进行回测可以参见 :ref:`backtest` .. _web_gui_replay: "
73,n\tqsdk\accoun,"n\tqsdk\accoun. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' import base64 import ctypes import logging import os import sys import uuid from typing import Optional from tqsdk.baseModule import TqModule class TqAccount(TqModule):  """"""天勤实盘类""""""  def __init__(self, broker_id: str, account_id: str, password: str, front_broker: Optional[str] = None,     front_url: Optional[str] = None, td_url: Optional[str] = None, account_type: str = ""FUTURE"") -> None:   """"""   创建天勤实盘实例   Args:    broker_id (str): 期货公司，支持的期货公司列表 https://www.shinnytech.com/blog/tq-support-broker/    account_id (str): 帐号    password (str): 密码    td_url(str): [可选]用于指定账户连接的交易服务器地址, eg: ""tcp://1.2.3.4:1234/""    account_type(str): [可选]用于指定账户类型     * FUTURE [默认]: 期货账户     * SPOT: 股票现货账户   """"""   if bool(front_broker) != bool(front_url):    raise Exception(""front_broker 和 front_url 参数需同时填写"")   if not isinstance(broker_id, str):    raise Exception(""broker_id 参数类型应该是 str"")   if not isinstance(account_id, str):    raise Exception(""account_id 参数类型应该是 str"")   if not isinstance(password, str):    raise Exception(""password 参数类型应该是 str"")   if account_type not in [""FUTURE"", ""SPOT""]:    raise Exception(""account_type 账户类型指定错误"")   self._broker_id = broker_id.strip()   self._account_type = account_type   self._account_id = account_id.strip()   self._sub_account_id = None   self._account_key = str(id(self))   self._password = password   self._front_broker = front_broker   self._front_url = front_url   self._td_url = td_url   self._app_id = ""SHINNY_TQ_1.0""   self._system_info = """"   self._order_id = 0 # 最新股票下单委托合同编号  def _get_system_info(self):   try:    l = ctypes.c_int(344)    buf = ctypes.create_string_buffer(l.value)    lib_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), ""ctpse"")    if sys.platform.startswith(""win"") or sys.platform.startswith(""linux""):     if sys.platform.startswith(""win""):      if ctypes.sizeof(ctypes.c_voidp) == 4:       selib = ctypes.cdll.LoadLibrary(os.path.join(lib_path, ""WinDataCollect32.dll""))       ret = getattr(selib, ""?CTP_GetSystemInfo@@YAHPADAAH@Z"")(buf, ctypes.byref(l))      else:       selib = ctypes.cdll.LoadLibrary(os.path.join(lib_path, ""WinDataCollect64.dll""))       ret = getattr(selib, ""?CTP_GetSystemInfo@@YAHPEADAEAH@Z"")(buf, ctypes.byref(l))     else:      selib = ctypes.cdll.LoadLibrary(os.path.join(lib_path, ""LinuxDataCollect64.so""))      ret = selib._Z17CTP_GetSystemInfoPcRi(buf, ctypes.byref(l))     if ret == 0:      return base64.b64encode(buf.raw[:l.value]).decode(""utf-8"")     else:      raise Exception(""错误码: %d"" % ret)    else:     logging.getLogger(""TqApi.TqAccount"").debug(""ctpse error"", error=""不支持该平台"")   except Exception as e:    self._api._print(f""采集穿透式监管客户端信息失败: {e}"", level=""ERROR"")    logging.getLogger(""TqApi.TqAccount"").error(""ctpse error"", error=e)   return """"  async def _run(self, api, api_send_chan, api_recv_chan, md_send_chan, md_recv_chan, td_send_chan, td_recv_chan):   self._api = api   req = {    ""aid"": ""req_login"",    ""bid"": self._broker_id,    ""user_name"": self._account_id,    ""password"": self._password,   }   mac = f""{uuid.getnode():012X}""   req[""client_mac_address""] = ""-"".join([mac[e:e + 2] for e in range(0, 11, 2)])   system_info = self._get_system_info()   if system_info:    req[""client_app_id""] = self._app_id    req[""client_system_info""] = system_info   if self._front_broker:    req[""broker_id""] = self._front_broker    req[""front""] = self._front_url   await td_send_chan.send(req)   if self._account_type == 'FUTURE':    await td_send_chan.send({     ""aid"": ""confirm_settlement""    }) # 自动发送确认结算单   self._api = api   self._api_send_chan = api_send_chan   self._api_recv_chan = api_recv_chan   self._md_send_chan = md_send_chan   self._md_recv_chan = md_recv_chan   self._td_send_chan = td_send_chan   self._td_recv_chan = td_recv_chan   await super(TqAccount, self)._run(api, api_send_chan, api_recv_chan, md_send_chan, md_recv_chan, td_send_chan,           td_recv_chan)  async def _handle_recv_data(self, pack, chan):   """"""   处理所有上游收到的数据包   """"""   if chan == self._md_recv_chan: # 从行情收到的数据包    if pack[""aid""] == ""rtn_data"":     self._diffs.extend(pack.get('data', []))    else:     await self._api_recv_chan.send(pack) # 有可能是另一个 account 的 rsp_login   elif chan == self._td_recv_chan: # 从交易收到的数据包    self._td_handler(pack)  async def _handle_req_data(self, pack):   if pack[""aid""] in [""insert_order"", ""cancel_order"", ""set_risk_management_rule""]:    assert ""account_key"" in pack, ""发给交易请求的包必须包含 account_key""    if pack[""account_key""] != self._account_key:     await self._md_send_chan.send(pack) # 若交易指令包不为当前账户实例，传递给下一个账户实例    else:     pack.pop(""account_key"", None)     await self._td_send_chan.send(pack)   else:    await self._md_send_chan.send(pack)  def _td_handler(self, pack):   # OTG 返回业务信息截面 trade 中 account_key 为 user_id, 该值需要替换为 account_key   for _, slice_item in enumerate(pack[""data""] if ""data"" in pack else []):    if ""trade"" not in slice_item:     continue    # 股票账户需要根据登录确认包确定客户号与资金账户    if self._account_type != 'FUTURE' and self._sub_account_id is None:     self._sub_account_id = self._get_sub_account(slice_item[""trade""])    if self._account_id in slice_item[""trade""]:     slice_item[""trade""][self._account_key] = slice_item[""trade""].pop(self._account_id)    elif self._sub_account_id in slice_item[""trade""]:     slice_item[""trade""][self._account_key] = slice_item[""trade""].pop(self._sub_account_id)   if pack[""aid""] == ""rtn_data"":    self._diffs.extend(pack.get('data', []))  def _get_sub_account(self, trade):   """""" 股票账户   OTG 登录确认包格式   {'trade': {'sub_account_key': {'session': {'user_id': '', 'trading_day': ''}}}}   """"""   for k, v in trade.items():    if 'session' in v.keys() and v.get('session').get('user_id', '') == self._account_id:     return k   return None  @property  def _next_order_id(self):   self._order_id += 1   return self._order_id class TqKq(TqAccount):  def __init__(self, td_url: Optional[str] = None):   """"""   创建快期模拟账户实例   """"""   super().__init__(""快期模拟"", """", """", td_url=td_url) class TqKqStock(TqAccount):  def __init__(self, td_url: Optional[str] = None):   """"""   创建快期股票模拟账户实例   快期股票模拟为专业版功能，可以点击 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_ 申请试用或购买   Example::    from tqsdk import TqApi, TqAuth, TqKqStock, TqChan    tq_kq_stock = TqKqStock()    api = TqApi(account=tq_kq_stock, auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SSE.688529"")    print(quote)    # 下单限价单    order = api.insert_order(""SSE.688529"", volume=200, direction=""BUY"", limit_price=quote.ask_price1)    while order.status == 'ALIVE':     api.wait_update()     print(order) # 打印委托单信息    print(api.get_account()) # 打印快期股票模拟账户信息    print(api.get_position(""SSE.688529"")) # 打印持仓信息    for trade in order.trade_records.values():     print(trade) # 打印委托单对应的成交信息    api.close()   """"""   super().__init__(""快期股票模拟"", """", """", td_url=td_url, account_type=""SPOT"") "
74,n\tqsdk\ap,"n\tqsdk\ap. #!/usr/bin/env python # -*- coding: utf-8 -*- """""" 天勤接口的PYTHON封装, 提供以下功能 * 连接行情和交易服务器, 接收行情及交易推送数据 * 在内存中存储管理一份完整的业务数据(行情+交易), 并在接收到新数据包时更新内存数据 * 通过一批函数接口, 支持用户代码访问业务数据 * 发送交易指令 * 提供本地的模拟交易账户，同时完成撮合成交 * 支持回测功能 * PYTHON SDK使用文档: https://doc.shinnytech.com/pysdk/latest/ * 天勤vscode插件使用文档: https://doc.shinnytech.com/pysdk/latest/devtools/vscode.html * 天勤用户论坛: https://www.shinnytech.com/qa/ """""" __author__ = 'chengzhi' import asyncio import copy import logging import lzma import json import os import platform import re import sys import time import warnings from datetime import datetime, date, timedelta from typing import Union, List, Any, Optional, Coroutine, Callable, Tuple, Dict import numpy as np import psutil from sgqlc.operation import Operation from shinny_structlog import ShinnyLoggerAdapter, JSONFormatter import pandas as pd import requests from pandas import RangeIndex, Index from pandas._libs.internals import BlockPlacement if tuple(map(int, pd.__version__.split("".""))) < (1, 3, 0):  from pandas.core.internals import FloatBlock else:  from pandas.core.internals import NumericBlock as FloatBlock from tqsdk.auth import TqAuth from tqsdk.baseApi import TqBaseApi from tqsdk.multiaccount import TqMultiAccount from tqsdk.backtest import TqBacktest, TqReplay from tqsdk.channel import TqChan from tqsdk.connect import TqConnect, MdReconnectHandler, ReconnectTimer from tqsdk.calendar import _get_trading_calendar, TqContCalendar, _init_chinese_rest_days from tqsdk.data_extension import DataExtension from tqsdk.data_series import DataSeries from tqsdk.datetime import _get_trading_day_start_time, _get_trading_day_end_time, _get_trading_day_from_timestamp, \  _datetime_to_timestamp_nano from tqsdk.diff import _merge_diff, _get_obj, _is_key_exist, _register_update_chan from tqsdk.entity import Entity from tqsdk.exceptions import TqTimeoutError from tqsdk.log import _clear_logs, _get_log_name, _get_disk_free from tqsdk.objs import Quote, TradingStatus, Kline, Tick, Account, Position, Order, Trade, QuotesEntity, RiskManagementRule, RiskManagementData from tqsdk.objs import SecurityAccount, SecurityOrder, SecurityTrade, SecurityPosition from tqsdk.objs_not_entity import QuoteList, TqDataFrame, TqSymbolDataFrame, SymbolList, SymbolLevelList, \  TqSymbolRankingDataFrame, TqOptionGreeksDataFrame from tqsdk.risk_manager import TqRiskManager from tqsdk.risk_rule import TqRiskRule from tqsdk.ins_schema import ins_schema, basic, derivative, future, option from tqsdk.symbols import TqSymbols from tqsdk.tradeable import TqAccount, TqKq, TqKqStock, TqSim, TqSimStock, BaseOtg from tqsdk.trading_status import TqTradingStatus from tqsdk.tqwebhelper import TqWebHelper from tqsdk.utils import _generate_uuid, _query_for_quote, BlockManagerUnconsolidated, _quotes_add_night, _bisect_value from tqsdk.utils_symbols import _symbols_to_quotes from tqsdk.tafunc import get_dividend_df, get_dividend_factor from .__version__ import __version__ UnionTradeable = Union[TqAccount, TqKq, TqKqStock, TqSim, TqSimStock] class TqApi(TqBaseApi):  """"""  天勤接口及数据管理类  通常情况下, 一个线程中 **应该只有一个** TqApi的实例, 它负责维护网络连接, 接收行情及账户数据, 并在内存中维护业务数据截面  """"""  def __init__(self, account: Optional[Union[TqMultiAccount, UnionTradeable]] = None,     auth: Union[TqAuth, str, None] = None,     url: Optional[str] = None, backtest: Union[TqBacktest, TqReplay, None] = None,     web_gui: Union[bool, str] = False, debug: Union[bool, str, None] = None,     loop: Optional[asyncio.AbstractEventLoop] = None, disable_print: bool = False, _stock: bool = True,     _ins_url=None, _md_url=None, _td_url=None) -> None:   """"""   创建天勤接口实例   Args:    account (None/TqAccount/TqKq/TqKqStock/TqSim/TqSimStock/TqMultiAccount): [可选]交易账号:     * None: 账号将根据环境变量决定, 默认为 :py:class:`~tqsdk.TqSim`     * :py:class:`~tqsdk.TqAccount` : 使用实盘账号, 直连行情和交易服务器, 需提供期货公司/帐号/密码     * :py:class:`~tqsdk.TqKq` : 使用快期账号登录，直连行情和快期模拟交易服务器     * :py:class:`~tqsdk.TqKqStock` : 使用快期账号登录，直连行情和快期股票模拟交易服务器     * :py:class:`~tqsdk.TqSim` : 使用 TqApi 自带的内部模拟账号     * :py:class:`~tqsdk.TqSimStock` : 使用 TqApi 自带的内部股票模拟账号     * :py:class:`~tqsdk.TqMultiAccount` : 多账户列表，列表中支持 :py:class:`~tqsdk.TqAccount`、:py:class:`~tqsdk.TqKq`、\     :py:class:`~tqsdk.TqKqStock`、:py:class:`~tqsdk.TqSim` 和 :py:class:`~tqsdk.TqSimStock` 中的 0 至 N 个或者组合    auth (TqAuth/str): [必填]用户信易账户:     * :py:class:`~tqsdk.TqAuth` : 添加信易账户类，例如：TqAuth(""tianqin@qq.com"", ""123456"")     * str: 用户权限认证对象为天勤用户论坛的邮箱和密码，中间以英文逗号分隔，例如： ""tianqin@qq.com,123456""\     信易账户注册链接 https://www.shinnytech.com/register-intro/    url (str): [可选]指定服务器的地址     * 当 account 为 :py:class:`~tqsdk.TqAccount`、:py:class:`~tqsdk.TqMultiAccount` 类型时, 可以通过该参数指定交易服务器地址,\     默认使用对应账户的交易服务地址，行情地址该信易账户对应的行情服务地址     * 当 account 为 :py:class:`~tqsdk.TqSim`、:py:class:`~tqsdk.TqSimStock` 类型时, 可以通过该参数指定行情服务器地址, 默认使用该信易账户对应的行情服务地址    backtest (TqBacktest): [可选] 进入时光机，此时强制要求 account 类型为 :py:class:`~tqsdk.TqSim`     * :py:class:`~tqsdk.TqBacktest` : 传入 TqBacktest 对象，进入回测模式 \     在回测模式下, TqBacktest 连接 wss://backtest.shinnytech.com/t/md/front/mobile 接收行情数据, \     由 TqBacktest 内部完成回测时间段内的行情推进和 K 线、Tick 更新.    debug(bool/str): [可选] 是否将调试信息输出到指定文件，默认值为 None。     * None [默认]: 根据账户情况不同，默认值的行为不同。      + 当有以下账户之一时，:py:class:`~tqsdk.TqAccount`、:py:class:`~tqsdk.TqKq`、:py:class:`~tqsdk.TqKqStock` 账户时，\      调试信息输出到指定文件夹 `~/.tqsdk/logs`（如果磁盘剩余空间不足 3G 则不会输出调试信息）。      + 其他情况，即仅有本地模拟账户 :py:class:`~tqsdk.TqSim`、:py:class:`~tqsdk.TqSimStock` 时，调试信息不输出。     * True: 调试信息会输出到指定文件夹 `~/.tqsdk/logs`。     * False: 不输出调试信息。     * str: 指定一个日志文件名, 调试信息输出到指定文件。    loop(asyncio.AbstractEventLoop): [可选] 使用指定的 IOLoop, 默认创建一个新的.    web_gui(bool/str): [可选]是否启用图形化界面功能, 默认不启用.     * 启用图形化界面传入参数 web_gui=True 会每次以随机端口生成网页，也可以直接设置本机IP和端口 web_gui=[ip]:port 为网页地址，\     ip 可选，默认为 0.0.0.0，参考example 6     * 为了图形化界面能够接收到程序传输的数据并且刷新，在程序中，需要循环调用 api.wait_update的形式去更新和获取数据     * 推荐打开图形化界面的浏览器为Google Chrome 或 Firefox   Example1::    # 使用实盘帐号直连行情和交易服务器    from tqsdk import TqApi, TqAuth, TqAccount    api = TqApi(TqAccount(""H海通期货"", ""022631"", ""123456""), auth=TqAuth(""信易账户"", ""账户密码""))   Example2::    # 使用快期模拟帐号连接行情服务器    from tqsdk import TqApi, TqAuth, TqKq    api = TqApi(TqKq(), auth=TqAuth(""信易账户"", ""账户密码"")) # 根据填写的信易账户参数连接指定的快期模拟账户   Example3::    # 使用模拟帐号直连行情服务器    from tqsdk import TqApi, TqAuth, TqSim    api = TqApi(TqSim(), auth=TqAuth(""信易账户"", ""账户密码"")) # 不填写参数则默认为 TqSim() 模拟账号   Example4::    # 进行策略回测    from datetime import date    from tqsdk import TqApi, TqAuth, TqBacktest    api = TqApi(backtest=TqBacktest(start_dt=date(2018, 5, 1), end_dt=date(2018, 10, 1)), auth=TqAuth(""信易账户"", ""账户密码""))   Example5::    # 进行策略复盘    from datetime import date    from tqsdk import TqApi, TqAuth, TqReplay    api = TqApi(backtest=TqReplay(replay_dt=date(2019, 12, 16)), auth=TqAuth(""信易账户"", ""账户密码""))   Example6::    # 开启 web_gui 功能，使用默认参数True    from tqsdk import TqApi, TqAuth    api = TqApi(web_gui=True, auth=TqAuth(""信易账户"", ""账户密码""))   Example7::    # 开启 web_gui 功能，使用本机IP端口固定网址生成    from tqsdk import TqApi, TqAuth    api = TqApi(web_gui="":9876"", auth=TqAuth(""信易账户"", ""账户密码"")) # 等价于 api = TqApi(web_gui=""0.0.0.0:9876"", auth=TqAuth(""信易账户"", ""账户密码""))   """"""   # 初始化 logger   self._logger = logging.getLogger(""TqApi"")   self._logger.setLevel(logging.DEBUG)   self.disable_print = disable_print   # 创建一个新的 ioloop, 避免和其他框架/环境产生干扰   super(TqApi, self).__init__(loop=loop)   # 记录参数   self._debug = debug # 日志选项   if isinstance(auth, TqAuth):    self._auth = auth   elif isinstance(auth, str):    comma_index = auth.find(',')    if comma_index == -1:     raise Exception(f""不能正确解析 auth=\""{auth}\"", 请填写正确的 auth 参数，以英文逗号分隔用户名和密码，例如：\""tianqin@qq.com,123456\""。"")    user_name, pwd = auth[:comma_index], auth[comma_index + 1:]    self._auth = TqAuth(user_name, pwd)   else:    self._auth = None   self._account = TqSim() if account is None else account   self._backtest = backtest   self._stock = False if isinstance(self._backtest, TqReplay) else _stock   self._ins_url = os.getenv(""TQ_INS_URL"", ""https://openmd.shinnytech.com/t/md/symbols/latest.json"")   self._md_url = os.getenv(""TQ_MD_URL"", None)   self._td_url = os.getenv(""TQ_TD_URL"", None)   if url and isinstance(self._account, TqMultiAccount):    raise Exception(""多账户模式下，交易服务器地址需在创建账户实例时单独指定"")   if url and isinstance(self._account, TqSim):    self._md_url = url   if url and isinstance(self._account, TqAccount):    self._td_url = url   if _ins_url:    self._ins_url = _ins_url   if _md_url:    self._md_url = _md_url   if _td_url:    self._td_url = _td_url   # 内部关键数据   self._risk_manager = TqRiskManager()   self._requests = {    ""trading_status"": set(),    ""quotes"": set(),    ""klines"": {},    ""ticks"": {},   } # 记录已发出的请求   self._serials = {} # 记录所有数据序列   # 记录所有(若有多个serial 则仅data_length不同, right_id相同)合约、周期相同的多合约K线中最大的更新数据范围   # key:(主合约,(所有副合约),duration), value:(K线的新数据中主合约最小的id, 主合约的right_id)。用于is_changing()中新K线生成的判定   self._klines_update_range = {}   self._data = Entity() # 数据存储   self._data._instance_entity([])   self._data[""quotes""] = QuotesEntity(self)   self._data[""quotes""]._instance_entity([""quotes""])   self._diffs = [] # 自上次wait_update返回后收到更新数据的数组 (异步代码)   self._sync_diffs = [] # 自上次wait_update返回后收到更新数据的数组 (同步代码)   self._pending_diffs = [] # 从网络上收到的待处理的 diffs, 只在 wait_update 函数执行过程中才可能为非空   self._pending_peek = False # 是否有发出的 peek_message 还没收到数据回复   self._prototype = self._gen_prototype() # 各业务数据的原型, 用于决定默认值及将收到的数据转为特定的类型   self._security_prototype = self._gen_security_prototype() # 股票业务数据原型   self._dividend_cache = {} # 缓存合约对应的复权系数矩阵，每个合约只计算一次   self._send_chan, self._recv_chan = TqChan(self), TqChan(self) # 消息收发队列   self._ws_md_recv_chan = None # 记录 ws_md_recv_chan 引用   # slave模式的api不需要完整初始化流程   self._is_slave = isinstance(account, TqApi)   self._slaves = []   if self._is_slave:    self._master = account    if self._master._is_slave:     raise Exception(""不可以为slave再创建slave"")    self._master._slaves.append(self)    self._account = self._master._account    if isinstance(self._account, TqMultiAccount):     warnings.warn(""TqSdk 暂不支持在多线程下使用"")    self._web_gui = False # 如果是slave, _web_gui 一定是 False    return # 注: 如果是slave,则初始化到这里结束并返回,以下代码不执行   self._web_gui = web_gui   # 初始化   self.create_task(self._notify_watcher()) # 监控服务器发送的通知   self._reconnect_timer = ReconnectTimer() # 管理 ws 连接重连时间   self._setup_connection() # 初始化通讯连接   # 等待初始化完成   deadline = time.time() + 60   try:    # 多账户时，所有账户需要初始化完成    trade_more_data = True    while self._data.get(""mdhis_more_data"", True) or trade_more_data:     if not self.wait_update(deadline=deadline): # 等待连接成功并收取截面数据      raise TqTimeoutError(""接收数据超时，请检查客户端及网络是否正常"")     trade_more_data = self._account._get_trade_more_data_and_order_id(self._data)   except:    self.close()    raise   # 使用空 list, 使得 is_changing() 返回 false, 因为截面数据不算做更新数据   self._diffs = []   self._sync_diffs = []  def _print(self, msg: str = """", level: str = ""INFO""):   if self.disable_print:    return   dt = """" if self._backtest else datetime.now().strftime('%Y-%m-%d %H:%M:%S')   level = level if isinstance(level, str) else logging.getLevelName(level)   print(f""{(dt + ' - ') if dt else ''}{level:>8} - {msg}"")  @property  def _base_headers(self):   return self._auth._base_headers  # ----------------------------------------------------------------------  def copy(self) -> 'TqApi':   """"""   创建当前TqApi的一个副本. 这个副本可以在另一个线程中使用   Returns:    :py:class:`~tqsdk.api.TqApi`: 返回当前TqApi的一个副本. 这个副本可以在另一个线程中使用   """"""   slave_api = TqApi(self)   # 将当前api的_data值复制到_copy_diff中, 然后merge到副本api的_data里   _copy_diff = {}   TqApi._deep_copy_dict(self._data, _copy_diff)   slave_api._auth = self._auth   _merge_diff(slave_api._data, _copy_diff, slave_api._prototype, persist=False)   return slave_api  def close(self) -> None:   """"""   关闭天勤接口实例并释放相应资源   Example::    # m1901开多3手    from tqsdk import TqApi, TqAuth    from contextlib import closing    with closing(TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) as api:     api.insert_order(symbol=""DCE.m1901"", direction=""BUY"", offset=""OPEN"", volume=3)   """"""   if self._loop.is_closed():    return   if self._loop.is_running():    raise Exception(""不能在协程中调用 close, 如需关闭 api 实例需在 wait_update 返回后再关闭"")   elif asyncio._get_running_loop():    raise Exception(     ""TqSdk 使用了 python3 的原生协程和异步通讯库 asyncio，您所使用的 IDE 不支持 asyncio, 请使用 pycharm 或其它支持 asyncio 的 IDE"")   # 总会发送 serial_extra_array 数据，由 TqWebHelper 处理   for _, serial in self._serials.items():    self._process_serial_extra_array(serial)   super(TqApi, self)._close()   mem = psutil.virtual_memory()   self._logger.debug(""process end"", mem_total=mem.total, mem_free=mem.free)  def __enter__(self):   return self  def __exit__(self, exc_type, exc_val, exc_tb):   self.close()  # ----------------------------------------------------------------------  def get_quote(self, symbol: str) -> Quote:   """"""   获取指定合约的盘口行情.   Args:    symbol (str): 指定合约代码。   Returns:    :py:class:`~tqsdk.objs.Quote`: 返回一个盘口行情引用. 其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新.   注意:   1. 在 tqsdk 还没有收到行情数据包时, 此对象中各项内容为 NaN 或 0   2. 天勤接口从0.8版本开始，合约代码格式变更为 交易所代码.合约代码 的格式. 可用的交易所代码如下：    * CFFEX: 中金所    * SHFE: 上期所    * DCE: 大商所    * CZCE: 郑商所    * INE: 能源交易所(原油)    * SSE: 上交所    * SZSE: 深交所   Example1::    # 获取 SHFE.cu1812 合约的报价    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SHFE.cu1812"")    print(quote.last_price)    while api.wait_update():     print(quote.last_price)    # 预计的输出是这样的:    nan    24575.0    24575.0    ...   Example2::    # 协程示例，为每个合约创建 task    from tqsdk import TqApi, TqAuth    async def demo(SYMBOL):     quote = await api.get_quote(SYMBOL) # 支持 await 异步，这里会订阅合约，等到收到合约行情才返回     print(f""quote: {SYMBOL}"", quote.datetime, quote.last_price) # 这一行就会打印出合约的最新行情     async with api.register_update_notify() as update_chan:      async for _ in update_chan:       if api.is_changing(quote):        print(SYMBOL, quote.datetime, quote.last_price)       # ... 策略代码 ...    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    symbol_list = [""SHFE.rb2107"", ""DCE.m2109""] # 设置合约代码    for symbol in symbol_list:     api.create_task(demo(symbol)) # 为每个合约创建异步任务    while True:     api.wait_update()   """"""   if symbol == """":    raise Exception(f""get_quote 中请求合约代码不能为空字符串"")   return self.get_quote_list([symbol])[0]  # ----------------------------------------------------------------------  def get_quote_list(self, symbols: List[str]) -> QuoteList:   """"""   获取指定合约列表的盘口行情.   Args:    symbols (list of str): 合约代码列表   Returns:    list of :py:class:`~tqsdk.objs.Quote`: 返回一个列表，每个元素为指定合约盘口行情引用。   注意:   1. 在 tqsdk 还没有收到行情数据包时, 此对象中各项内容为 NaN 或 0   2. 天勤接口从0.8版本开始，合约代码格式变更为 交易所代码.合约代码 的格式. 可用的交易所代码如下：    * CFFEX: 中金所    * SHFE: 上期所    * DCE: 大商所    * CZCE: 郑商所    * INE: 能源交易所(原油)    * SSE: 上交所    * SZSE: 深交所   Example::    # 获取 SHFE.cu1812 合约的报价    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    quote_list = api.get_quote_list([""SHFE.cu2105"", ""SHFE.cu2112""])    print(quote_list[0].last_price, quote_list[1].last_price)    while api.wait_update():     print(quote_list[0].last_price, quote_list[1].last_price)    # 预计的输出是这样的:    24575.0 24545.0    24575.0 24545.0    ...   """"""   if any([s == """" for s in symbols]):    raise Exception(f""get_quote_list 中请求合约代码不能为空字符串 {symbols}"")   quote_list = QuoteList(self, [_get_obj(self._data, [""quotes"", s], self._prototype[""quotes""][""#""])          for s in symbols])   if not self._loop.is_running():    deadline = time.time() + 30    if isinstance(self._backtest, TqBacktest):     if len(quote_list) > 100:      raise Exception(""get_quote_list 请求合约长度超过限制。回测中最多支持长度为 100。"")     deadline = time.time() + 25 + 3 * len(quote_list) # 回测时的行情需要下载 klines，加长超时时间    while not quote_list._task.done():     if not self.wait_update(deadline=deadline, _task=quote_list._task):      raise TqTimeoutError(f""获取 {symbols} 的行情信息超时，请检查客户端及网络是否正常"")   return quote_list  def _ensure_symbol(self, symbol: Union[str, List[str]]):   # 已经收到收到合约信息之后返回，同步   all_symbol_list = symbol if isinstance(symbol, list) else [symbol]   # self._data.quotes 下 price_tick 不大于 0，需要发送 ins_query 查询的合约   symbol_list = [symbol for symbol in all_symbol_list if      not self._data.get(""quotes"", {}).get(symbol, {}).get('price_tick', float('nan')) > 0]   if len(symbol_list) == 0:    return True   if self._stock is False:    raise Exception(""代码 %s 不存在, 请检查合约代码是否填写正确"" % (symbol_list))   else:    task = self.create_task(self._ensure_symbol_async(symbol_list), _caller_api=True)    if not self._loop.is_running():     deadline = time.time() + 30     while not task.done():      if not self.wait_update(deadline=deadline, _task=task):       raise TqTimeoutError(f""获取 {symbol} 的合约信息超时，请检查客户端及网络是否正常，且合约代码填写正确"")  async def _ensure_symbol_async(self, symbol: Union[str, List[str]]):   # 已经收到收到合约信息之后返回，异步   all_symbol_list = symbol if isinstance(symbol, list) else [symbol]   # self._data.quotes 下 price_tick 不大于 0，需要发送 ins_query 查询的合约   symbol_list = [symbol for symbol in all_symbol_list if      not self._data.get(""quotes"", {}).get(symbol, {}).get('price_tick', float('nan')) > 0]   if len(symbol_list) == 0:    return True   if self._stock is False:    raise Exception(""代码 %s 不存在, 请检查合约代码是否填写正确"" % symbol_list)   else:    query_pack = _query_for_quote(symbol_list)    self._send_pack(query_pack)    async with self.register_update_notify() as update_chan:     async for _ in update_chan:      if all([self._data.get(""quotes"", {}).get(symbol, {}).get('price_tick', float('nan')) > 0 for symbol in symbol_list]):       break  # ----------------------------------------------------------------------  def get_trading_status(self, symbol: str) -> TradingStatus:   """"""   获取指定合约的交易状态. 此接口为 TqSdk 专业版提供，便于实现开盘抢单功能。   如果想使用此功能，可以点击 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_ 申请试用或购买   Args:    symbol (str): 合约代码   Returns:    :py:class:`~tqsdk.objs.TradingStatus`: 返回指定合约交易状态引用。   Example::    # 在集合竞价时下单    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    ts = api.get_trading_status(""SHFE.cu2201"")    print(ts.trade_status)    while True:    api.wait_update()    if ts.trade_status == ""AUCTIONORDERING"":     order = api.insert_order(""SHFE.cu2201"",""BUY"",""OPEN"", 1, 71400)     break    # insert_order指令会在下一次wait_update()发出    api.wait_update()    api.close()   """"""   if symbol == """":    raise Exception(f""get_trading_status 中合约代码不能为空字符串"")   if not self._auth._has_feature('tq_trading_status'):    raise Exception(f""您的账户不支持查看交易状态信息，需要购买专业版本后使用。升级网址：https://account.shinnytech.com"")   if self._backtest:    raise Exception('回测/复盘不支持查看交易状态信息')   ts = _get_obj(self._data, ['trading_status', symbol], self._prototype[""trading_status""][""#""])   ts._task = self.create_task(self._handle_trading_status(symbol, ts), _caller_api=True)   if not self._loop.is_running():    deadline = time.time() + 30    while not ts._task.done():     if not self.wait_update(deadline=deadline, _task=ts._task):      raise TqTimeoutError(f""获取 {symbol} 的合约交易状态信息超时，请检查客户端及网络是否正常"")   return ts  async def _handle_trading_status(self, symbol, ts):   if ts.trade_status != """":    return ts   if symbol not in self._requests[""trading_status""]:    self._requests[""trading_status""].add(symbol)    self._send_pack({     ""aid"": ""subscribe_trading_status"",     ""ins_list"": "","".join(self._requests[""trading_status""])    })   async with self.register_update_notify(ts) as update_chan:    async for _ in update_chan:     if ts.trade_status != """":      return ts  # ----------------------------------------------------------------------  def get_kline_serial(self, symbol: Union[str, List[str]], duration_seconds: int, data_length: int = 200,       chart_id: Optional[str] = None, adj_type: Union[str, None] = None) -> pd.DataFrame:   """"""   获取k线序列数据   请求指定合约及周期的K线数据. 序列数据会随着时间推进自动更新   Args:    symbol (str/list of str): 指定合约代码或合约代码列表.     * str: 一个合约代码     * list of str: 合约代码列表 （一次提取多个合约的K线并根据相同的时间向第一个合约（主合约）对齐)    duration_seconds (int): K线数据周期, 以秒为单位。例如: 1分钟线为60,1小时线为3600,日线为86400。\     注意: 周期在日线以内时此参数可以任意填写, 在日线以上时只能是日线(86400)的整数倍, 最大为28天 (86400*28)。    data_length (int): 需要获取的序列长度。默认200根, 返回的K线序列数据是从当前最新一根K线开始往回取data_length根。\    每个序列最大支持请求 8000 个数据    chart_id (str): [可选]指定序列id, 默认由 api 自动生成    adj_type (str/None): [可选]指定复权类型，默认为 None。adj_type 参数只对股票和基金类型合约有效。\    ""F"" 表示前复权；""B"" 表示后复权；None 表示不做处理。    **注：关于传入合约代码列表 获取多合约K线的说明：**    1. 主合约的字段名为原始K线数据字段，从第一个副合约开始，字段名在原始字段后加数字，如第一个副合约的开盘价为 ""open1"" , 第二个副合约的收盘价为 ""close2""。    2. 每条K线都包含了订阅的所有合约数据，即：如果任意一个合约（无论主、副）在某个时刻没有数据（即使其他合约在此时有数据）,\     则不能对齐，此多合约K线在该时刻那条数据被跳过，现象表现为K线不连续（如主合约有夜盘，而副合约无夜盘，则生成的多合约K线无夜盘时间的数据）。    3. 若设置了较大的序列长度参数，而所有可对齐的数据并没有这么多，则序列前面部分数据为NaN（这与获取单合约K线且数据不足序列长度时情况相似）。    4. 若主合约与副合约的交易时间在所有合约数据中最晚一根K线时间开始往回的 8000*周期 时间段内完全不重合，则无法生成多合约K线，程序会报出获取数据超时异常。    5. datetime、duration是所有合约公用的字段，则未单独为每个副合约增加一份副本，这两个字段使用原始字段名（即没有数字后缀）。    6. **暂不支持复权** 获取多合约K线，若填入 adj_type，程序会报参数错误。   Returns:    pandas.DataFrame: 本函数总是返回一个 pandas.DataFrame 实例. 行数=data_length, 包含以下列:    * id: 1234 (k线序列号)    * datetime: 1501080715000000000 (K线起点时间(按北京时间)，自unix epoch(1970-01-01 00:00:00 GMT)以来的纳秒数)    * open: 51450.0 (K线起始时刻的最新价)    * high: 51450.0 (K线时间范围内的最高价)    * low: 51450.0 (K线时间范围内的最低价)    * close: 51450.0 (K线结束时刻的最新价)    * volume: 11 (K线时间范围内的成交量)    * open_oi: 27354 (K线起始时刻的持仓量)    * close_oi: 27355 (K线结束时刻的持仓量)   Example1::    # 获取 SHFE.cu1812 的1分钟线    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    klines = api.get_kline_serial(""SHFE.cu1812"", 60)    print(klines.iloc[-1].close)    while True:     api.wait_update()     print(klines.iloc[-1].close)    # 预计的输出是这样的:    50970.0    50970.0    50960.0    ...   Example2::    # 获取按时间对齐的多合约K线    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    # 获取 CFFEX.IF1912 按照K线时间向 SHFE.au2006 对齐的K线    klines = api.get_kline_serial([""SHFE.au2006"", ""CFFEX.IF2006""], 5, data_length=10)    print(""多合约K线："", klines.iloc[-1])    while True:     api.wait_update()     if api.is_changing(klines.iloc[-1], [""close1"", ""close""]): # 判断任何一个收盘价是否有更新      dif = klines.close1 - klines.close # 使用对齐的K线直接计算价差等数据      print(""价差序列："", dif)   Example3::    # 使用tqsdk自带的时间转换函数, 将最后一根K线的纳秒时间转换为 datetime.datetime 类型    from tqsdk import tafunc    ...    klines = api.get_kline_serial(""DCE.jd2001"", 10)    kline_time = tafunc.time_to_datetime(klines.iloc[-1][""datetime""]) # datetime.datetime 类型值    print(type(kline_time), kline_time)    print(kline_time.year, kline_time.month, kline_time.day, kline_time.hour, kline_time.minute, kline_time.second)    ...   """"""   if not isinstance(symbol, list):    symbol = [symbol]   if any([s == """" for s in symbol]):    raise Exception(""参数错误，合约代码不能为空字符串"")   duration_seconds = int(duration_seconds) # 转成整数   if duration_seconds <= 0 or duration_seconds > 86400 and duration_seconds % 86400 != 0:    raise Exception(""K线数据周期 %d 错误, 请检查K线数据周期值是否填写正确"" % (duration_seconds))   data_length = int(data_length)   if data_length <= 0:    raise Exception(""K线数据序列长度 %d 错误, 请检查序列长度是否填写正确"" % (data_length))   if adj_type not in [None, ""F"", ""B"", ""FORWARD"", ""BACK""]:    raise Exception(""adj_type 参数只支持 None (不复权) ｜ 'F' (前复权) ｜ 'B' (后复权)"")   adj_type = adj_type[0] if adj_type else adj_type   if adj_type and len(symbol) > 1:    raise Exception(""参数错误，多合约 K 线序列不支持复权。"")   if data_length > 8964:    data_length = 8964   dur_id = duration_seconds * 1000000000   request = (tuple(symbol), duration_seconds, data_length, adj_type, chart_id) # request 中 symbols 为 tuple 序列   serial = self._requests[""klines""].get(request, None)   pack = {    ""aid"": ""set_chart"",    ""chart_id"": chart_id if chart_id is not None else _generate_uuid(""PYSDK_realtime""),    ""ins_list"": "","".join(symbol),    ""duration"": dur_id,    ""view_width"": data_length if len(symbol) == 1 else 8964,    # 如果同时订阅了两个以上合约K线，初始化数据时默认获取 1w 根K线(初始化完成后修改指令为设定长度)   }   # 将数据权转移给TqChan时其所有权也随之转移，因pack还需要被用到，所以传入副本   task = self.create_task(self._get_serial_async(symbol, chart_id, serial, pack.copy()), _caller_api=True)   if serial is None:    serial = self._init_serial([_get_obj(self._data, [""klines"", s, str(dur_id)]) for s in symbol],          data_length, self._prototype[""klines""][""*""][""*""][""data""][""@""], adj_type)    serial[""chart""] = _get_obj(self._data, [""charts"", pack[""chart_id""]]) # 保存chart信息    serial[""chart""].update(pack)    self._requests[""klines""][request] = serial    self._serials[id(serial[""df""])] = serial   # 对于多合约Kline，超时的等待时间应该和需要下载的数据量成正比，根据合约数量判断下载的数据量   deadline = time.time() + 25 + 5 * len(symbol)   while not self._loop.is_running() and not serial[""init""]:    if not self.wait_update(deadline=deadline, _task=[task, serial[""df""].__dict__[""_task""]]):     if len(symbol) > 1:      raise TqTimeoutError(""获取 %s (%d) 的K线超时，请检查客户端及网络是否正常，或任一副合约在主合约行情的最后 %d 秒内无可对齐的K线"" % (       symbol, duration_seconds, 8964 * duration_seconds))     else:      raise TqTimeoutError(""获取 %s (%d) 的K线超时，请检查客户端及网络是否正常"" % (symbol, duration_seconds))   return serial[""df""]  async def _get_serial_async(self, symbol, chart_id, serial, pack):   await self._ensure_symbol_async(symbol)   self._auth._has_md_grants(symbol)   # 判断用户是否指定了 chart_id（参数）, 如果指定了，则一定会发送新的请求。   if serial is None or chart_id is not None:    self._send_pack(pack)  # ----------------------------------------------------------------------  def get_tick_serial(self, symbol: str, data_length: int = 200, chart_id: Optional[str] = None,       adj_type: Union[str, None] = None) -> pd.DataFrame:   """"""   获取tick序列数据   请求指定合约的Tick序列数据. 序列数据会随着时间推进自动更新   Args:    symbol (str): 指定合约代码.    data_length (int): 需要获取的序列长度。每个序列最大支持请求 8000 个数据    chart_id (str): [可选]指定序列id, 默认由 api 自动生成    adj_type (str/None): [可选]指定复权类型，默认为 None。adj_type 参数只对股票和基金类型合约有效。\    ""F"" 表示前复权；""B"" 表示后复权；None 表示不做处理。   Returns:    pandas.DataFrame: 本函数总是返回一个 pandas.DataFrame 实例. 行数=data_length, 包含以下列:    * id: 12345 tick序列号    * datetime: 1501074872000000000 (tick从交易所发出的时间(按北京时间)，自unix epoch(1970-01-01 00:00:00 GMT)以来的纳秒数)    * last_price: 3887.0 (最新价)    * average: 3820.0 (当日均价)    * highest: 3897.0 (当日最高价)    * lowest: 3806.0 (当日最低价)    * ask_price1: 3886.0 (卖一价)    * ask_volume1: 3 (卖一量)    * bid_price1: 3881.0 (买一价)    * bid_volume1: 18 (买一量)    * volume: 7823 (当日成交量)    * amount: 19237841.0 (成交额)    * open_interest: 1941 (持仓量)   Example::    # 获取 SHFE.cu1812 的Tick序列    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    serial = api.get_tick_serial(""SHFE.cu1812"")    while True:     api.wait_update()     print(serial.iloc[-1].bid_price1, serial.iloc[-1].ask_price1)    # 预计的输出是这样的:    50860.0 51580.0    50860.0 51580.0    50820.0 51580.0    ...   """"""   if symbol == """":    raise Exception(""参数错误，合约代码不能为空字符串"")   data_length = int(data_length)   if data_length <= 0:    raise Exception(""K线数据序列长度 %d 错误, 请检查序列长度是否填写正确"" % (data_length))   if adj_type not in [None, ""F"", ""B"", ""FORWARD"", ""BACK""]:    raise Exception(""adj_type 参数只支持 None (不复权) ｜ 'F' (前复权) ｜ 'B' (后复权)"")   adj_type = adj_type[0] if adj_type else adj_type   if data_length > 8964:    data_length = 8964   request = (symbol, data_length, adj_type, chart_id)   serial = self._requests[""ticks""].get(request, None)   pack = {    ""aid"": ""set_chart"",    ""chart_id"": chart_id if chart_id is not None else _generate_uuid(""PYSDK_realtime""),    ""ins_list"": symbol,    ""duration"": 0,    ""view_width"": data_length,   }   # pack 的副本数据和所有权转移给TqChan   task = self.create_task(self._get_serial_async(symbol, chart_id, serial, pack.copy()), _caller_api=True)   if serial is None:    serial = self._init_serial([_get_obj(self._data, [""ticks"", symbol])], data_length,          self._prototype[""ticks""][""*""][""data""][""@""], adj_type)    serial[""chart""] = _get_obj(self._data, [""charts"", pack[""chart_id""]])    serial[""chart""].update(pack)    self._requests[""ticks""][request] = serial    self._serials[id(serial[""df""])] = serial   deadline = time.time() + 30   while not self._loop.is_running() and not serial[""init""]:    if not self.wait_update(deadline=deadline, _task=[task, serial[""df""].__dict__[""_task""]]):     raise TqTimeoutError(""获取 %s 的Tick超时，请检查客户端及网络是否正常，且合约代码填写正确"" % (symbol))   return serial[""df""]  # ----------------------------------------------------------------------  def get_kline_data_series(self, symbol: Union[str, List[str]], duration_seconds: int,        start_dt: Union[date, datetime], end_dt: Union[date, datetime],        adj_type: Union[str, None] = None) -> pd.DataFrame:   """"""   获取指定时间段内的 K 线序列，TqSdk 会缓存已经下载过的合约，提升代码执行效率、节约请求流量。   本接口仅限专业版用户使用，如需购买专业版或者申请试用，请访问 https://www.shinnytech.com/tqsdk_professional/。   该函数返回的对象不会更新，不建议在循环内调用该方法。   Args:    symbol (str): 指定合约代码。当前只支持单个合约。    duration_seconds (int): K 线数据周期, 以秒为单位。例如: 1 分钟线为 60，1 小时线为 3600，日线为 86400。\     注意: 周期在日线以内时此参数可以任意填写, 在日线以上时只能是日线(86400)的整数倍    start_dt (date/datetime): 起始时间, 如果类型为 date 则指的是交易日, 如果为 datetime 则指的是具体时间点    end_dt (date/datetime): 结束时间, 如果类型为 date 则指的是交易日, 如果为 datetime 则指的是具体时间点    adj_type (str/None): [可选]指定复权类型，默认为 None。adj_type 参数只对股票和基金类型合约有效。\    ""F"" 表示前复权；""B"" 表示后复权；None 表示不做处理。   Returns:    pandas.DataFrame: 本函数总是返回一个 pandas.DataFrame 实例。包含以下列:    * id: 1234 (k线序列号)    * datetime: 1501080715000000000 (K线起点时间(按北京时间)，自unix epoch(1970-01-01 00:00:00 GMT)以来的纳秒数)    * open: 51450.0 (K线起始时刻的最新价)    * high: 51450.0 (K线时间范围内的最高价)    * low: 51450.0 (K线时间范围内的最低价)    * close: 51450.0 (K线结束时刻的最新价)    * volume: 11 (K线时间范围内的成交量)    * open_oi: 27354 (K线起始时刻的持仓量)    * close_oi: 27355 (K线结束时刻的持仓量)   Example::    # 获取 SHFE.cu1805 合约 20180101-06:00:00 ~ 20180601-16:00:00 的 1 分钟线    from tqsdk import TqApi, TqAuth    from tqsdk.ta import MA, MACD    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    kline_data = api.get_kline_data_series(symbol = ""SHFE.cu1805"", duration_seconds=60,       start_dt = datetime(2018, 1, 1, 6, 0, 0), end_dt = datetime(2018, 6, 1, 16, 0, 0))    print(kline_data)    ma = MA(kline_data, 30) # 计算 MA 指标    print(list(ma[""ma""]))    macd = MACD(kline_data, 12, 26, 9) # 计算 MACD 指标    print(list(macd[""diff""]))    print(list(macd[""dea""]))    print(list(macd[""bar""]))    api.close()   """"""   if duration_seconds <= 0 or duration_seconds > 86400 and duration_seconds % 86400 != 0:    raise Exception(""K线数据周期 %d 错误, 请检查K线数据周期值是否填写正确"" % duration_seconds)   return self._get_data_series(""get_kline_data_series"", symbol, duration_seconds, start_dt, end_dt, adj_type)  # ----------------------------------------------------------------------  def get_tick_data_series(self, symbol: Union[str, List[str]], start_dt: Union[date, datetime],        end_dt: Union[date, datetime], adj_type: Union[str, None] = None) -> pd.DataFrame:   """"""   获取指定时间段内的 tick 序列，TqSdk 会缓存已经下载过的合约，提升代码执行效率、节约请求流量。   本接口仅限专业版用户使用，如需购买专业版或者申请试用，请访问 https://www.shinnytech.com/tqsdk_professional/。   该函数返回的对象不会更新，不建议在循环内调用该方法。   Args:    symbol (str): 指定合约代码。当前只支持单个合约。    start_dt (date/datetime): 起始时间, 如果类型为 date 则指的是交易日, 如果为 datetime 则指的是具体时间点    end_dt (date/datetime): 结束时间, 如果类型为 date 则指的是交易日, 如果为 datetime 则指的是具体时间点    adj_type (str/None): [可选]指定复权类型，默认为 None。adj_type 参数只对股票和基金类型合约有效。\    ""F"" 表示前复权；""B"" 表示后复权；None 表示不做处理。   Returns:    pandas.DataFrame: 本函数总是返回一个 pandas.DataFrame 实例。包含以下列:    * id: 12345 tick序列号    * datetime: 1501074872000000000 (tick从交易所发出的时间(按北京时间)，自unix epoch(1970-01-01 00:00:00 GMT)以来的纳秒数)    * last_price: 3887.0 (最新价)    * average: 3820.0 (当日均价)    * highest: 3897.0 (当日最高价)    * lowest: 3806.0 (当日最低价)    * ask_price1: 3886.0 (卖一价)    * ask_volume1: 3 (卖一量)    * bid_price1: 3881.0 (买一价)    * bid_volume1: 18 (买一量)    * volume: 7823 (当日成交量)    * amount: 19237841.0 (成交额)    * open_interest: 1941 (持仓量)   Example::    # 获取 SHFE.cu1805 合约 20180201-06:00:00 ~ 20180301-16:00:00 的 tick 数据    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    tick_data = api.get_tick_data_series(symbol = ""SHFE.cu1805"",       start_dt = datetime(2018, 2, 1, 6, 0, 0), end_dt = datetime(2018, 3, 1, 16, 0, 0))    print(tick_data)    ma = MA(tick_data, 30) # 计算 MA 指标    print(list(ma[""ma""]))    api.close()   """"""   return self._get_data_series(""get_tick_data_series"", symbol, 0, start_dt, end_dt, adj_type)  def _get_data_series(self, call_func: str, symbol_list: Union[str, List[str]], duration_seconds: int,       start_dt: Union[date, datetime], end_dt: Union[date, datetime],       adj_type: Union[str, None] = None) -> pd.DataFrame:   if self._loop.is_running():    raise Exception(f""不支持在协程中调用 {call_func} 接口"")   if not self._auth._has_feature(""tq_dl""):    raise Exception(     f""{call_func} 数据获取方式仅限专业版用户使用，如需购买专业版或者申请试用，请访问 https://www.shinnytech.com/tqsdk_professional/"")   if self._backtest:    raise Exception(f""不支持在回测/复盘中调用 {call_func} 接口"")   dur_nano = duration_seconds * 1000000000   symbol_list = symbol_list if isinstance(symbol_list, list) else [symbol_list]   if len(symbol_list) != 1:    raise Exception(f""{call_func} 数据获取方式暂不支持多合约请求"")   self._ensure_symbol(symbol_list) # 检查合约代码是否存在   if isinstance(start_dt, datetime):    start_dt_nano = _datetime_to_timestamp_nano(start_dt)   elif isinstance(start_dt, date):    start_dt_nano = _get_trading_day_start_time(     _datetime_to_timestamp_nano(datetime(start_dt.year, start_dt.month, start_dt.day)))   else:    raise Exception(f""start_dt 参数类型 {type(start_dt)} 错误, 只支持 datetime / date 类型，请检查是否正确"")   if isinstance(end_dt, datetime):    end_dt_nano = _datetime_to_timestamp_nano(end_dt)   elif isinstance(end_dt, date):    end_dt_nano = _get_trading_day_end_time(     _datetime_to_timestamp_nano(datetime(end_dt.year, end_dt.month, end_dt.day)))   else:    raise Exception(f""end_dt 参数类型 {type(end_dt)} 错误, 只支持 datetime / date 类型，请检查是否正确"")   if adj_type not in [None, ""F"", ""B""]:    raise Exception(""adj_type 参数只支持 None (不复权) ｜ 'F' (前复权) ｜ 'B' (后复权) "")   ds = DataSeries(self, symbol_list, dur_nano, start_dt_nano, end_dt_nano, adj_type)   while not self._loop.is_running() and not ds.is_ready:    deadline = time.time() + 30    if not self.wait_update(deadline=deadline):     raise TqTimeoutError(      f""{call_func} 获取数据 ({symbol_list, duration_seconds, start_dt, end_dt}) 超时，请检查客户端及网络是否正常。"")   return ds.df  # ----------------------------------------------------------------------  def get_trading_calendar(self, start_dt: Union[date, datetime], end_dt: Union[date, datetime]) -> pd.DataFrame:   """"""   获取一段时间内的交易日历信息，交易日历可以处理的范围为 2003-01-01 ～ 2022-12-31。   Args:    start_dt (date/datetime): 起始时间，如果类型为 date 则指的是该日期；如果为 datetime 则指的是该时间点所在日期    end_dt (date/datetime): 结束时间，如果类型为 date 则指的是该日期；如果为 datetime 则指的是该时间点所在日期   Returns:    pandas.DataFrame: 包含以下列:    * date: (datetime64[ns]) 日期    * trading:   (bool) 是否是交易日   Example::    from datetime import date    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    cld = api.get_trading_calendar(start_dt=date(2021,2,1), end_dt=date(2021,3,1))    print(cld)    # 预期输出如下    #   date trading    # 0 2021-02-01 True    # 1 2021-02-02 True    # 2 2021-02-03 True    # ......    # 26 2021-02-27 False    # 27 2021-02-28 False    # 28 2021-03-01 True    api.close()   """"""   if isinstance(start_dt, datetime):    start_dt = date(year=start_dt.year, month=start_dt.month, day=start_dt.day)   elif not isinstance(start_dt, date):    raise Exception(f""start_dt 参数类型 {type(start_dt)} 错误, 只支持 datetime / date 类型，请检查是否正确"")   if isinstance(end_dt, datetime):    end_dt = date(year=end_dt.year, month=end_dt.month, day=end_dt.day)   elif not isinstance(end_dt, date):    raise Exception(f""end_dt 参数类型 {type(end_dt)} 错误, 只支持 datetime / date 类型，请检查是否正确"")   first_date, latest_date = _init_chinese_rest_days()   if start_dt < first_date or end_dt > latest_date:    raise Exception(f""交易日历可以处理的范围为 {first_date.strftime('%Y-%m-%d')} ～ {latest_date.strftime('%Y-%m-%d')}，请修改参数"")   return _get_trading_calendar(start_dt, end_dt, headers=self._base_headers)  # ----------------------------------------------------------------------  def query_his_cont_quotes(self, symbol: Union[str, List[str]], n: int = 200) -> pd.DataFrame:   """"""   获取指定的主连合约最近 n 天的标的，可以处理的范围为 2003-01-01 ～ 2022-12-31。   Args:    symbol (str/list of str): 指定主连合约代码或主连合约代码列表.     * str: 一个合约代码     * list of str: 合约代码列表 （一次提取多个合约的K线并根据相同的时间向第一个合约（主合约）对齐)    n：返回 n 个交易日交易日的对应品种的主力, 默认值为 200，最大为 8964   Returns：    pandas.DataFrame: 包含 n 行数据，列数为指定主连合约代码个数加 1，有以下列:     * date: (datetime64[ns]) 日期     * 主连代码:   (str) 对应的标的合约   注意:   如果返回的时间段中，还未上市的主连合约，其对应的标的合约值为空字符串。   Example::    from datetime import date    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    conts = api.query_his_cont_quotes(symbol=['KQ.m@DCE.a', 'KQ.m@DCE.eg'], n=20)    print(conts)    # 预期输出如下    #   date KQ.m@DCE.a KQ.m@DCE.eg    # 0 2021-08-13 DCE.a2109 DCE.eg2109    # 1 2021-08-16 DCE.a2111 DCE.eg2109    # 2 2021-08-17 DCE.a2111 DCE.eg2109    # ......    # 17 2021-09-07 DCE.a2111 DCE.eg2201    # 18 2021-09-08 DCE.a2111 DCE.eg2201    # 19 2021-09-09 DCE.a2111 DCE.eg2201    api.close()   """"""   symbols = symbol if isinstance(symbol, list) else [symbol]   if any([s == """" for s in symbols]):    raise Exception(""参数错误，合约代码不能为空字符串"")   if n <= 0:    raise Exception(f""参数错误，n={n} 应该是大于等于 1 的整数"")   now_dt = self._get_current_datetime()   trading_day = _get_trading_day_from_timestamp(_datetime_to_timestamp_nano(now_dt))   end_dt = datetime.fromtimestamp(trading_day / 1000000000)   cont_calendar = TqContCalendar(start_dt=end_dt - timedelta(days=n * 2 + 30), end_dt=end_dt, symbols=symbols,          headers=self._base_headers)   df = cont_calendar.df.loc[cont_calendar.df.date.le(end_dt), ['date'] + symbols]   df = df.iloc[-n:]   df.reset_index(inplace=True, drop=True)   return df  # ----------------------------------------------------------------------  def add_risk_rule(self, rule: TqRiskRule) -> None:   """"""   添加一项风控规则实例，此接口为 TqSdk 专业版提供。   如需使用此功能，可以点击 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_ 申请试用或购买   Args:    rule (TqRiskRule): 风控规则实例，必须是 TqRiskRule 的子类型   """"""   if not self._auth._has_feature(""tq_lc_rk""):    raise Exception(""本地风控功能仅限专业版用户使用，如需购买专业版或者申请试用，请访问 https://www.shinnytech.com/tqsdk_professional/"")   if not isinstance(rule, TqRiskRule):    raise Exception(""传入参数对象必须是 TqRiskRule 的类型"")   self._risk_manager.append(rule)  def delete_risk_rule(self, rule: TqRiskRule) -> None:   """"""   删除一项风控规则实例，此接口为 TqSdk 专业版提供。   如需使用此功能，可以点击 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_ 申请试用或购买   Args:    rule (TqRiskRule): 风控规则实例，必须是 TqRiskRule 的子类型   """"""   if not isinstance(rule, TqRiskRule):    raise Exception(""传入参数对象必须是 TqRiskRule 的类型"")   self._risk_manager.remove(rule)  # ----------------------------------------------------------------------  def insert_order(self, symbol: str, direction: str, offset: str = """", volume: int = 0,      limit_price: Union[str, float, None] = None, advanced: Optional[str] = None,      order_id: Optional[str] = None, account: Optional[UnionTradeable] = None) -> Order:   """"""   发送下单指令. **注意: 指令将在下次调用** :py:meth:`~tqsdk.api.TqApi.wait_update` **时发出**   Args:    symbol (str): 拟下单的合约symbol, 格式为 交易所代码.合约代码, 例如 ""SHFE.cu1801""    direction (str): ""BUY"" 或 ""SELL""    offset (str): ""OPEN"", ""CLOSE"" 或 ""CLOSETODAY"" \     (上期所和上期能源分平今/平昨, 平今用""CLOSETODAY"", 平昨用""CLOSE""; 其他交易所直接用""CLOSE"" 按照交易所的规则平仓), \     股票交易中该参数无需填写    volume (int): 下单交易数量, 期货为下单手数, A 股股票为股数    limit_price (float | str): [可选] 下单价格, 默认为 None, 股票交易目前仅支持限价单, 该字段必须指定。     * 数字类型: 限价单，按照限定价格或者更优价格成交     * None: 市价单，默认值就是市价单 (郑商所期货/期权、大商所期货支持)     * ""BEST"": 最优一档，以对手方实时最优一档价格为成交价格成交（仅中金所支持）     * ""FIVELEVEL"": 最优五档，在对手方实时最优五个价位内以对手方价格为成交价格依次成交（仅中金所支持）    advanced (str): [可选] ""FAK"", ""FOK""。默认为 None, 股票交易中该参数不支持。     * None: 对于限价单，任意手数成交，委托单当日有效；对于市价单、最优一档、最优五档(与 FAK 指令一致)，任意手数成交，剩余撤单。     * ""FAK"": 剩余即撤销，指在指定价位成交，剩余委托自动被系统撤销。(限价单、市价单、最优一档、最优五档有效)     * ""FOK"": 全成或全撤，指在指定价位要么全部成交，否则全部自动被系统撤销。(限价单、市价单有效，郑商所期货品种不支持 FOK)    order_id (str): [可选]指定下单单号, 默认由 api 自动生成, 股票交易下单时, 无需指定    account (TqAccount/TqKq/TqKqStock/TqSim): [可选]指定发送下单指令的账户实例, 多账户模式下，该参数必须指定   Returns:    :py:class:`~tqsdk.objs.Order`: 返回一个委托单对象引用. 其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新.   Example1::    # 市价开3手 DCE.m1809 多仓    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    order = api.insert_order(symbol=""DCE.m1809"", direction=""BUY"", offset=""OPEN"", volume=3)    while True:     api.wait_update()     print(""单状态: %s, 已成交: %d 手"" % (order.status, order.volume_orign - order.volume_left))    # 预计的输出是这样的:    单状态: ALIVE, 已成交: 0 手    单状态: ALIVE, 已成交: 0 手    单状态: FINISHED, 已成交: 3 手    ...   Example2::    # 限价开多3手 DCE.m1901    from tqsdk import TqApi, TqAuth    with TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) as api:     order = api.insert_order(symbol=""DCE.m2009"", direction=""BUY"", offset=""OPEN"", volume=3, limit_price=3000)     while True:      api.wait_update()      print(""单状态: %s, 已成交: %d 手"" % (order.status, order.volume_orign - order.volume_left))    # 预计的输出是这样的:    单状态: ALIVE, 已成交: 0 手    单状态: ALIVE, 已成交: 0 手    单状态: FINISHED, 已成交: 3 手    ...   Example3::    # 市价开多3手 DCE.m1901 FAK    from tqsdk import TqApi, TqAuth    with TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) as api:     order = api.insert_order(symbol=""DCE.m2009"", direction=""BUY"", offset=""OPEN"", volume=3, advanced=""FAK"")     while True:      api.wait_update()      print(""单状态: %s, 已成交: %d 手"" % (order.status, order.volume_orign - order.volume_left))    # 预计的输出是这样的:    单状态: ALIVE, 已成交: 0 手    单状态: ALIVE, 已成交: 0 手    单状态: FINISHED, 已成交: 3 手    ...   Example4::    # 多账户模式下, 使用不同期货公司交易账户进行下单操作    from tqsdk import TqApi, TqAuth, TqMultiAccount    account1 = TqAccount(""H海通期货"", ""123456"", ""123456"")    account2 = TqAccount(""H宏源期货"", ""123456"", ""123456"")    with TqApi(TqMultiAccount([account1, account2]), auth=TqAuth(""信易账户"", ""账户密码"")) as api:     order1 = api.insert_order(symbol=""DCE.m2101"", direction=""BUY"", offset=""OPEN"", volume=3, account=account1)     order2 = api.insert_order(symbol=""DCE.m2103"", direction=""BUY"", offset=""OPEN"", volume=3, account=account2)     while order1.status != ""FINISHED"" or order2.status != ""FINISHED"":      api.wait_update()      print(""委托单1已成交: %d 手, 委托单2已成交: %d 手"", order1.volume_orign - order1.volume_left,      order2.volume_orign - order2.volume_left)    # 预计的输出是这样的:    委托单1已成交: 0 手, 委托单2已成交: 3 手    ...   Example5::    # 股票模拟下单    from tqsdk import TqApi, TqAuth, TqKqStock    account = TqKqStock()    with TqApi(account=account, auth=TqAuth(""信易账户"", ""账户密码"")) as api:     order = api.insert_order(""SSE.601456"", direction=""BUY"", limit_price=None, volume=200)     while order.status != ""FINISHED"":      api.wait_update()      print(""已成交: %d 股"" % (order.volume_orign - order.volume_left))    # 预计的输出是这样的:    已成交: 200 股    ...   """"""   (exchange_id, instrument_id) = symbol.split(""."", 1)   account = self._account._check_valid(account)   if account is None:    raise Exception(f""多账户模式下, 需要指定账户实例 account"")   if direction not in (""BUY"", ""SELL""):    raise Exception(""下单方向(direction) %s 错误, 请检查 direction 参数是否填写正确"" % (direction))   volume = int(volume)   if volume <= 0:    raise Exception(""下单数量(volume) %s 错误, 请检查 volume 是否填写正确"" % (volume))   if limit_price != limit_price:    raise Exception(f""limit_price 参数不支持设置为 {limit_price}。"")   if isinstance(account, TqAccount) and exchange_id == ""KQ"":    raise Exception(f""账户 {account._broker_id}, {account._account_id} 不支持交易合约 {symbol}。"")   if isinstance(account, TqKq) and exchange_id in [""SSE"", ""SZSE""]: # 快期模拟暂不支持，提前抛错    raise Exception(f""快期模拟暂不支持股票及 ETF 期权交易，股票交易请使用 TqKqStock。"")   if not (advanced is None or advanced in [""FAK"", ""FOK""]):    raise Exception(""advanced 参数错误，只支持以下选项之一 'FAK', 'FOK', None。"")   order_id = order_id if order_id else _generate_uuid(""PYSDK_insert"")   # 股票下单时, 不支持 offset 参数   if self._account._is_stock_type(account):    if offset:     raise Exception(f""股票交易无需指定开平标志 {offset}"")   else:    if offset not in (""OPEN"", ""CLOSE"", ""CLOSETODAY""):     raise Exception(""开平标志(offset) %s 错误, 请检查 offset 是否填写正确"" % (offset))   if self._loop.is_running():    # 需要在异步代码中发送合约信息请求和下单请求    self.create_task(     self._insert_order_async(symbol, direction, offset, volume, limit_price, advanced, order_id, account),     _caller_api=True)    order = self.get_order(order_id, account=account)    order.update({     ""order_id"": order_id,     ""exchange_id"": exchange_id,     ""instrument_id"": instrument_id,     ""direction"": direction,     ""volume_orign"": volume,     ""volume_left"": volume,     ""status"": ""ALIVE"",     ""_this_session"": True    })    if offset:     order.update({""offset"": offset})    return order   else:    self._ensure_symbol(symbol) # 合约是否存在    self._auth._has_td_grants(symbol) # 用户是否有该合约交易权限    quote = self._data[""quotes""][symbol]    if quote.ins_class == ""STOCK"":     pack = self._get_insert_order_stock_pack(symbol, direction, volume, limit_price, order_id, account)    else:     pack = self._get_insert_order_future_pack(symbol, direction, offset, volume, limit_price, advanced, order_id, account)    self._send_pack(pack)    order = self.get_order(order_id, account=account)    order.update({     ""order_id"": order_id,     ""exchange_id"": exchange_id,     ""instrument_id"": instrument_id,     ""direction"": direction,     ""volume_orign"": volume,     ""volume_left"": volume,     ""status"": ""ALIVE"",     ""limit_price"": pack.get(""limit_price"", float(""nan"")),     ""price_type"": pack[""price_type""],     ""_this_session"": True    })    if quote.ins_class != ""STOCK"":     # 非股票，期货/期权还有以下字段     order.update({      ""offset"": offset,      ""volume_condition"": pack[""volume_condition""],      ""time_condition"": pack[""time_condition""]     })    return order  def _get_insert_order_future_pack(self, symbol, direction, offset, volume, limit_price, advanced, order_id,          account: Optional[UnionTradeable] = None):   quote = self._data[""quotes""][symbol]   (exchange_id, instrument_id) = symbol.split(""."", 1)   msg = {    ""aid"": ""insert_order"",    ""account_key"": self._account._get_account_key(account),    ""user_id"": self._account._get_account_id(account),    ""order_id"": order_id,    ""exchange_id"": exchange_id,    ""instrument_id"": instrument_id,    ""direction"": direction,    ""offset"": offset,    ""volume"": volume   }   if limit_price == ""BEST"" or limit_price == ""FIVELEVEL"":    if exchange_id != ""CFFEX"":     raise Exception(f""{symbol} 不支持 {limit_price} 市价单，请修改 limit_price 参数。仅中金所支持 BESE / FIVELEVEL"")    if exchange_id in [""CFFEX""] and advanced == ""FOK"":     raise Exception(f""{symbol} 不支持 advanced 为 \""FOK\""。中金所不支持在指定 BEST / FIVELEVEL 的情况下使用 FOK 。"")    msg[""price_type""] = limit_price    msg[""time_condition""] = ""IOC""   elif limit_price is None:    if exchange_id in [""CFFEX"", ""SHFE"", ""INE"", ""SSE"", ""SZSE""]:     raise Exception(f""{symbol} 不支持市价单，请使用 limit_price 参数指定价格。中金所、上期所、原油交易所、上交所、深交所不支持市价单。"")    if exchange_id == ""DCE"" and quote.ins_class in [""OPTION"", ""FUTURE_OPTION""]:     raise Exception(f""{symbol} 不支持市价单，请使用 limit_price 参数指定价格。大商所期权不支持市价单。"")    if advanced == ""FOK"" and exchange_id == ""CZCE"" and quote.ins_class == ""FUTURE"":     raise Exception(f""{symbol} 不支持 advanced 为 \""FOK\""。郑商所期货品种不支持 FOK。"")    msg[""price_type""] = ""ANY""    msg[""time_condition""] = ""IOC""   else:    if advanced == ""FOK"" and exchange_id == ""CZCE"" and quote.ins_class == ""FUTURE"":     raise Exception(f""{symbol} 不支持 advanced 为 \""FOK\""。郑商所期货品种不支持 FOK。"")    if advanced == ""FAK"" and exchange_id in [""SZSE"", ""SSE""] and quote.ins_class.endswith(""OPTION""):     raise Exception(f""{symbol} 不支持 advanced 为 \""FAK\""。上交所、深交所限价单不支持 FAK。"")    msg[""price_type""] = ""LIMIT""    msg[""limit_price""] = float(limit_price)    msg[""time_condition""] = ""IOC"" if advanced else ""GFD""   msg[""volume_condition""] = ""ALL"" if advanced == ""FOK"" else ""ANY""   self._risk_manager._could_insert_order(msg)   self._risk_manager._on_insert_order(msg)   return msg  def _get_insert_order_stock_pack(self, symbol, direction, volume, limit_price, order_id,          account: Optional[UnionTradeable] = None):   (exchange_id, instrument_id) = symbol.split(""."", 1)   msg = {    ""aid"": ""insert_order"",    ""account_key"": self._account._get_account_key(account),    ""user_id"": self._account._get_account_id(account),    ""order_id"": order_id,    ""exchange_id"": exchange_id,    ""instrument_id"": instrument_id,    ""direction"": direction,    ""volume"": volume,    ""price_type"": ""ANY"" if limit_price is None else ""LIMIT""   }   if limit_price:    msg[""limit_price""] = float(limit_price)   self._risk_manager._could_insert_order(msg)   self._risk_manager._on_insert_order(msg)   return msg  async def _insert_order_async(self, symbol, direction, offset, volume, limit_price, advanced, order_id,         account: Optional[UnionTradeable] = None):   await self._ensure_symbol_async(symbol) # 合约是否存在   self._auth._has_td_grants(symbol) # 用户是否有该合约交易权限   quote = self._data[""quotes""][symbol]   if quote.ins_class == ""STOCK"":    pack = self._get_insert_order_stock_pack(symbol, direction, volume, limit_price, order_id, account)   else:    pack = self._get_insert_order_future_pack(symbol, direction, offset, volume, limit_price, advanced, order_id, account)   self._send_pack(pack)  # ----------------------------------------------------------------------  def cancel_order(self, order_or_order_id: Union[str, Order], account: Optional[UnionTradeable] = None) -> None:   """"""   发送撤单指令. **注意: 指令将在下次调用** :py:meth:`~tqsdk.api.TqApi.wait_update` **时发出**   Args:    order_or_order_id (str/ :py:class:`~tqsdk.objs.Order` ): 拟撤委托单或单号    account (TqAccount/TqKq/TqKqStock/TqSim/TqSimStock): [可选]指定发送撤单指令的账户实例, 多账户模式下, 该参数必须指定   Example1::    # 挂价开3手 DCE.m1809 多仓, 如果价格变化则撤单重下，直到全部成交    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""DCE.m1809"")    order = {}    while True:     api.wait_update()     # 当行情有变化且当前挂单价格不优时，则撤单     if order and api.is_changing(quote) and order.status == ""ALIVE"" and quote.bid_price1 > order.limit_price:      print(""价格改变，撤单重下"")      api.cancel_order(order)     # 当委托单已撤或还没有下单时则下单     if (not order and api.is_changing(quote)) or (api.is_changing(order) and order.volume_left != 0 and order.status == ""FINISHED""):      print(""下单: 价格 %f"" % quote.bid_price1)      order = api.insert_order(symbol=""DCE.m1809"", direction=""BUY"", offset=""OPEN"", volume=order.get(""volume_left"", 3), limit_price=quote.bid_price1)     if api.is_changing(order):      print(""单状态: %s, 已成交: %d 手"" % (order.status, order.volume_orign - order.volume_left))    # 预计的输出是这样的:    下单: 价格 3117.000000    单状态: ALIVE, 已成交: 0 手    价格改变，撤单重下    下单: 价格 3118.000000    单状态: ALIVE, 已成交: 0 手    单状态: FINISHED, 已成交: 3 手    ...   Example2::    # 多账户条件下, 股票账户依据期货账户下单结果进行操作    from tqsdk import TqApi, TqAuth, TqMultiAccount    future_account = TqAccount(""N南华期货"", ""123456"", ""123456"")    stock_account = TqAccount(""N南华期货_股票"", ""88888888"", ""123456"")    api = TqApi(TqMultiAccount([account1, account2]), auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""CFFEX.IF2011"")    order1 = api.insert_order(symbol=""CFFEX.IF2011"", direction=""SELL"", offset=""OPEN"", volume=3, account=future_account)    while True:     api.wait_update()     # 当行情有变化且当前挂单价格不优时，则撤单     if order1.status == ""ALIVE"" and api.is_changing(quote) and quote.bid_price1 > order.limit_price:      api.cancel_order(order1, future_account)     # 当期货账户下单成功后, 操作股票账户进行下单     if order1.status == ""FINISHED"" and order1.volume_left == 0:      order2 = api.insert_order(symbol=""SSE.10002504"", direction=""BUY"", volume=volume, account=stock_account)    api.close()    ...   """"""   if not self._account._check_valid(account):    raise Exception(f""多账户模式下, 需要指定账户实例 account"")   if isinstance(order_or_order_id, (Order, SecurityOrder)):    order_id = order_or_order_id.order_id   else:    order_id = order_or_order_id   msg = {    ""aid"": ""cancel_order"",    ""account_key"": self._account._get_account_key(account),    ""user_id"": self._account._get_account_id(account),    ""order_id"": order_id,   }   self._send_pack(msg)  # ----------------------------------------------------------------------  def get_account(self, account: Optional[UnionTradeable] = None) -> Account:   """"""   获取用户账户资金信息   Args:    account (TqAccount/TqKq/TqKqStock/TqSim/TqSimStock): [可选]指定获取账户资金信息的账户实例, 多账户模式下, 该参数必须指定   Returns:    :py:class:`~tqsdk.objs.Account` / :py:class:`~tqsdk.objs.SecurityAccount`: 返回一个账户对象引用. 其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新.    期货账户资金返回对象类型为 :py:class:`~tqsdk.objs.Account`，股票账户资金返回对象类型为 :py:class:`~tqsdk.objs.SecurityAccount`。   Example1::    # 获取当前浮动盈亏    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    account = api.get_account()    print(account.float_profit)    # 预计的输出是这样的:    2180.0    2080.0    2080.0    ...   Example2::    # 多账户模式下, 分别获取各账户浮动盈亏    from tqsdk import TqApi, TqAuth, TqMultiAccount    account1 = TqAccount(""N南华期货"", ""123456"", ""123456"")    account2 = TqAccount(""H宏源期货"", ""111111"", ""123456"")    api = TqApi(TqMultiAccount([account1, account2]), auth=TqAuth(""信易账户"", ""账户密码""))    account_info1 = account1.get_account()    account_info2 = account2.get_account()    print(""账户 1 浮动盈亏 %f, 账户 2 浮动盈亏 %f"", account_info1.float_profit, account_info2.float_profit)    api.close()    # 预计的输出是这样的:    账户 1 浮动盈亏 20580.0, 账户 2 浮动盈亏 -7390.0    ...   """"""   if not self._account._check_valid(account):    raise Exception(f""多账户模式下, 需要指定账户实例 account"")   prototype = self._security_prototype if self._account._is_stock_type(account) else self._prototype   return _get_obj(self._data, [""trade"", self._account._get_account_key(account), ""accounts"", ""CNY""],       prototype[""trade""][""*""][""accounts""][""@""])  # ----------------------------------------------------------------------  def get_position(self, symbol: Optional[str] = None, account: Optional[UnionTradeable] = None) -> Union[Position, Entity]:   """"""   获取用户持仓信息   Args:    symbol (str): [可选]合约代码, 不填则返回所有持仓    account (TqAccount/TqKq/TqKqStock/TqSim/TqSimStock): [可选]指定获取持仓信息的账户实例, 多账户模式下, 必须指定   Returns:    :py:class:`~tqsdk.objs.Position` / :py:class:`~tqsdk.objs.SecurityPosition`: 当指定了 symbol 时, 返回一个持仓对象引用.    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新.    期货账户持仓返回对象类型为 :py:class:`~tqsdk.objs.Position`，股票账户持仓返回对象类型为 :py:class:`~tqsdk.objs.SecurityPosition`。    不填 symbol 参数调用本函数, 将返回包含用户所有持仓的一个tqsdk.objs.Entity对象引用, 使用方法与dict一致, \    其中每个元素的key为合约代码, value为 :py:class:`~tqsdk.objs.Position`。    注意: 为保留一些可供用户查询的历史信息, 如 volume_long_yd(本交易日开盘前的多头持仓手数) 等字段, 因此服务器会返回当天已平仓合约( pos_long 和 pos_short 等字段为0)的持仓信息   Example1::    # 获取 DCE.m1809 当前浮动盈亏    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    position = api.get_position(""DCE.m1809"")    print(position.float_profit_long + position.float_profit_short)    while api.wait_update():     print(position.float_profit_long + position.float_profit_short)    # 预计的输出是这样的:    300.0    330.0    ...   Example2::    # 多账户模式下, 分别获取各账户浮动盈亏    from tqsdk import TqApi, TqAuth, TqMultiAccount    account1 = TqAccount(""N南华期货"", ""123456"", ""123456"")    account2 = TqAccount(""N宏源期货"", ""123456"", ""123456"")    api = TqApi(TqMultiAccount([account1, account2]), auth=TqAuth(""信易账户"", ""账户密码""))    position1 = account1.get_position(""DCE.m2101"")    position2 = account2.get_position(""DCE.m2101"")    print(""账户 1 浮动盈亏 %f, 账户 2 浮动盈亏 %f"", position1.float_profit_long + position2.float_profit_short,     position1.float_profit_long + position2.float_profit_short)    api.close()    # 预计的输出是这样的:    账户 1 浮动盈亏 2140.0, 账户 2 浮动盈亏 0.00    ...   """"""   if not self._account._check_valid(account):    raise Exception(f""多账户模式下, 需要指定账户实例 account"")   prototype = self._security_prototype if self._account._is_stock_type(account) else self._prototype   if symbol:    self._ensure_symbol(symbol)    pos = _get_obj(self._data, [""trade"", self._account._get_account_key(account), ""positions"", symbol],       prototype[""trade""][""*""][""positions""][""@""])    pos.exchange_id = pos.exchange_id if pos.exchange_id else symbol.split('.', maxsplit=1)[0]    pos.instrument_id = pos.instrument_id if pos.instrument_id else symbol.split('.', maxsplit=1)[1]    return pos   return _get_obj(self._data, [""trade"", self._account._get_account_key(account), ""positions""])  # ----------------------------------------------------------------------  def get_order(self, order_id: Optional[str] = None, account: Optional[UnionTradeable] = None) -> Union[Order, Entity]:   """"""   获取用户委托单信息   Args:    order_id (str): [可选]单号, 不填单号则返回所有委托单    account (TqAccount/TqKq/TqKqStock/TqSim/TqSimStock): [可选]指定获取委托单号的账户实例, 多账户模式下, 该参数必须指定   Returns:    :py:class:`~tqsdk.objs.Order` / :py:class:`~tqsdk.objs.SecurityOrder` : 当指定了order_id时, 返回一个委托单对象引用. \    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新.    期货账户委托单返回对象类型为 :py:class:`~tqsdk.objs.Order`，股票账户委托单返回对象类型为 :py:class:`~tqsdk.objs.SecurityOrder`。    不填order_id参数调用本函数, 将返回包含用户所有委托单的一个tqsdk.objs.Entity对象引用, \    使用方法与dict一致, 其中每个元素的key为委托单号, value为 :py:class:`~tqsdk.objs.Order`    注意: 在刚下单后, tqsdk 还没有收到回单信息时, 此对象中各项内容为空   Example1::    # 获取当前总挂单手数    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    orders = api.get_order()    while True:     api.wait_update()     print(sum(order.volume_left for oid, order in orders.items() if order.status == ""ALIVE""))    # 预计的输出是这样的:    3    3    0    ...   Example2::    # 多账户模式下, 分别获取各账户浮动盈亏    from tqsdk import TqApi, TqAuth, TqMultiAccount    account1 = TqAccount(""N南华期货"", ""123456"", ""123456"")    account2 = TqAccount(""N宏源期货"", ""123456"", ""123456"")    api = TqApi(TqMultiAccount([account1, account2]), auth=TqAuth(""信易账户"", ""账户密码""))    orders1 = account1.get_order()    order2 = account2.get_order(order_id=""订单号"")    print(len(orders1), order2.volume_left)    api.close()    # 预计的输出是这样的:    2 0    ...   """"""   prototype = self._security_prototype if self._account._is_stock_type(account) else self._prototype   if order_id:    return _get_obj(self._data, [""trade"", self._account._get_account_key(account), ""orders"", order_id],        prototype[""trade""][""*""][""orders""][""@""])   return _get_obj(self._data, [""trade"", self._account._get_account_key(account), ""orders""])  # ----------------------------------------------------------------------  def get_trade(self, trade_id: Optional[str] = None, account: Optional[UnionTradeable] = None) -> Union[Trade, Entity]:   """"""   获取用户成交信息   Args:    trade_id (str): [可选]成交号, 不填成交号则返回所有委托单    account (TqAccount/TqKq/TqKqStock/TqSim/TqSimStock): [可选]指定获取用户成交信息的账户实例, 多账户模式下, 该参数必须指定   Returns:    :py:class:`~tqsdk.objs.Trade` / :py:class:`~tqsdk.objs.SecurityTrade`: 当指定了trade_id时, 返回一个成交对象引用. \    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新.    期货账户成交返回对象类型为 :py:class:`~tqsdk.objs.Trade`，股票账户成交返回对象类型为 :py:class:`~tqsdk.objs.SecurityTrade`。    不填trade_id参数调用本函数, 将返回包含用户当前交易日所有成交记录的一个tqsdk.objs.Entity对象引用, 使用方法与dict一致, \    其中每个元素的key为成交号, value为 :py:class:`~tqsdk.objs.Trade`    推荐优先使用 :py:meth:`~tqsdk.objs.Order.trade_records` 获取某个委托单的相应成交记录, 仅当确有需要时才使用本函数.   Example::    # 多账户模式下, 分别获取各账户浮动盈亏    from tqsdk import TqApi, TqAuth, TqMultiAccount    account1 = TqAccount(""N南华期货"", ""123456"", ""123456"")    account2 = TqAccount(""N宏源期货"", ""123456"", ""123456"")    api = TqApi(TqMultiAccount([account1, account2]), auth=TqAuth(""信易账户"", ""账户密码""))    trades1 = account1.get_trade()    trades2 = account2.get_trade()    print(len(trades1), len(trades2))    api.close()    # 预计的输出是这样的:    20 55    ...   """"""   prototype = self._security_prototype if self._account._is_stock_type(account) else self._prototype   if trade_id:    return _get_obj(self._data, [""trade"", self._account._get_account_key(account), ""trades"", trade_id],        prototype[""trade""][""*""][""trades""][""@""])   return _get_obj(self._data, [""trade"", self._account._get_account_key(account), ""trades""])  # ----------------------------------------------------------------------  def get_risk_management_rule(self, exchange_id: Optional[str] = None, account: Optional[UnionTradeable] = None) -> \    Union[RiskManagementRule, Entity]:   """"""   获取账户风控统计规则   Args:    exchange_id (str): [可选] 交易所代码, 不填交易所代码则返回所有交易所风控规则    目前支持设置风控规则的交易所 SSE（上海证券交易所）、SZSE（深圳证券交易所）   Returns:    :py:class:`~tqsdk.objs.RiskManagementRule`: 当指定了 exchange_id 时, 返回该交易所的风控统计规则对象的引用.    不填 exchange_id 参数调用本函数, 将返回包含所有交易所风控规则的一个 tqsdk.objs.Entity 对象引用, 使用方法与dict一致, \    其中每个元素的 key 为交易所代码, value为 :py:class:`~tqsdk.objs.RiskManagementRule`。   Example::    from tqsdk import TqApi, TqAuth, TqAccount    api = TqApi(TqAccount(""H海通期货"", ""022631"", ""123456""), auth=TqAuth(""信易账户"", ""账户密码""))    rule = api.get_risk_management_rule(exchange_id=""SSE"")    print(exchange_id, rule['enable'])    print(""自成交限制:"", rule.self_trade)    print(""频繁报撤单限制:"", rule.frequent_cancellation)    print(""成交持仓比限制:"", rule.trade_position_ratio)    api.close()   """"""   if exchange_id:    if exchange_id not in [""SSE"", ""SZSE""]:     raise Exception(f""{exchange_id} 不支持设置风控规则，只有 SSE，SZSE 支持"")    return _get_obj(self._data, [""trade"", self._account._get_account_key(account), ""risk_management_rule"", exchange_id],        RiskManagementRule(self))   else:    return _get_obj(self._data, [""trade"", self._account._get_account_key(account), ""risk_management_rule""])  # ----------------------------------------------------------------------  def set_risk_management_rule(self, exchange_id: str, enable: bool, count_limit: int = None, insert_order_count_limit: Optional[int] = None,         cancel_order_count_limit: Optional[int] = None, cancel_order_percent_limit: Optional[float] = None,         trade_units_limit: Optional[int] = None, trade_position_ratio_limit: Optional[float] = None,         account: Optional[UnionTradeable] = None) -> Optional[RiskManagementRule]:   """"""   设置交易所风控规则. **注意: 指令将在下次调用** :py:meth:`~tqsdk.api.TqApi.wait_update` **时发出**   调用本函数时，没有填写的可选参数会被服务器设置为默认值。   Args:    exchange_id (str): 交易所代码, ""SSE"" 或者 ""SZSE""    enable (bool): 是否启用该规则    count_limit (int): [可选]最大自成交次数限制，如果未填写，服务器将根据交易所不同赋不同的默认值。    insert_order_count_limit (int): [可选]频繁报撤单起算报单次数，如果未填写，服务器将根据交易所不同赋不同的默认值。    cancel_order_count_limit (int): [可选]频繁报撤单起算撤单次数，如果未填写，服务器将根据交易所不同赋不同的默认值。    cancel_order_percent_limit (float): [可选]频繁报撤单撤单比例限额，为百分比，如果未填写，服务器将根据交易所不同赋不同的默认值。    trade_units_limit (int): [可选]成交持仓比起算成交手数，如果未填写，服务器将根据交易所不同赋不同的默认值。    trade_position_ratio_limit (float): [可选]成交持仓比例限额，为百分比，如果未填写，服务器将根据交易所不同赋不同的默认值，持仓数为该合约的净持仓。   Returns:    :py:class:`~tqsdk.objs.RiskManagementRule`: 返回一个风控规则对象引用. 其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新.   Example::    from tqsdk import TqApi, TqAuth, TqAccount    api = TqApi(TqAccount(""H海通期货"", ""022631"", ""123456""), auth=TqAuth(""信易账户"", ""账户密码""))    # 开启 SSE 风控限制    api.set_risk_management_rule(exchange_id=""SSE"", enable=True)    api.wait_update() # 真正把设置规则数据包发送到服务器    rule = api.get_risk_management_rule(exchange_id=""SSE"")    print(rule)    api.close()   """"""   if account is not None and type(account) is not TqAccount:    self._print(""模拟账户不支持设置风控规则"", ""WARNING"")    return None   if exchange_id not in [""SSE"", ""SZSE""]:    raise Exception(f""{exchange_id} 不支持设置风控规则，只有 SSE，SZSE 支持"")   rule_pack = {    ""aid"": ""set_risk_management_rule"",    ""account_key"": self._account._get_account_key(account),    ""user_id"": self._account._get_account_id(account),    ""exchange_id"": exchange_id,    ""enable"": enable,    ""self_trade"": {},    ""frequent_cancellation"": {},    ""trade_position_ratio"": {}   }   if count_limit is not None: # 最大自成交次数限制    rule_pack[""self_trade""][""count_limit""] = int(count_limit)   if insert_order_count_limit is not None: # 频繁报撤单起算报单次数    rule_pack[""frequent_cancellation""][""insert_order_count_limit""] = int(insert_order_count_limit)   if cancel_order_count_limit is not None: # 频繁报撤单起算撤单次数    rule_pack[""frequent_cancellation""][""cancel_order_count_limit""] = int(cancel_order_count_limit)   if cancel_order_percent_limit is not None: # 频繁报撤单撤单比例限额，为百分比    rule_pack[""frequent_cancellation""][""cancel_order_percent_limit""] = float(cancel_order_percent_limit)   if trade_units_limit is not None: # 成交持仓比起算成交手数    rule_pack[""trade_position_ratio""][""trade_units_limit""] = int(trade_units_limit)   if trade_position_ratio_limit is not None: # 成交持仓比例限额，为百分比    rule_pack[""trade_position_ratio""][""trade_position_ratio_limit""] = float(trade_position_ratio_limit)   self._send_pack(copy.deepcopy(rule_pack))   del rule_pack[""aid""]   rule = _get_obj(self._data, [""trade"", self._account._get_account_key(account), ""risk_management_rule"", exchange_id], RiskManagementRule(self))   if not self._loop.is_running():    deadline = time.time() + 30    while not (rule_pack['enable'] == rule['enable']      and rule_pack['self_trade'].items() <= rule['self_trade'].items()      and rule_pack['frequent_cancellation'].items() <= rule['frequent_cancellation'].items()      and rule_pack['trade_position_ratio'].items() <= rule['trade_position_ratio'].items()):     # @todo: merge diffs     if not self.wait_update(deadline=deadline):      raise TqTimeoutError(""设置风控规则超时请检查客户端及网络是否正常"")   return rule  # ----------------------------------------------------------------------  def get_risk_management_data(self, symbol: Optional[str] = None, account: Optional[UnionTradeable] = None) -> \    Union[RiskManagementData, Entity]:   """"""   获取账户风控统计数据   Args:    symbol (str): [可选]合约代码, 不填合约代码则返回账户下所有持仓合约的风控统计数据   Returns:    :py:class:`~tqsdk.objs.RiskManagementData`: 当指定了 symbol 时, 返回该合约下的风控统计数据对象引用.    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新.    不填 symbol 参数调用本函数, 将返回包含用户所有持仓合约的一个 tqsdk.objs.Entity 对象引用, 使用方法与 dict 一致, \    其中每个元素的 key 为合约代码, value为 :py:class:`~tqsdk.objs.RiskManagementData`。   """"""   if symbol:    return _get_obj(self._data, [""trade"", self._account._get_account_key(account), ""risk_management_data"", symbol], RiskManagementData(self))   else:    return _get_obj(self._data, [""trade"", self._account._get_account_key(account), ""risk_management_data""])  # ----------------------------------------------------------------------  def wait_update(self, deadline: Optional[float] = None, _task: Union[asyncio.Task, List[asyncio.Task], None] = None) -> bool:   """"""   等待业务数据更新   调用此函数将阻塞当前线程, 等待天勤主进程发送业务数据更新并返回   注: 它是TqApi中最重要的一个函数, 每次调用它时都会发生这些事:    * 实际发出网络数据包(如行情订阅指令或交易指令等).    * 尝试从服务器接收一个数据包, 并用收到的数据包更新内存中的业务数据截面.    * 让正在运行中的后台任务获得动作机会(如策略程序创建的后台调仓任务只会在wait_update()时发出交易指令).    * 如果没有收到数据包，则挂起等待.   Args:    deadline (float): [可选]指定截止时间，自unix epoch(1970-01-01 00:00:00 GMT)以来的秒数(time.time())。默认没有超时(无限等待)   Returns:    bool: 如果收到业务数据更新则返回 True, 如果到截止时间依然没有收到业务数据更新则返回 False   注意:    * 由于存在网络延迟, 因此有数据更新不代表之前发出的所有请求都被处理了, 例如::     from tqsdk import TqApi, TqAuth     api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))     quote = api.get_quote(""SHFE.cu1812"")     api.wait_update()     print(quote.datetime)    可能输出 """"(空字符串), 表示还没有收到该合约的行情   """"""   if self._loop.is_running():    raise Exception(""不能在协程中调用 wait_update, 如需在协程中等待业务数据更新请使用 register_update_notify"")   elif asyncio._get_running_loop():    raise Exception(     ""TqSdk 使用了 python3 的原生协程和异步通讯库 asyncio，您所使用的 IDE 不支持 asyncio, 请使用 pycharm 或其它支持 asyncio 的 IDE"")   self._wait_timeout = False   # 先尝试执行各个task,再请求下个业务数据，可能用户的同步代码会在 chan 中 send 数据，需要先 run_tasks   self._run_until_idle(async_run=False)   # 用户可能在同步或者异步代码中修改 klines 附加列的值   # 同步代码：此次调用 wait_update 之前应该已经修改执行   # 异步代码：上一行 self._run_until_idle() 可能会修改 klines 附加列的值   # 所以放在这里处理， 总会发送 serial_extra_array 数据，由 TqWebHelper 处理   for _, serial in self._serials.items():    self._process_serial_extra_array(serial)   self._run_until_idle(async_run=False) # 这里 self._run_until_idle() 主要为了把上一步计算出得需要绘制的数据发送到 TqWebHelper   if _task is not None:    # 如果 _task 已经 done，则提前返回 True, False 代表超时会抛错    _tasks = _task if isinstance(_task, list) else [_task]    if all([t.done() for t in _tasks]):     return True   if not self._is_slave and not self._pending_peek:    self._send_chan.send_nowait({     ""aid"": ""peek_message""    })    self._pending_peek = True   # 先 _fetch_msg 再判断 deadline, 避免当 deadline 立即触发时无法接收数据   update_task = self.create_task(self._fetch_msg())   try:    self._run_until_task_done(task=update_task, deadline=deadline)    return len(self._pending_diffs) != 0   finally:    if len(self._pending_diffs) > 0:     self._diffs = self._pending_diffs     self._sync_diffs = (self._sync_diffs if _task else []) + self._pending_diffs     self._pending_diffs = []     # 清空K线更新范围，避免在 wait_update 未更新K线时仍通过 is_changing 的判断     self._klines_update_range = {}     for d in self._diffs:      # 判断账户类别, 对股票和期货的 trade 数据分别进行处理      if ""trade"" in d:       for k, v in d.get('trade').items():        prototype = self._security_prototype if self._account._is_stock_type(k) else self._prototype        _merge_diff(self._data, {'trade': {k: v}}, prototype, persist=False, reduce_diff=True)      # 非交易数据均按照期货处理逻辑      diff_without_trade = {k: v for k, v in d.items() if k != ""trade""}      if diff_without_trade:       _merge_diff(self._data, diff_without_trade, self._prototype, persist=False, reduce_diff=True)     self._risk_manager._on_recv_data(self._diffs)     for _, serial in self._serials.items():      # K线df的更新与原始数据、left_id、right_id、more_data、last_id相关，其中任何一个发生改变都应重新计算df      # 注：订阅某K线后再订阅合约代码、周期相同但长度更短的K线时, 服务器不会再发送已有数据到客户端，即chart发生改变但内存中原始数据未改变。      # 检测到K线数据或chart的任何字段发生改变则更新serial的数据      if self._is_obj_changing(serial[""df""], diffs=self._diffs, key=[]) \        or self._is_obj_changing(serial[""chart""], diffs=self._diffs, key=[]):       if len(serial[""root""]) == 1: # 订阅单个合约        self._update_serial_single(serial)       else: # 订阅多个合约        self._update_serial_multi(serial)  # ----------------------------------------------------------------------  def is_changing(self, obj: Any, key: Union[str, List[str], None] = None) -> bool:   """"""   判定obj最近是否有更新   当业务数据更新导致 wait_update 返回后可以使用该函数判断 **本次业务数据更新是否包含特定obj或其中某个字段** 。   关于判断K线更新的说明：   当生成新K线时，其所有字段都算作有更新，若此时执行 api.is_changing(klines.iloc[-1]) 则一定返回True。   Args:    obj (any): 任意业务对象, 包括 get_quote 返回的 quote, get_kline_serial 返回的 k_serial, get_account 返回的 account 等    key (str/list of str): [可选]需要判断的字段，默认不指定         * 不指定: 当该obj下的任意字段有更新时返回True, 否则返回 False.         * str: 当该obj下的指定字段有更新时返回True, 否则返回 False.         * list of str: 当该obj下的指定字段中的任何一个字段有更新时返回True, 否则返回 False.   Returns:    bool: 如果本次业务数据更新包含了待判定的数据则返回 True, 否则返回 False.   Example::    # 追踪 SHFE.cu1812 的最新价更新    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SHFE.cu1812"")    print(quote.last_price)    while True:     api.wait_update()     if api.is_changing(quote, ""last_price""):      print(quote.last_price)    # 以上代码运行后的输出是这样的:    51800.0    51810.0    51800.0    ...   """"""   if obj is None:    return False   # is_changing 区分同步 / 异步中，根据不同的 diffs 判断   diffs = self._diffs if self._loop.is_running() else self._sync_diffs   if not isinstance(key, list):    key = [key] if key else []   if isinstance(obj, list):    for o in obj:     if self._is_obj_changing(o, diffs=diffs, key=key):      return True   else:    return self._is_obj_changing(obj, diffs=diffs, key=key)  def _is_obj_changing(self, obj: Any, diffs: List[Dict[str, Any]], key: List[str]) -> bool:   try:    if isinstance(obj, pd.DataFrame):     if id(obj) in self._serials:      paths = []      for root in self._serials[id(obj)][""root""]:       paths.append(root[""_path""])     elif len(obj) == 0:      return False     else: # 处理传入的为一个 copy 出的 DataFrame (与原 DataFrame 数据相同的另一个object)      duration = int(obj[""duration""].iloc[0]) * 1000000000      paths = [       [""klines"", obj[k].iloc[0], str(duration)] if duration != 0 else [""ticks"", obj[""symbol""].iloc[0]]       for k in obj.keys() if k.startswith(""symbol"")]    elif isinstance(obj, pd.Series):     ins_list = [v for k, v in obj.items() if k.startswith(""symbol"")]     if len(ins_list) > 1: # 如果是K线的Series      # 处理：一根新K线的数据被拆分到多个数据包中时 diff 中只有最后一个包的数据，      # 则 is_changing 无法根据前面数据包中的字段来判断K线有更新(仅在生成多合约新K线时产生此问题),因此：用_klines_update_range记录/判定更新      new_kline_range = self._klines_update_range.get(       (ins_list[0], tuple(ins_list[1:]), obj[""duration""] * 1000000000), (0, 0))      if obj[""id""] >= new_kline_range[0] and obj[""id""] < new_kline_range[1]: # 保持左闭右开规范       return True     duration = int(obj[""duration""]) * 1000000000     paths = []     if duration != 0:      for i in range(0, len(ins_list)):       # pandas的key值序列会保持固定顺序, 则ins_list[i]对应的是""id""+str(i)，否则不成立。 todo:增加测试用例以保证其顺序一致，若不再顺序一致则修改此处用法       key_id = ""id"" + str(i) if i != 0 else ""id""       if key_id in obj.keys():        paths.append([""klines"", ins_list[i], str(duration), ""data"", str(int(obj[key_id]))])       else:        paths.append([""klines"", ins_list[i], str(duration), ""data"", str(-1)])     else:      paths.append([""ticks"", obj[""symbol""], ""data"", str(int(obj[""id""]))])    else:     paths = [obj[""_path""]]   except (KeyError, IndexError):    return False   for diff in diffs:    # 如果传入key：生成一个dict（key:序号，value: 字段）, 遍历这个dict并在_is_key_exist()判断key是否存在    if (isinstance(obj, pd.DataFrame) or isinstance(obj, pd.Series)) and len(key) != 0:     k_dict = {}     for k in key:      if k not in obj.index:       continue      m = re.match(r'(.*?)(\d+)$', k) # 匹配key中的数字      if m is None: # 无数字       k_dict.setdefault(0, []).append(k)      elif int(m.group(2)) < len(paths):       m_k = int(m.group(2))       k_dict.setdefault(m_k, []).append(m.group(1))     for k_id, v in k_dict.items():      if _is_key_exist(diff, paths[k_id], v):       return True    else: # 如果没有传入key：遍历所有path     for path in paths:      if _is_key_exist(diff, path, key):       return True   return False  # ----------------------------------------------------------------------  def is_serial_ready(self, obj: pd.DataFrame) -> bool:   """"""   判断是否已经从服务器收到了所有订阅的数据   Args:    obj (pandas.Dataframe): K线数据   Returns:    bool: 返回 True 表示已经从服务器收到了所有订阅的数据   Example::    # 判断是否已经从服务器收到了最后 3000 根 SHFE.cu1812 的分钟线数据    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    klines = api.get_kline_serial(""SHFE.cu1812"", 60, data_length=3000)    while True:     api.wait_update()     print(api.is_serial_ready(klines))    # 预计的输出是这样的:    False    False    True    True    ...   """"""   return self._serials[id(obj)][""init""]  # ----------------------------------------------------------------------  def create_task(self, coro: Coroutine, _caller_api: bool = False) -> asyncio.Task:   """"""   创建一个task   一个task就是一个协程，task的调度是在 wait_update 函数中完成的，如果代码从来没有调用 wait_update，则task也得不到执行   Args:    coro (coroutine): 需要创建的协程   Example::    # 一个简单的task    import asyncio    from tqsdk import TqApi, TqAuth    async def hello():     await asyncio.sleep(3)     print(""hello world"")    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    api.create_task(hello())    while True:     api.wait_update()    #以上代码将在3秒后输出    hello world   """"""   return super(TqApi, self)._create_task(coro=coro, _caller_api=_caller_api)  # ----------------------------------------------------------------------  def register_update_notify(self, obj: Optional[Any] = None, chan: Optional[TqChan] = None) -> TqChan:   """"""   注册一个channel以便接受业务数据更新通知   调用此函数将返回一个channel, 当obj更新时会通知该channel   推荐使用 async with api.register_update_notify() as update_chan 来注册更新通知   如果直接调用 update_chan = api.register_update_notify() 则使用完成后需要调用 await update_chan.close() 避免资源泄漏   Args:    obj (any/list of any): [可选]任意业务对象, 包括 get_quote 返回的 quote, get_kline_serial 返回的 k_serial, \    get_account 返回的 account 等。默认不指定，监控所有业务对象    chan (TqChan): [可选]指定需要注册的channel。默认不指定，由本函数创建   Example::    # 获取 SHFE.cu1812 合约的报价    from tqsdk import TqApi, TqAuth    async def demo():     quote = api.get_quote(""SHFE.cu1812"")     async with api.register_update_notify(quote) as update_chan:      async for _ in update_chan:       print(quote.last_price)    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    api.create_task(demo())    while True:     api.wait_update()    #以上代码将输出    nan    51850.0    51850.0    51690.0    ...   """"""   if chan is None:    chan = TqChan(self, last_only=True)   if not isinstance(obj, list):    obj = [obj] if obj is not None else [self._data]   registing_objs = []   for o in obj:    if isinstance(o, pd.DataFrame):     for root in self._serials[id(o)][""root""]:      registing_objs.append(root)    else:     registing_objs.append(o)   return _register_update_chan(registing_objs, chan)  # ----------------------------------------------------------------------  def query_graphql(self, query: str, variables: dict, query_id: Optional[str] = None) -> Entity:   """"""   发送基于 GraphQL 的合约服务请求查询，在同步代码中返回查询结果；异步代码中返回查询结果的引用地址。   Args:    query (str): [必填] 查询语句    variables (dict): [必填] 查询语句对应的参数取值    query_id (str): [可选] 查询请求 id   Returns:    :py:class:`~tqsdk.entity.Entity`: 返回查询结果的对象引用。     其的结构为 {query: """", variables: {}, result: {}}     query 和 variables 为发送请求时传入的参数，result 为查询结果   Example::    # 查询 ""SHFE.au2012"" 对应的全部期权    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    variables = {     ""derivative_class"": [""OPTION""],     ""underlying_symbol"": [""SHFE.au2012""]    }    query = '''      query($derivative_class:[Class], $underlying_symbol:[String]){       multi_symbol_info(instrument_id:$underlying_symbol){        ... on basic { instrument_id         derivatives (class: $derivative_class) {          edges { node { ... on basic{ instrument_id}} }         }        }       }      }      '''    res = api.query_graphql(query, variables)    print(res[""result""])   """"""   if self._stock is False:    raise Exception(""不支持（_stock is False）当前接口调用"")   for k, v in variables.items():    if v == """" or isinstance(v, list) and (any([s == """" for s in v]) or len(v) == 0):     raise Exception(f""variables 中变量值不支持空字符串、空列表或者列表中包括空字符串。"")   pack = {    ""query"": query,    ""variables"": variables   }   symbols = _get_obj(self._data, [""symbols""])   for symbol_query in symbols.values():    if symbol_query.items() >= pack.items(): # 检查是否发送过相同的请求     return symbol_query   query_id = _generate_uuid(""PYSDK_api"") if query_id is None else query_id   self._send_pack({    ""aid"": ""ins_query"",    ""query_id"": query_id,    ""query"": query,    ""variables"": variables   })   deadline = time.time() + 60   if not self._loop.is_running():    while query_id not in symbols:     if not self.wait_update(deadline=deadline):      raise TqTimeoutError(""查询合约服务 %s 超时，请检查客户端及网络是否正常 %s"" % (query, query_id))    if isinstance(self._backtest, TqBacktest):     self._send_pack({      ""aid"": ""ins_query"",      ""query_id"": query_id,      ""query"": """",      ""variables"": {}     })   return _get_obj(self._data, [""symbols"", query_id])  def query_symbol_ranking(self, symbol: str, ranking_type: str, days: int = 1, start_dt: date = None, broker: str = None)\    -> TqSymbolRankingDataFrame:   """"""   查询合约成交排名/持仓排名   本接口仅限专业版用户使用，如需购买专业版或者申请试用，请访问 https://www.shinnytech.com/tqsdk_professional/。   该函数返回的对象不会更新，不建议在循环内调用该方法。   Args:    symbol (str): [必填] 合约代码    ranking_type (str)：[必填] 表示返回结果以哪一项为排名基准，VOLUME 成交量排名，LONG 多头持仓排名, SHORT 空头持仓排名    days (int): [必填] 返回结果中包含的天数，默认为 1    start_dt (date): [可选] 查询时间段开始日期，默认为 None     * 如果开始日期为 date 类型，则返回从开始日期之后 days 个交易日的有效数据     * 如果开始日期为 None，则返回最近 days 个交易日的持仓排名情况    broker (str): [可选] 指定期货公司，以各家交易所列出的期货公司名称为准来进行查询，各家交易所可能期货公司名称不一致，如果对应这一天这家交易所没数据则返回对应数值为nan   Returns:    pandas.DataFrame: 本函数返回 pandas.DataFrame 实例。行数为 days * 20，每行为一条成交量/多头持仓量/空头持仓量的排名信息。返回值不会再更新。包含以下列:    * datetime (查询日期)    * symbol (合约代码，以交易所列出的期货公司名称为准)    * exchange_id (交易所)    * instrument_id (交易所内合约代码)    * broker (期货公司)    * volume (成交量)    * volume_change (成交量变化)    * volume_ranking (成交量排名)    * long_oi (多头持仓量)    * long_change (多头持仓增减量)    * long_ranking (多头持仓量排名)    * short_oi (空头持仓量)    * short_change (空头持仓增减量)    * short_ranking (空头持仓量排名)    注意:    1. 返回值中 datetime、symbol、exchange_id、instrument_id、broker 这几列一定为有效值。其他列会根据不同的 ranking_type 参数值，可能返回 nan：     * 例如：当 ranking_type 参数值为 volume_ranking 时，volume、volume_change、volume_ranking 这三列为有效值；      如果该期货公司的 long_ranking 在前 20 名内，long_oi、long_change、long_ranking 这三列为有效值，否则为 nan。      如果该期货公司的 short_ranking 在前 20 名内，short_oi、short_change、short_ranking 这三列为有效值，否则为 nan。    2. 数据更新时间: 18:30~19:00。 用户在交易日 19:00 之前可以查询当前交易日之前的所有数据，19:00 之后可以查询包括当前交易日的数据。    3. 数据支持范围：从 20200720 开始的期货数据。   Example::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    df = api.query_symbol_ranking(""SHFE.cu2109"", ranking_type='VOLUME')    print(df.to_string()) # 最近 1 天持仓排名信息，以成交量排序    df = api.query_symbol_ranking(""SHFE.cu2109"", ranking_type='LONG', days=3)    print(df.to_string()) # 最近 3 天持仓排名信息，以多头持仓量排序    api.close()   """"""   if not isinstance(symbol, str) or symbol == """":    raise Exception(f""symbol 参数应该填入有效的合约代码。"")   if ranking_type not in ['VOLUME', 'LONG', 'SHORT']:    raise Exception(f""ranking_type 参数只支持以下值： 'VOLUME', 'LONG', 'SHORT'。"")   if not (start_dt is None or isinstance(start_dt, date)):    raise Exception(f""start_dt 参数类型 {type(start_dt)} 错误。"")   if not (isinstance(days, int) or days <= 1):    raise Exception(f""days 参数 {days} 错误。"")   if not (broker is None or isinstance(broker, str)):    raise Exception(f""str 参数类型 {type(str)} 错误。"")   df = TqSymbolRankingDataFrame(self, symbol, ranking_type, days=days, start_dt=start_dt, broker=broker)   deadline = time.time() + 30   while not self._loop.is_running() and not df.__dict__[""_task""].done():    if not self.wait_update(deadline=deadline, _task=df.__dict__[""_task""]):     raise TqTimeoutError(f""获取 {symbol}, {ranking_type} 持仓排名信息信息超时，请检查客户端及网络是否正常"")   return df  def query_quotes(self, ins_class: str = None, exchange_id: str = None, product_id: str = None, expired: bool = None,      has_night: bool = None) -> SymbolList:   """"""   根据相应的参数发送合约服务请求查询，并返回查询结果   Args:    ins_class (str): [可选] 合约类型     * FUTURE: 期货     * CONT: 主连     * COMBINE: 组合     * INDEX: 指数     * OPTION: 期权     * STOCK: 股票    exchange_id (str): [可选] 交易所     * CFFEX: 中金所     * SHFE: 上期所     * DCE: 大商所     * CZCE: 郑商所     * INE: 能源交易所(原油)     * SSE: 上交所     * SZSE: 深交所    product_id (str): [可选] 品种（股票、期权不能通过 product_id 筛选查询）    expired (bool): [可选] 是否已下市    has_night (bool): [可选] 是否有夜盘，默认为 None。     * None 表示筛选结果既包括有夜盘品种也包括无夜盘品种     * True 表示筛选结果只包括有夜盘品种     * False 表示筛选结果只包括无夜盘品种   Returns:    list: 符合筛选条件的合约代码的列表，例如: [""SHFE.cu2012"", ""SHFE.au2012"", ""SHFE.wr2012""]   Example::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    # 不推荐使用以下方式获取符合某种条件的合约列表，推荐使用接口来完成此功能。    # ls = [k for k,v in api._data[""quotes""].items() if k.startswith(""KQ.m"")]    # print(ls)    ls = api.query_quotes(ins_class=""FUTURE"", product_id=""au"")    print(ls) # au 品种的全部合约，包括已下市以及未下市合约    ls = api.query_quotes(ins_class=""INDEX"", product_id=""au"")    print(ls) # au 品种指数合约    ls = api.query_quotes(ins_class=""CONT"")    print(ls) # 全部主连合约    ls = api.query_quotes(ins_class=""CONT"", product_id=""au"")    print(ls) # au 品种主连合约    ls = api.query_quotes(ins_class=""FUTURE"", exchange_id=""SHFE"", has_night=True)    print(ls) # 上期所带夜盘的期货合约列表    ls = api.query_quotes(product_id=""au"", expired=False)    print(ls) # au 品种的全部未下市合约、指数、主连    ls = api.query_quotes(ins_class=""STOCK"", exchange_id=""SSE"", expired=False)    print(ls) # 上海交易所股票代码列表    ls = api.query_quotes(ins_class=""FUND"", exchange_id=""SSE"", expired=False)    print(ls) # 上海交易所基金代码列表   """"""   if self._stock is False:    raise Exception(""期货行情系统(_stock = False)不支持当前接口调用"")   variables = {}   if ins_class is not None:    if ins_class == """":     raise Exception(""ins_class 参数不能为空字符串。"")    variables[""class_""] = [ins_class]   if exchange_id is not None:    if exchange_id == """":     raise Exception(""exchange_id 参数不能为空字符串。"")    # 如果是主连和指数，请求全部，在客户端区分交易所    if ins_class not in [""INDEX"", ""CONT""] or exchange_id not in [""CFFEX"", ""SHFE"", ""DCE"", ""CZCE"", ""INE""]:     variables[""exchange_id""] = [exchange_id]   if product_id is not None:    if product_id == """":     raise Exception(""product_id 参数不能为空字符串。"")    variables[""product_id""] = [product_id]   if expired is not None:    variables[""expired""] = expired   if has_night is not None:    variables[""has_night""] = has_night   if isinstance(self._backtest, TqBacktest):    variables[""timestamp""] = int(self._get_current_datetime().timestamp() * 1e9)   op = Operation(ins_schema.rootQuery)   query = op.multi_symbol_info(**variables)   query.__as__(basic).instrument_id()   def filter(query_result):    result = []    for quote in query_result.get(""result"", {}).get(""multi_symbol_info"", []):     if ins_class in [""INDEX"", ""CONT""] and exchange_id in [""CFFEX"", ""SHFE"", ""DCE"", ""CZCE"", ""INE""]:      if exchange_id in quote[""instrument_id""]:       result.append(quote[""instrument_id""])     else:      result.append(quote[""instrument_id""])    return result   return self._get_symbol_list(query=op.__to_graphql__(), filter=filter)  def _get_symbol_list(self, query: str, filter: Callable[[dict], list]) -> SymbolList:   result = SymbolList(self, query_id=_generate_uuid(""PYSDK_api""), query=query, filter=filter)   if not self._loop.is_running():    deadline = time.time() + 30    while not result._task.done():     if not self.wait_update(deadline=deadline, _task=result._task):      raise TqTimeoutError(f""查询合约服务 {query} 超时，请检查客户端及网络是否正常"")   return result  def query_cont_quotes(self, exchange_id: str = None, product_id: str = None, has_night: bool = None) -> SymbolList:   """"""   根据填写的参数筛选，返回主力连续合约对应的标的合约列表   Args:    exchange_id (str): [可选] 交易所     * CFFEX: 中金所     * SHFE: 上期所     * DCE: 大商所     * CZCE: 郑商所     * INE: 能源交易所(原油)    product_id (str): [可选] 品种    has_night (bool / None): [可选] 是否有夜盘，默认为 None。     * None 表示筛选结果既包括有夜盘品种也包括无夜盘品种     * True 表示筛选结果只包括有夜盘品种     * False 表示筛选结果只包括无夜盘品种   Returns:    list: 符合筛选条件的合约代码的列表，例如: [""SHFE.cu2012"", ""SHFE.au2012"", ""SHFE.wr2012""]   Example1::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    ls = api.query_cont_quotes()    print(ls) # 全部主连合约对应的标的合约    ls = api.query_cont_quotes(exchange_id=""DCE"")    print(ls) # 大商所主连合约对应的标的合约    ls = api.query_cont_quotes(product_id=""jd"")    print(ls) # jd 品种主连合约对应的标的合约   Example2::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    print(api.query_cont_quotes(exchange_id=""DCE"", has_night=True))    print(api.query_cont_quotes(exchange_id=""DCE"", has_night=False))    print(api.query_cont_quotes(exchange_id=""DCE""))    api.close()    # 输出应该如下所示    ['DCE.c2105', 'DCE.m2105', 'DCE.rr2105', 'DCE.b2105', 'DCE.jm2105', 'DCE.pp2105', 'DCE.i2105', 'DCE.cs2105', 'DCE.eb2105', 'DCE.l2105', 'DCE.v2105', 'DCE.pg2104', 'DCE.eg2105', 'DCE.p2105', 'DCE.a2105', 'DCE.y2105', 'DCE.j2105']    ['DCE.bb2105', 'DCE.jd2105', 'DCE.fb2105', 'DCE.lh2109']    ['DCE.y2105', 'DCE.j2105', 'DCE.jd2105', 'DCE.c2105', 'DCE.m2105', 'DCE.rr2105', 'DCE.b2105', 'DCE.jm2105', 'DCE.fb2105', 'DCE.pp2105', 'DCE.lh2109', 'DCE.i2105', 'DCE.cs2105', 'DCE.eb2105', 'DCE.l2105', 'DCE.v2105', 'DCE.pg2104', 'DCE.eg2105', 'DCE.p2105', 'DCE.bb2105', 'DCE.a2105']   """"""   if self._stock is False:    raise Exception(""期货行情系统(_stock = False)不支持当前接口调用"")   variables = {""class_"": [""CONT""]}   if has_night is not None:    variables[""has_night""] = has_night   if isinstance(self._backtest, TqBacktest):    variables[""timestamp""] = int(self._get_current_datetime().timestamp() * 1e9)   op = Operation(ins_schema.rootQuery)   query = op.multi_symbol_info(**variables)   query.__as__(basic).instrument_id()   query.__as__(derivative).underlying().edges().node().__as__(basic).instrument_id()   query.__as__(derivative).underlying().edges().node().__as__(basic).exchange_id()   query.__as__(derivative).underlying().edges().node().__as__(future).product_id()   def filter(query_result):    result = []    for quote in query_result.get(""result"", {}).get(""multi_symbol_info"", []):     if quote.get(""underlying""):      for edge in quote[""underlying""][""edges""]:       underlying_quote = edge[""node""]       if (exchange_id and underlying_quote[""exchange_id""] != exchange_id) \         or (product_id and underlying_quote[""product_id""] != product_id):        continue       result.append(underlying_quote[""instrument_id""])    return result   return self._get_symbol_list(query=op.__to_graphql__(), filter=filter)  def query_options(self, underlying_symbol: str, option_class: str = None, exercise_year: int = None,      exercise_month: int = None, strike_price: float = None, expired: bool = None, has_A: bool = None,      **kwargs) -> SymbolList:   """"""   发送合约服务请求查询，查询符合条件的期权列表，并返回查询结果   Args:    underlying_symbol (str): 标的合约    option_class (str): [可选] 期权类型     * CALL: 看涨期权     * PUT: 看跌期权    exercise_year (int): [可选] 最后行权日年份    exercise_month (int): [可选] 最后行权日月份    strike_price (float): [可选] 行权价格    expired (bool): [可选] 是否下市    has_A (bool): [可选] 是否含有A，输入True代表只含A的期权，输入False代表不含A的期权，默认为None不做区分   Returns:    list: 符合筛选条件的合约代码的列表，例如: [""SHFE.cu2012C24000"", ""SHFE.cu2012P24000""]   Example::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    ls = api.query_options(""SHFE.au2012"")    print(ls) # 标的为 ""SHFE.au2012"" 的所有期权    ls = api.query_options(""SHFE.au2012"", option_class=""PUT"")    print(ls) # 标的为 ""SHFE.au2012"" 的看跌期权    ls = api.query_options(""SHFE.au2012"", option_class=""PUT"", expired=False)    print(ls) # 标的为 ""SHFE.au2012"" 的看跌期权, 未下市的    ls = api.query_options(""SHFE.au2012"", strike_price=340)    print(ls) # 标的为 ""SHFE.au2012"" 、行权价为 340 的期权    ls = api.query_options(""SSE.000300"")    print(ls) # 中金所沪深300股指期权    ls = api.query_options(""SSE.510300"")    print(ls) # 上交所沪深300etf期权    ls = api.query_options(""SSE.510300"", exercise_year=2020, exercise_month=12)    print(ls) # 上交所沪深300etf期权, 限制条件 2020 年 12 月份行权   """"""   if self._stock is False:    raise Exception(""期货行情系统(_stock = False)不支持当前接口调用"")   query = self._query_options_by_underlying(underlying_symbol)   def filter(query_result):    options = []    exe_year = exercise_year if exercise_year else kwargs.get(""delivery_year"")    exe_month = exercise_month if exercise_month else kwargs.get(""delivery_month"")    for quote in query_result.get(""result"", {}).get(""multi_symbol_info"", []):     if quote.get(""derivatives""):      for edge in quote[""derivatives""][""edges""]:       option = edge[""node""]       if (option_class and option[""call_or_put""] != option_class) \         or (exe_year and datetime.fromtimestamp(        option[""last_exercise_datetime""] / 1e9).year != exe_year) \         or (exe_month and datetime.fromtimestamp(        option[""last_exercise_datetime""] / 1e9).month != exe_month) \         or (strike_price and option[""strike_price""] != strike_price) \         or (expired is not None and option[""expired""] != expired) \         or (has_A is True and option[""english_name""].count('A') == 0) \         or (has_A is False and option[""english_name""].count('A') > 0):        continue       options.append(option[""instrument_id""])    return options   return self._get_symbol_list(query=query, filter=filter)  def query_atm_options(self, underlying_symbol, underlying_price, price_level, option_class, exercise_year: int = None,       exercise_month: int = None, has_A: bool = None) -> SymbolList:   """"""   Args:    underlying_symbol (str): [必填] 标的合约 （目前每个标的只对应一个交易所的期权）    underlying_price (float): [必填] 标的价格，该价格用户输入可以是任意值，例如合约最新价，最高价，开盘价等然后以该值去对比实值/虚值/平值期权    price_level (int / list[int]): [必填] 实值/平值/虚值档位，支持 -100 ~ 100 之间的整数，其中 3,2,1,0,-1,-2,-3，分别代表实值3档，实值2档，实值1档，平值期权，虚值1档，虚值2档，虚值3档，以此类推。     * 如果没有用户指定档位的期权（比如 -100 档），则返回的列表该位置上为 None。例如当 price_level = [-100, 0]，则会返回 [None, ""平值期权合约代码""]    option_class (str): [必填] 期权类型     * CALL: 看涨期权     * PUT: 看跌期权    exercise_year (str): [ETF 期权、股指期权必填] 期权最后行权日年份    exercise_month (str): [ETF 期权、股指期权必填] 期权最后行权日月份    has_A (bool): [可选] 是否含有 A，输入True代表只含A的期权，输入False代表不含A的期权，默认为None不做区分    **注：当选择平值期权时，会按以下逻辑进行选择：**    1. 根据用户传入参数来生成一个期权列表，在这个期权列表中来选择是否有和传入价格相比的平值期权并返回    2. 如果没有符合的平值期权，则取行权价距离传入价格绝对值相差最小的期权作为平值期权    3. 如果存在最近的两个期权的行权价到传入价格的绝对值最小且相等，则取虚值的那个期权作为平值期权，其他档位期权依次展开   return:    返回一个列表类型对象   Example1::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    ls = api.query_atm_options(""SHFE.au2012"", quote.last_price, 0, ""CALL"")    # 预计输出的为以au2012现在最新价来比对的认购的平值期权，当没有符合的平值期权时返回为空    [""SHFE.au2012C30000""]   Example2::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    ls = api.query_atm_options(""SHFE.au2012"", quote.open, [3,2,1], ""CALL"")    # 预计输出的为au2012，以开盘价来比对的认购的实值3档，实值2档，实值1档期权，如果没有符合要求的期权则对应栏返回为None，如果有则返回格式例如    [None,None,""SHFE.au2012C30000""]   Example3::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    ls = api.query_atm_options(""SHFE.au2012"", quote.open, [1,0,-1], ""CALL"")    # 预计输出的为au2012，以开盘价来比对的认购的实值1档，平值期权，虚值1档，如果没有符合要求的期权则对应栏返回为None，如果有则返回格式例如    [""SHFE.au2012C20000"",""SHFE.au2012C25000"",""SHFE.au2012C30000""]   Example4::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    ls = api.query_atm_options(""SHFE.au2012"", quote.last_price, -1, ""CALL"")    # 预计输出的为au2012，以现在最新价来比对的认购的虚值1档期权   Example5::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    ls = api.query_atm_options(""SSE.000300"", quote.last_price, -1, ""CALL"", exercise_year=2020, exercise_month=12)    # 预计输出沪深300股指期权,2020年12月的虚值1档期权   Example6::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    ls = api.query_atm_options(""SSE.510300"", quote.last_price, -1, ""CALL"", exercise_year=2020, exercise_month=12)    # 预计输出 上交所 沪深300股指ETF期权,2020年12月的虚值1档期权   """"""   if self._stock is False:    raise Exception(""期货行情系统(_stock = False)不支持当前接口调用"")   price_level = price_level if type(price_level) is list else [price_level]   if not all([pl in range(-100, 101, 1) for pl in price_level]):    raise Exception(""price_level 必须为 -100 ~ 100 之间的整数"")   if option_class not in ['CALL', 'PUT']:    raise Exception(""option_class 参数错误，option_class 必须是 'CALL' 或者 'PUT'"")   if exercise_year and exercise_month and not (isinstance(exercise_year, int) and isinstance(exercise_month, int)):    raise Exception(""exercise_year / exercise_month 类型错误"")   query = self._query_options_by_underlying(underlying_symbol)   def filter(query_result):    options = self._convert_query_result_to_list(query_result)    if len(options) == 0:     return []    options = self._get_options_filtered(options, option_class=option_class, exercise_year=exercise_year, exercise_month=exercise_month, has_A=has_A)    if len(options) == 0:     return []    options, option_0_index = self._get_options_sorted(options, underlying_price, option_class)    rst_options = []    for pl in price_level:     option_index = option_0_index - pl     if 0 <= option_index < len(options):      rst_options.append(options[option_index][""instrument_id""])     else:      rst_options.append(None)    return rst_options   return self._get_symbol_list(query=query, filter=filter)  def query_symbol_info(self, symbol: Union[str, List[str]]) -> TqSymbolDataFrame:   """"""   查询合约信息   Args:    symbol (str/list of str): 指定合约代码或合约代码列表.     * str: 一个合约代码     * list of str: 合约代码列表   Returns:    pandas.DataFrame: 本函数返回 pandas.DataFrame 实例。每行为一个合约的合约信息。返回值不会再更新。包含以下列:    * ins_class: 合约类型，可能的值有     * FUTURE: 期货     * CONT: 主连     * COMBINE: 组合     * INDEX: 指数     * OPTION: 期权     * STOCK: 股票    * instrument_id: 合约代码，参考 :ref:`mddatas`    * instrument_name: 合约中文名    * exchange_id: 交易所代码，参考 :ref:`mddatas`    * product_id: 品种代码    * price_tick: 合约价格变动单位    * volume_multiple: 合约乘数    * max_limit_order_volume: 最大限价单手数    * max_market_order_volume: 最大市价单手数    * underlying_symbol: 标的合约 （CONT OPTION 类型的合约此字段有效）    * strike_price: 期权行权价    * expired: 合约是否已下市    * expire_datetime: 到期具体日，以秒为单位的 timestamp 值    * expire_rest_days: 距离到期日的剩余天数（自然日天数）    * delivery_year: 期货交割日年份，只对期货品种有效。期权推荐使用最后行权日年份    * delivery_month: 期货交割日月份，只对期货品种有效。期权推荐使用最后行权日月份    * last_exercise_datetime: 期权最后行权日，以秒为单位的 timestamp 值    * exercise_year: 期权最后行权日年份，只对期权品种有效。    * exercise_month: 期权最后行权日月份，只对期权品种有效。    * option_class: 期权方向    * upper_limit: 涨停价    * lower_limit: 跌停价    * pre_settlement: 昨结算    * pre_open_interest: 昨持仓    * pre_close: 昨收盘    * trading_time_day: 白盘交易时间段，list 类型    * trading_time_night: 夜盘交易时间段，list 类型   注意:   1. 回测时，以下字段值为 nan: ""upper_limit"", ""lower_limit"", ""pre_settlement"", ""pre_open_interest"", ""pre_close""   2. 中金所合约未提供涨停价、跌停价   Example1::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    ls = api.query_options(""SSE.510050"", option_class=""CALL"", expired=False) # 所有未下市上交所上证50etf期权    df = api.query_symbol_info(ls)    print(df.to_string())    api.close()   Example2::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    ls = api.query_options(""SSE.510050"", option_class=""CALL"", expired=False)    # 在异步代码中使用    async def show_symbols_info(symbols):     df = await api.query_symbol_info(symbols)     print(df.to_string())    api.create_task(show_symbols_info(ls))    while True:     api.wait_update()    api.close()   """"""   if self._stock is False:    raise Exception(""期货行情系统(_stock = False)不支持当前接口调用"")   symbol_list = [symbol] if isinstance(symbol, str) else symbol   if any([s == """" for s in symbol_list]):    raise Exception(f""symbol 参数 {symbol} 中不能有空字符串。"")   backtest_timestamp = _datetime_to_timestamp_nano(self._get_current_datetime()) if isinstance(self._backtest,                        TqBacktest) else None   df = TqSymbolDataFrame(self, symbol_list, backtest_timestamp=backtest_timestamp)   deadline = time.time() + 30   while not self._loop.is_running() and not df.__dict__[""_task""].done():    if not self.wait_update(deadline=deadline, _task=df.__dict__[""_task""]):     raise TqTimeoutError(f""获取 {symbol} 的行情信息超时，请检查客户端及网络是否正常"")   return df  def query_all_level_options(self, underlying_symbol, underlying_price, option_class, exercise_year: int = None,       exercise_month: int = None, has_A: bool = None) -> SymbolList:   """"""   发送合约服务请求查询，查询符合条件的期权列表，返回全部的实值、平值、虚值期权   Args:    underlying_symbol (str): [必填] 标的合约 （目前每个标的只对应一个交易所的期权）    underlying_price (float): [必填] 标的价格，该价格用户输入可以是任意值，例如合约最新价，最高价，开盘价等然后以该值去对比实值/虚值/平值期权    option_class (str): [必填] 期权类型     * CALL: 看涨期权     * PUT: 看跌期权    exercise_year (str): [ETF 期权、股指期权必填] 期权最后行权日年份    exercise_month (str): [ETF 期权、股指期权必填] 期权最后行权日月份    has_A (bool): [可选] 是否含有 A，输入True代表只含A的期权，输入False代表不含A的期权，默认为None不做区分   return:    返回三个列表，分别为实值期权列表、平值期权列表、虚值期权列表。其中，平值期权列表只包含一个元素。    对于看涨期权，返回的实值期权列表、平值期权列表、虚值期权列表其期权行权价依此递增；    对于看跌期权，返回的实值期权列表、平值期权列表、虚值期权列表其期权行权价依此递减。    **注：当选择平值期权时，会按以下逻辑进行选择：**    1. 根据用户传入参数来生成一个期权列表，在这个期权列表中来选择是否有和传入价格相比的平值期权并返回    2. 如果没有符合的平值期权，则取行权价距离传入价格绝对值相差最小的期权作为平值期权    3. 如果存在最近的两个期权的行权价到传入价格的绝对值最小且相等，则取虚值的那个期权作为平值期权，其他档位期权依次展开   Example1::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SHFE.au2112"")    in_money_options, at_money_options, out_of_money_options = api.query_all_level_options(""SHFE.au2112"", quote.last_price, ""CALL"")    print(in_money_options) # 实值期权列表    print(at_money_options) # 平值期权列表    print(out_of_money_options) # 虚值期权列表   """"""   if self._stock is False:    raise Exception(""期货行情系统(_stock = False)不支持当前接口调用"")   if option_class not in ['CALL', 'PUT']:    raise Exception(""option_class 参数错误，option_class 必须是 'CALL' 或者 'PUT'"")   if exercise_year and exercise_month and not (isinstance(exercise_year, int) and isinstance(exercise_month, int)):    raise Exception(""exercise_year / exercise_month 类型错误"")   query = self._query_options_by_underlying(underlying_symbol)   def filter(query_result):    options = self._convert_query_result_to_list(query_result)    if len(options) == 0:     return [], [], []    options = self._get_options_filtered(options, option_class=option_class, exercise_year=exercise_year, exercise_month=exercise_month, has_A=has_A)    if len(options) == 0:     return [], [], []    options, option_0_index = self._get_options_sorted(options, underlying_price, option_class)    # 实值期权    in_money_options = [o['instrument_id'] for o in options[:option_0_index]]    # 平值期权    at_money_options = [options[option_0_index]['instrument_id']]    # 虚值期权    out_of_money_options = [o['instrument_id'] for o in options[option_0_index + 1:]]    return in_money_options, at_money_options, out_of_money_options   return self._get_symbol_level_list(query=query, filter=filter)  def _get_symbol_level_list(self, query: str, filter: Callable[[dict], Tuple[list, list, list]]):   result = SymbolLevelList(self, query_id=_generate_uuid(""PYSDK_api""), query=query, filter=filter)   if not self._loop.is_running():    deadline = time.time() + 30    while not result._task.done():     if not self.wait_update(deadline=deadline, _task=result._task):      raise TqTimeoutError(f""查询合约服务 {query} 超时，请检查客户端及网络是否正常"")   return result  def query_all_level_finance_options(self, underlying_symbol, underlying_price, option_class,           nearbys: Union[int, List[int]], has_A: bool = None) -> SymbolList:   """"""   发送合约服务请求查询，针对 ETF 期权和股指期权，只查询未下市合约，可以按照距离最后行权日的距离的远近，查询符合条件的期权列表，返回全部的实值、平值、虚值期权   Args:    underlying_symbol (str): [必填] 标的合约 （针对 ETF 期权和股指期权，只支持以下几个合约）     * ""SSE.000300"" 为中金所股指期权标的     * ""SSE.510050"" 为上交所华夏上证 50 ETF 期权标的     * ""SSE.510300"" 为上交所华泰柏瑞沪深 300 ETF 期权标的     * ""SZSE.159919"" 为深交所嘉实沪深 300 ETF 期权标的     * ""SZSE.159915"" 为深交所易方达创业板 ETF 期权标的     * ""SZSE.159922"" 为深交所嘉实中证 500 ETF 期权标的     * ""SSE.510500"" 为上交所南方中证 500 ETF 期权标的    underlying_price (float): [必填] 标的价格，该价格用户输入可以是任意值，例如合约最新价，最高价，开盘价等然后以该值去对比实值/虚值/平值期权    option_class (str): [必填] 期权类型     * CALL: 看涨期权     * PUT: 看跌期权    nearbys (int / list of int): [必填] 将所有未下市期权按照最后行权日由近到远排序，参数 0 代表的是当前月/最接近当前月份的未下市期权, 1 代表下一个到期的期权，依此类推。     * 对于 ETF 期权来说 1 代表在参数 0 后的下月，2 代表随后的第一个一个季月，3 代表随后的第二个季月     * 对于股指期权来说 1 代表在参数 0 后的下月，2 代表下下月，3 代表随后第一个季月，4 代表随后第二个季月，5 代表随后第三个季月    has_A (bool): [可选] 是否含有 A，输入 True 代表只含 A 的期权，输入 False 代表不含 A 的期权，默认为 None 不做区分   return:    返回三个列表，分别为实值期权列表、平值期权列表、虚值期权列表。其中，平值期权列表只包含一个元素。    对于看涨期权，返回的实值期权列表、平值期权列表、虚值期权列表其期权行权价依此递增；    对于看跌期权，返回的实值期权列表、平值期权列表、虚值期权列表其期权行权价依此递减。    **注：当选择平值期权时，会按以下逻辑进行选择：**    1. 根据用户传入参数来生成一个期权列表，按照到期时间和行权价排序（看涨期权升序排列，看跌期权降序排列，使得实值期权在前、虚值期权在后）。    2. 将所有的行权价去重排序（看涨期权升序排列，看跌期权降序排列，实值期权在前、虚值期权在后）    3. 找到与 underlying_price 差值最小的价格为平值期权行权价格，如果有两个行权价与 underlying_price 的差相等，则选取下标大价格的为平值期权行权价格（即两个期权与标的价格距离相等，选取虚值的那个期权作为平值期权）。    4. 如果有多个行权月份的期权，选取距离行权日期最近的那个作为平值期权（保证平值期权列表只包含一个元素）。    5. 下标比平值期权小的为实值期权，下标比平值期权大的为虚值期权。   Example1::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SSE.510300"")    in_money_options, at_money_options, out_of_money_options = api.query_all_level_finance_options(""SSE.510300"", quote.last_price, ""CALL"", nearbys = 1)    print(in_money_options) # 实值期权列表    print(at_money_options) # 平值期权列表    print(out_of_money_options) # 虚值期权列表   Example2::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SSE.510050"")    in_money_options, at_money_options, out_of_money_options = api.query_all_level_finance_options(""SSE.510050"", quote.last_price, ""CALL"", nearbys=[0,1,2])    print(in_money_options) # 实值期权列表    print(at_money_options) # 平值期权列表    print(out_of_money_options) # 虚值期权列表   """"""   if self._stock is False:    raise Exception(""期货行情系统(_stock = False)不支持当前接口调用"")   if underlying_symbol not in [""SSE.000300"", ""SSE.510050"", ""SSE.510300"", ""SZSE.159919"", ""SZSE.159915"", ""SZSE.159922"", ""SSE.510500""]:    raise Exception(""不支持的标的合约"")   if option_class not in ['CALL', 'PUT']:    raise Exception(""option_class 参数错误，option_class 必须是 'CALL' 或者 'PUT'"")   nearbys = nearbys if isinstance(nearbys, list) else [nearbys]   if underlying_symbol == ""SSE.000300"": # 股指期权    if any([i not in [0, 1, 2, 3, 4, 5] for i in nearbys]):     raise Exception(f""股指期权标的为：{underlying_symbol}，exercise_date 参数应该是在 [0, 1, 2, 3, 4, 5] 之间。"")   else: # ETF期权    if any([i not in [0, 1, 2, 3] for i in nearbys]):     raise Exception(f""ETF 期权标的为：{underlying_symbol}，exercise_date 参数应该是在 [0, 1, 2, 3] 之间。"")   query = self._query_options_by_underlying(underlying_symbol)   def filter(query_result):    options = self._convert_query_result_to_list(query_result)    if len(options) == 0:     return [], [], []    options = self._get_options_filtered(options, option_class=option_class, has_A=has_A, nearbys=nearbys)    if len(options) == 0:     return [], [], []    options, option_0_index = self._get_options_sorted(options, underlying_price, option_class)    in_money_options = [o['instrument_id'] for o in options[:option_0_index]] # 实值期权    at_money_options = [options[option_0_index]['instrument_id']] # 平值期权    out_of_money_options = [o['instrument_id'] for o in options[option_0_index + 1:]] # 虚值期权    return in_money_options, at_money_options, out_of_money_options   return self._get_symbol_level_list(query=query, filter=filter)  def _query_options_by_underlying(self, underlying_symbol):   """"""返回标的为 underlying_symbol 的全部期权""""""   if underlying_symbol == """":    raise Exception(""underlying_symbol 不能为空字符串。"")   query_vars = {""instrument_id"": [underlying_symbol]}   derivative_vars = {""class_"": [""OPTION""]}   if isinstance(self._backtest, TqBacktest):    query_vars['timestamp'] = int(self._get_current_datetime().timestamp() * 1e9)    derivative_vars['timestamp'] = int(self._get_current_datetime().timestamp() * 1e9)   op = Operation(ins_schema.rootQuery)   query = op.multi_symbol_info(**query_vars)   query.__as__(basic).instrument_id()   derivative = query.__as__(basic).derivatives(**derivative_vars)   derivative.edges().node().__as__(basic).class_()   derivative.edges().node().__as__(basic).instrument_id()   derivative.edges().node().__as__(basic).exchange_id()   derivative.edges().node().__as__(basic).english_name()   derivative.edges().node().__as__(option).expired()   derivative.edges().node().__as__(option).expire_datetime()   derivative.edges().node().__as__(option).last_exercise_datetime()   derivative.edges().node().__as__(option).strike_price()   derivative.edges().node().__as__(option).call_or_put()   return op.__to_graphql__()  def _convert_query_result_to_list(self, query_result):   options = []   for quote in query_result.get(""result"", {}).get(""multi_symbol_info"", []):    if quote.get(""derivatives""):     for edge in quote[""derivatives""][""edges""]:      last_exercise_datetime = datetime.fromtimestamp(edge[""node""][""last_exercise_datetime""] / 1e9)      edge[""node""][""exercise_year""] = last_exercise_datetime.year      edge[""node""][""exercise_month""] = last_exercise_datetime.month      options.append(edge[""node""])   return options  def _options_filter(self, options, filter_handler):   return list(filter(filter_handler, options))  def _get_options_filtered(self, options, option_class=None, exercise_year=None, exercise_month=None, has_A=None, nearbys=None):   """"""   按照参数中的条件筛选期权   满足以下条件之一：   1. exercise_year is None and exercise_month is None and nearbys is None   2. (exercise_month or exercise_month) xor nearbys   """"""   options = self._options_filter(options,      lambda o: (option_class is None or o[""call_or_put""] == option_class)      and (has_A is None or (has_A is True and o[""english_name""].count('A') > 0) or (has_A is False and o[""english_name""].count('A') == 0))      and (exercise_year is None or o[""exercise_year""] == exercise_year)      and (exercise_month is None or o[""exercise_month""] == exercise_month)      )   if nearbys is not None:    options = self._options_filter(options, lambda o: o[""expired""] is False) # 只筛选在交易的合约    all_exercise_datetime = list(set([o[""last_exercise_datetime""] for o in options]))    all_exercise_datetime.sort()    expect_exercise_datetime = [dt for index, dt in enumerate(all_exercise_datetime) if index in nearbys]    options = self._options_filter(options, lambda o: o[""last_exercise_datetime""] in expect_exercise_datetime)   return options  def _get_options_sorted(self, options, underlying_price, option_class):   """"""返回排序的期权列表（实值在前虚值在后），以及平值期权的下标""""""   options.sort(key=lambda x: x[""last_exercise_datetime""]) # 先按照行权日排序，可能有多个行权日   options.sort(key=lambda x: x['strike_price']) # 按照行权价排序   price_list = [o['strike_price'] for o in options]   mid_price = _bisect_value(price_list, underlying_price, priority=""right"" if option_class == ""CALL"" else ""left"")   mid_option = options[price_list.index(mid_price)]   if option_class == ""PUT"":    options.sort(key=lambda x: x['strike_price'], reverse=True) # 看跌期权按照行权价倒序排序, 保证实值在前虚值在后   return options, options.index(mid_option)  def query_option_greeks(self, symbol: Union[str, List[str]], v: Union[float, List[float], None] = None, r=0.025)\    -> TqOptionGreeksDataFrame:   """"""   返回指定期权的希腊指标   Args:    symbol (str / list of str): 指定合约代码或合约代码列表     * str: 一个合约代码     * list of str: 合约代码列表    v (float / list of float): 合约对应的波动率     * float: 一个波动率值，symbol 为 str 类型时，可以只传入一个波动率值     * list of float: 波动率序列，symbol 为 list 类型时，必须传入与 symbol 数量相同，顺序一一对应的波动率序列     * None: 默认使用隐含波动率计算    r (float): [可选] 无风险利率   Returns:    pandas.DataFrame: 行数与参数 symbol 的合约数量相同，包含以下列：    * instrument_id: 合约代码    * instrument_name: 合约中文名    * option_class: 期权方向    * expire_rest_days: 距离到期日的剩余天数    * expire_datetime: 到期具体日，以秒为单位的 timestamp 值    * underlying_symbol: 标的合约    * strike_price: 期权行权价    * delta: 期权希腊指标 detla 值    * gamma: 期权希腊指标 gamma 值    * theta: 期权希腊指标 theta 值    * vega: 期权希腊指标 vega 值    * rho: 期权希腊指标 rho 值   Example::    from tqsdk import TqApi, TqAuth    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SSE.510300"")    in_money_options, at_money_options, out_of_money_options = api.query_all_level_finance_options(""SSE.510300"", quote.last_price, ""CALL"", nearbys = 1)    ls = in_money_options + at_money_options + out_of_money_options # 期权列表    df = api.query_option_greeks(ls)    print(df.to_string()) # 显示期权希腊指标    api.close()   """"""   symbol_list = [symbol] if isinstance(symbol, str) else symbol   if len(symbol_list) <= 0 or any([s == """" or s is None for s in symbol_list]):    raise Exception(f""symbol 参数 {symbol} 不能为空列表，以及不能有空字符串或者 None。"")   v_list = [v] if isinstance(v, float) else v   if not (v_list is None or len(v_list) == len(symbol_list)):    raise Exception(f""v 参数 {v} 数量与 symbol 参数 {symbol} 数量不同。"")   df = TqOptionGreeksDataFrame(self, symbol_list, v_list=v_list, r=r)   deadline = time.time() + 30   while not self._loop.is_running() and not df.__dict__[""_task""].done():    if not self.wait_update(deadline=deadline, _task=df.__dict__[""_task""]):     raise TqTimeoutError(f""获取 {symbol} 的行情信息超时，请检查客户端及网络是否正常"")   return df  def _setup_connection(self):   """"""初始化""""""   tq_web_helper = TqWebHelper(self)   self._account = self._account if isinstance(self._account, TqMultiAccount) else TqMultiAccount([self._account])   # TqWebHelper 初始化可能会修改 self._account、self._backtest，所以在这里才初始化 logger   # 在此之前使用 self._logger 不会打印日志   if not self._logger.handlers and (self._debug or (self._account._has_tq_account and self._debug is not False)):    _clear_logs() # 先清空日志    log_name = self._debug if isinstance(self._debug, str) else _get_log_name()    if self._debug is not None or _get_disk_free() >= 3:     # self._debug is None 并且磁盘剩余空间小于 3G 则不写入日志     fh = logging.FileHandler(filename=log_name)     fh.setFormatter(JSONFormatter())     fh.setLevel(logging.DEBUG)     self._logger.addHandler(fh)   mem = psutil.virtual_memory()   self._logger.debug(""process start"", product=""tqsdk-python"", version=__version__, os=platform.platform(),       py_version=platform.python_version(), py_arch=platform.architecture()[0],       cmd=sys.argv, mem_total=mem.total, mem_free=mem.free)   if self._auth is None:    raise Exception(""请输入 auth （信易账户）参数，信易账户是使用 tqsdk 的前提，如果没有请点击注册，注册地址：https://account.shinnytech.com/。"")   else:    self._auth.init(mode=""bt"" if isinstance(self._backtest, TqBacktest) else ""real"")    self._auth.login() # tqwebhelper 有可能会设置 self._auth   # 在信易账户登录之后，对于账户的基本信息校验及更新   for acc in self._account._account_list:    if isinstance(acc, BaseOtg):     acc._update_otg_info(self) # 获取交易地址；更新模拟账户 _account_id    # TqAccount 需要尝试自动绑定实盘账户    if isinstance(acc, TqAccount):     if not self._auth._has_account(acc._account_id):      self._auth._add_account(acc._account_id)    elif isinstance(acc, TqKqStock):     if not self._auth._has_account(acc._account_id):      raise Exception(f""您的账户不支持快期股票模拟 TqKqStock，需要购买专业版本后使用。升级网址：https://account.shinnytech.com"")    elif isinstance(acc, TqSimStock):     if not self._auth._has_feature(""sec""):      raise Exception(f""您的账户不支持本地股票模拟 TqSimStock，需要购买专业版本后使用。升级网址：https://account.shinnytech.com"")   # 等待复盘服务器启动   if isinstance(self._backtest, TqReplay):    sim = None # 复盘时如果用户传入的 TqSim 实例，则使用用户传入的参数    for acc in self._account._account_list:     if isinstance(acc, TqSim):      sim = acc      break    self._account = TqMultiAccount([sim if sim else TqSim()])    self._ins_url, self._md_url = self._backtest._create_server(self)   # 连接合约和行情服务器   if self._md_url is None:    try:     self._md_url = self._auth._get_md_url(self._stock, backtest=isinstance(self._backtest, TqBacktest)) # 如果用户未指定行情地址，则使用名称服务获取行情地址    except Exception as e:     now = datetime.now()     if now.hour == 19 and 0 <= now.minute <= 30:      raise Exception(f""{e}, 每日 19:00-19:30 为日常运维时间，请稍后再试"")     else:      raise   md_logger = ShinnyLoggerAdapter(self._logger.getChild(""TqConnect""), url=self._md_url)   ws_md_send_chan = TqChan(self, chan_name=""send to md"", logger=md_logger)   ws_md_recv_chan = TqChan(self, chan_name=""recv from md"", logger=md_logger)   if self._stock is False: # self._stock == False 需要旧版的合约服务文件    quotes = self._fetch_symbol_info(self._ins_url)   else: # todo: self._stock == True 新版合约服务没有已下市合约    dir_path = os.path.dirname(os.path.realpath(__file__))    with lzma.open(os.path.join(dir_path, ""expired_quotes.json.lzma""), ""rt"", encoding=""utf-8"") as f:     quotes = json.loads(f.read())   if isinstance(self._backtest, TqBacktest):    _quotes_add_night(quotes)   # 期权增加了 exercise_year、exercise_month 在旧版合约服务中没有，需要添加，使用下市日期代替最后行权日   for quote in quotes.values():    if quote[""ins_class""] == ""FUTURE_OPTION"":     quote[""exercise_year""] = datetime.fromtimestamp(quote[""expire_datetime""]).year     quote[""exercise_month""] = datetime.fromtimestamp(quote[""expire_datetime""]).month   ws_md_recv_chan.send_nowait({    ""aid"": ""rtn_data"",    ""data"": [{""quotes"": quotes}]   }) # 获取合约信息   self._ws_md_recv_chan = ws_md_recv_chan # 记录 ws_md_recv_chan 引用   conn = TqConnect(md_logger, conn_id=""md"")   self.create_task(conn._run(self, self._md_url, ws_md_send_chan, ws_md_recv_chan))   md_handler_logger = ShinnyLoggerAdapter(self._logger.getChild(""MdReconnect""), url=self._md_url)   ws_md_send_chan._logger_bind(chan_from=""md_reconn"")   ws_md_recv_chan._logger_bind(chan_to=""md_reconn"")   md_reconnect = MdReconnectHandler(md_handler_logger)   api_send_chan = TqChan(self, chan_name=""send to md_reconn"", logger=md_handler_logger)   api_recv_chan = TqChan(self, chan_name=""recv from md_reconn"", logger=md_handler_logger)   self.create_task(md_reconnect._run(self, api_send_chan, api_recv_chan, ws_md_send_chan, ws_md_recv_chan))   ws_md_send_chan, ws_md_recv_chan = api_send_chan, api_recv_chan   # 合约服务模块，负责将 tqsdk 发送的 query 请求结果转为 quotes   tq_symbols = TqSymbols()   ws_md_send_chan._logger_bind(chan_from=""tq_symbols"")   ws_md_recv_chan._logger_bind(chan_to=""tq_symbols"")   tq_symbols_logger = ShinnyLoggerAdapter(self._logger.getChild(""TqSymbols""))   tq_symbols_send_chan = TqChan(self, chan_name=""send to tq_symbols"", logger=tq_symbols_logger)   tq_symbols_recv_chan = TqChan(self, chan_name=""recv from tq_symbols"", logger=tq_symbols_logger)   self.create_task(    tq_symbols._run(self, tq_symbols_send_chan, tq_symbols_recv_chan, ws_md_send_chan, ws_md_recv_chan))   ws_md_send_chan, ws_md_recv_chan = tq_symbols_send_chan, tq_symbols_recv_chan   # 复盘模式，定时发送心跳包, 并将复盘日期发在行情的 recv_chan   if isinstance(self._backtest, TqReplay):    ws_md_recv_chan.send_nowait({     ""aid"": ""rtn_data"",     ""data"": [{      ""_tqsdk_replay"": {       ""replay_dt"": _datetime_to_timestamp_nano(datetime.combine(self._backtest._replay_dt, datetime.min.time()))}     }]    })    self.create_task(self._backtest._run())   # 如果处于回测模式，则将行情连接对接到 backtest 上   if isinstance(self._backtest, TqBacktest):    ws_md_send_chan._logger_bind(chan_from=""backtest"")    ws_md_recv_chan._logger_bind(chan_to=""backtest"")    bt_logger = ShinnyLoggerAdapter(self._logger.getChild(""TqBacktest""))    bt_send_chan = TqChan(self, chan_name=""send to backtest"", logger=bt_logger)    bt_recv_chan = TqChan(self, chan_name=""recv from backtest"", logger=bt_logger)    self.create_task(self._backtest._run(self, bt_send_chan, bt_recv_chan, ws_md_send_chan, ws_md_recv_chan))    ws_md_send_chan, ws_md_recv_chan = bt_send_chan, bt_recv_chan   if not self._backtest:    ts = TqTradingStatus()    ts_send_chan = TqChan(self, chan_name=""send to trading_status"")    ts_recv_chan = TqChan(self, chan_name=""recv from trading_status"")    ws_md_send_chan._logger_bind(chan_from=""trading_status"")    ws_md_recv_chan._logger_bind(chan_to=""trading_status"")    self.create_task(ts._run(self, ts_send_chan, ts_recv_chan, ws_md_send_chan, ws_md_recv_chan))    ws_md_send_chan, ws_md_recv_chan = ts_send_chan, ts_recv_chan   # 启动账户实例并连接交易服务器   self._account._run(self, self._send_chan, self._recv_chan, ws_md_send_chan, ws_md_recv_chan)   # 与 web 配合, 在 tq_web_helper 内部中处理 web_gui 选项   web_send_chan, web_recv_chan = TqChan(self, chan_name=""send to web_helper""), TqChan(self, chan_name=""recv from web_helper"")   self._send_chan._logger_bind(chan_from=""web_helper"")   self._recv_chan._logger_bind(chan_to=""web_helper"")   self.create_task(tq_web_helper._run(web_send_chan, web_recv_chan, self._send_chan, self._recv_chan))   self._send_chan, self._recv_chan = web_send_chan, web_recv_chan   data_extension = DataExtension(self)   data_extension_send_chan = TqChan(self, chan_name=""send to data_extension"")   data_extension_recv_chan = TqChan(self, chan_name=""recv from data_extension"")   self._send_chan._logger_bind(chan_from=""data_extension"")   self._recv_chan._logger_bind(chan_to=""data_extension"")   self.create_task(    data_extension._run(data_extension_send_chan, data_extension_recv_chan, self._send_chan, self._recv_chan),    _caller_api=True)   self._send_chan, self._recv_chan = data_extension_send_chan, data_extension_recv_chan   self._send_chan._logger_bind(chan_from=""api"")   self._recv_chan._logger_bind(chan_to=""api"")  def _fetch_symbol_info(self, url):   """"""获取合约信息""""""   rsp = requests.get(url, headers=self._base_headers, timeout=30)   rsp.raise_for_status()   quotes = {    k: {     ""ins_class"": v.get(""class"", """"),     ""instrument_id"": v.get(""instrument_id"", """"),     ""exchange_id"": v.get(""exchange_id"", """"),     ""margin"": v.get(""margin""), # 用于内部实现模拟交易, 不作为 api 对外可用数据（即 Quote 类中无此字段）     ""commission"": v.get(""commission""), # 用于内部实现模拟交易, 不作为 api 对外可用数据（即 Quote 类中无此字段）     ""price_tick"": v[""price_tick""],     ""price_decs"": v[""price_decs""],     ""volume_multiple"": v[""volume_multiple""],     ""max_limit_order_volume"": v.get(""max_limit_order_volume"", 0),     ""max_market_order_volume"": v.get(""max_market_order_volume"", 0),     ""min_limit_order_volume"": v.get(""min_limit_order_volume"", 0),     ""min_market_order_volume"": v.get(""min_market_order_volume"", 0),     ""underlying_symbol"": v.get(""underlying_symbol"", """"),     ""strike_price"": v.get(""strike_price"", float(""nan"")),     ""expired"": v[""expired""],     ""trading_time"": v.get(""trading_time""),     ""expire_datetime"": v.get(""expire_datetime""),     ""delivery_month"": v.get(""delivery_month""),     ""delivery_year"": v.get(""delivery_year""),     ""option_class"": v.get(""option_class"", """"),     ""product_id"": v.get(""product_id"", """"),    } for k, v in rsp.json().items()   }   # 补丁：将旧版合约服务中 ""CSI.000300"" 全部修改成 ""SSE.000300""   quotes[""SSE.000300""] = quotes.pop(""CSI.000300"", {})   quotes[""SSE.000300""][""exchange_id""] = ""SSE""   for k, v in quotes.items():    if k.startswith(""CFFEX.IO"") and v[""ins_class""] == ""OPTION"":     v[""underlying_symbol""] = ""SSE.000300""   return quotes  def _init_serial(self, root_list, width, default, adj_type):   last_id_list = [root.get(""last_id"", -1) for root in root_list]   # 主合约的array字段   array = [[default[""datetime""]] + [i] + [default[k] for k in default if k != ""datetime""] for i in     range(last_id_list[0] + 1 - width, last_id_list[0] + 1)]   for last_id in last_id_list[1:]:    # 将多个列横向合并    array = np.hstack((array, [[i] + [default[k] for k in default if k != ""datetime""] for i in          range(last_id + 1 - width, last_id + 1)]))   default_keys = [""id""] + [k for k in default.keys() if k != ""datetime""]   columns = [""datetime""] + default_keys   for i in range(1, len(root_list)):    columns += [k + str(i) for k in default_keys]   serial = {    ""root"": root_list,    ""width"": width,    ""default"": default,    ""array"": np.array(array, order=""F""),    ""init"": False, # 是否初始化完成. 完成状态: 订阅K线后已获取所有主、副合约的数据并填满df序列.    ""adj_type"": adj_type,    ""calc_ids_F"": [], # 前复权已经计算过的id，每个 id 只计算一次    ""update_row"": 0, # 起始更新数据行    ""all_attr"": set(columns) | {""symbol"" + str(i) for i in range(1, len(root_list))} | {""symbol"", ""duration""},    ""extra_array"": {},   }   columns = Index(columns)   index = RangeIndex(0, serial[""array""].shape[0])   values = serial[""array""].T   block = FloatBlock(values=values, ndim=2, placement=BlockPlacement(slice(0, len(columns))))   bm = BlockManagerUnconsolidated(blocks=[block], axes=[columns, index])   serial[""df""] = TqDataFrame(self, bm, copy=False)   serial[""df""][""symbol""] = root_list[0][""_path""][1]   for i in range(1, len(root_list)):    serial[""df""][""symbol"" + str(i)] = root_list[i][""_path""][1]   serial[""df""][""duration""] = 0 if root_list[0][""_path""][0] == ""ticks"" else int(    root_list[0][""_path""][-1]) // 1000000000   return serial  def _update_serial_single(self, serial):   """"""处理订阅单个合约时K线的数据更新""""""   last_id = serial[""root""][0].get(""last_id"", -1)   array = serial[""array""]   serial[""update_row""] = 0   if serial[""init""]: # 已经初始化完成    shift = min(last_id - int(array[-1, 1]), serial[""width""]) # array[-1, 1]: 已有数据的last_id    if shift != 0:     array[0:serial[""width""] - shift] = array[shift:serial[""width""]]     for ext in serial[""extra_array""].values():      ext[0:serial[""width""] - shift] = ext[shift:serial[""width""]]      if np.issubdtype(ext.dtype, np.floating):       ext[serial[""width""] - shift:] = np.nan      elif np.issubdtype(ext.dtype, np.object_):       ext[serial[""width""] - shift:] = None      elif np.issubdtype(ext.dtype, np.integer):       ext[serial[""width""] - shift:] = 0      elif np.issubdtype(ext.dtype, np.bool_):       ext[serial[""width""] - shift:] = False      elif np.issubdtype(ext.dtype, np.datetime64):       ext[serial[""width""] - shift:] = np.datetime64('nat')      elif np.issubdtype(ext.dtype, np.timedelta64):       ext[serial[""width""] - shift:] = np.timedelta64('nat')      else:       ext[serial[""width""] - shift:] = np.nan    serial[""update_row""] = max(serial[""width""] - shift - 1, 0)   else:    left_id = serial[""chart""].get(""left_id"", -1)    right_id = serial[""chart""].get(""right_id"", -1)    if (left_id != -1 or right_id != -1) and not serial[""chart""].get(""more_data"", True) and serial[""root""][     0].get(""last_id"", -1) != -1:     serial[""init""] = True   symbol = serial[""chart""][""ins_list""].split("","")[0] # 合约列表   quote = self._data.quotes.get(symbol, {})   duration = serial[""chart""][""duration""] # 周期   keys = list(serial[""default""].keys())   keys.remove('datetime')   if duration != 0:    cols = [""open"", ""high"", ""low"", ""close""]   else:    cols = [""last_price"", ""highest"", ""lowest""] + [f""{x}{i}"" for x in               [""bid_price"", ""ask_price""] for i in               range(1, 6)]   for i in range(serial[""update_row""], serial[""width""]):    index = last_id - serial[""width""] + 1 + i    item = serial[""default""] if index < 0 else _get_obj(serial[""root""][0], [""data"", str(index)],                 serial[""default""])    # 如果需要复权，计算复权    if index > 0 and serial[""adj_type""] in [""B"", ""F""] and quote.ins_class in [""STOCK"", ""FUND""]:     self._ensure_dividend_factor(symbol)     last_index = index - 1     last_item = _get_obj(serial[""root""][0], [""data"", str(last_index)], serial[""default""])     factor = get_dividend_factor(self._dividend_cache[symbol][""df""], last_item, item)     if serial[""adj_type""] == ""B"":      self._dividend_cache[symbol][""back_factor""] = self._dividend_cache[symbol][""back_factor""] * (1 / factor)      if self._dividend_cache[symbol][""back_factor""] != 1.0:       item = item.copy()       for c in cols:        item[c] = item[c] * self._dividend_cache[symbol][""back_factor""]     elif serial[""adj_type""] == ""F"" and factor != 1.0 and i not in serial['calc_ids_F']:      serial['calc_ids_F'].append(i)      for c in cols:       col_index = keys.index(c) + 2       array[:i, col_index] = array[:i, col_index] * factor    array[i] = [item[""datetime""]] + [index] + [item[k] for k in keys if k != ""datetime""]  def _ensure_dividend_factor(self, symbol):   quote = self._data.quotes.get(symbol, {})   if self._dividend_cache.get(symbol, None) is None:    dividend_df = get_dividend_df(quote.get(""stock_dividend_ratio"", []), quote.get(""cash_dividend_ratio"", []))    self._dividend_cache[symbol] = {     ""df"": dividend_df,     ""back_factor"": 1.0    }  def _update_serial_multi(self, serial):   """"""处理订阅多个合约时K线的数据更新""""""   # 判断初始化数据是否接收完全, 否: 则返回   left_id = serial[""chart""].get(""left_id"", -1) # 主合约的left_id   right_id = serial[""chart""].get(""right_id"", -1) # 主合约的right_id   if (left_id == -1 and right_id == -1) or serial[""chart""].get(""more_data"", True):    return   for root in serial[""root""]:    if root.get(""last_id"", -1) == -1:     return   array = serial[""array""]   ins_list = serial[""chart""][""ins_list""].split("","") # 合约列表   if not serial[""init""]: # 未初始化完成则进行初始化处理. init完成状态: 订阅K线后获取所有数据并填满df序列.    update_row = serial[""width""] - 1 # 起始更新数据行,局部变量    current_id = right_id # 当前数据指针    while current_id >= left_id and current_id >= 0 and update_row >= 0: # 如果当前id >= left_id 且 数据尚未填满width长度     master_item = serial[""root""][0][""data""][str(current_id)] # 主合约中 current_id 对应的数据     # 此次更新的一行array初始化填入主合约数据     row_data = [master_item[""datetime""]] + [current_id] + [master_item[col] for col in                  serial[""default""].keys() if col != ""datetime""]     tid = -1     for symbol in ins_list[1:]: # 遍历副合约      # 从binding中取出与symbol对应的last_id      tid = serial[""root""][0].get(""binding"", {}).get(symbol, {}).get(str(current_id), -1)      if tid == -1:       break      other_item = serial[""root""][ins_list.index(symbol)][""data""].get(str(tid)) # 取出tid对应的副合约数据      if other_item is None:       # 1 避免初始化时主合约和binding都收到但副合约数据尚未收到报错       # 2 使用break而非return: 避免夜盘时有binding数据但其对应的副合约需到白盘才有数据（即等待时间过长导致报超时错误）       tid = -1       break      row_data += [tid] + [other_item[col] for col in serial[""default""].keys() if col != ""datetime""]     if tid != -1:      # 数据更新      array[update_row] = row_data      update_row -= 1     current_id -= 1    # 当主合约与某副合约的交易时间完全无重合时不会更新数据。当 update_row 发生了改变，表示数据有更新，则将序列就绪标志转为 True    if update_row != serial[""width""] - 1:     serial[""init""] = True     serial[""update_row""] = 0 # 若需发送数据给天勤，则发送所有数据    # 修改行情订阅指令的 view_width    self._send_pack({     ""aid"": ""set_chart"",     ""chart_id"": serial[""chart""][""chart_id""],     ""ins_list"": serial[""chart""][""ins_list""],     ""duration"": serial[""chart""][""duration""],     # 如果长度小于30,则默认请求30,以保证能包含到所有在向上处理数据时收到的新数据,30:get_klines_serial()中等待超时的秒数,最小K线序列为1s线     ""view_width"": len(array) if len(array) >= 30 else 30,    })   else: # 正常行情更新处理    serial[""update_row""] = serial[""width""] - 1    new_kline_range = None    new_data_index = serial[""width""] - 1 # 记录更新数据位置    # 从 left_id 或 已有数据的最后一个 last_id 到服务器发回的最新数据的 last_id: 每次循环更新一行。max: 避免数据更新过多时产生大量多余循环判断    for i in range(max(serial[""chart""].get(""left_id"", -1), int(array[-1, 1])),       serial[""root""][0].get(""last_id"", -1) + 1):     # 如果某条主K线和某条副K线之间的 binding 映射数据存在: 则对应副合约数据也存在; 遍历主合约与所有副合约的binding信息, 如果都存在, 则将此K线填入array保存.     master_item = serial[""root""][0][""data""][str(i)] # 主合约数据     # array更新的一行数据: 初始化填入主合约数据     row_data = [master_item[""datetime""]] + [i] + [master_item[col] for col in serial[""default""].keys() if                col != ""datetime""]     tid = -1     for symbol in ins_list[1:]: # 遍历副合约      # 从binding中取出与symbol对应的last_id      tid = (serial[""root""][0].get(""binding"", {}).get(symbol, {}).get(str(i), -1))      if tid == -1:       break      # 取出tid对应的副合约数据      other_item = serial[""root""][ins_list.index(symbol)][""data""].get(str(tid))      if other_item is None:       return      row_data += [tid] + [other_item[col] for col in serial[""default""].keys() if col != ""datetime""]     # 如果有新增K线, 则向上移动一行；循环的第一条数据为原序列最后一条数据, 只更新不shift     if tid != -1:      if i != array[-1, 1]: # 如果不是已有数据的最后一行，表示生成新K线，则向上移动一行       new_data_index = new_data_index + 1       # 修改 serial[""update_row""] 以保证发送正确数序列给天勤       serial[""update_row""] = serial[""update_row""] - 1 if serial[""update_row""] > 0 else 0       if new_kline_range is None: # 记录第一条新K线的id        new_kline_range = i      # 数据更新      array[new_data_index % serial[""width""]] = row_data    if new_kline_range is not None: # 有新K线生成     array[:] = np.roll(array, serial[""width""] - (new_data_index % serial[""width""]) - 1, axis=0)[:]     remain = max(2 * serial[""width""] - 1 - new_data_index, 0)     for ext in serial[""extra_array""].values():      ext[:remain] = ext[serial[""width""] - remain:]      if ext.dtype == np.float:       ext[remain:] = np.nan      elif ext.dtype == np.object:       ext[remain:] = None      elif ext.dtype == np.int:       ext[remain:] = 0      elif ext.dtype == np.bool:       ext[remain:] = False      elif ext.dtype == np.datetime64:       ext[remain:] = np.datetime64('nat')      elif ext.dtype == np.timedelta64:       ext[remain:] = np.timedelta64('nat')      else:       ext[remain:] = np.nan     k = (ins_list[0], tuple(ins_list[1:]), serial[""df""][""duration""][0] * 1000000000)     # 注: i 从 left_id 开始，shift最大长度为width，则必有：new_kline_range >= array[0,1]     self._klines_update_range[k] = (      new_kline_range if not self._klines_update_range.get(k) else min(self._klines_update_range[k][0],                      new_kline_range),      array[-1, 1] + 1) # array[-1, 1] + 1： 保持左闭右开规范  def _process_serial_extra_array(self, serial):   for col in set(serial[""df""].columns.values) - serial[""all_attr""]:    serial[""update_row""] = 0    serial[""extra_array""][col] = serial[""df""][col].to_numpy()   # 如果策略中删除了之前添加到 df 中的序列，则 extra_array 中也将其删除   for col in serial[""all_attr""] - set(serial[""df""].columns.values):    del serial[""extra_array""][col]   serial[""all_attr""] = set(serial[""df""].columns.values)   if serial[""update_row""] == serial[""width""]:    return   symbol = serial[""root""][0][""_path""][1] # 主合约的symbol，标志绘图的主合约   duration = 0 if serial[""root""][0][""_path""][0] == ""ticks"" else int(serial[""root""][0][""_path""][-1])   cols = list(serial[""extra_array""].keys())   # 归并数据序列   while len(cols) != 0:    col = cols[0].split(""."")[0]    # 找相关序列，首先查找以col开头的序列    group = [c for c in cols if c.startswith(col + ""."") or c == col]    cols = [c for c in cols if c not in group]    data = {c[len(col):]: serial[""extra_array""][c][serial[""update_row""]:] for c in group}    self._process_chart_data_for_web(serial, symbol, duration, col, serial[""width""] - serial[""update_row""],            int(serial[""array""][-1, 1]) + 1, data)   serial[""update_row""] = serial[""width""]  def _process_chart_data_for_web(self, serial, symbol, duration, col, count, right, data):   # 与 _process_chart_data 函数功能类似，但是处理成符合 diff 协议的序列，在 js 端就不需要特殊处理了   if not data:    return   if "".open"" in data:    data_type = ""KSERIAL""   elif "".type"" in data:    data_type = data["".type""]    rows = np.where(np.not_equal(data_type, None))[0]    if len(rows) == 0:     return    data_type = data_type[rows[0]]   else:    data_type = ""LINE""   send_data = {    ""type"": ""KSERIAL"" if data_type == ""KSERIAL"" else ""SERIAL"",    ""range_left"": right - count,    ""range_right"": right - 1,    ""data"": {}   }   # 在执行 _update_serial_single 时，有可能将未赋值的字段设置为 None, 这里如果为 None 则不发送这个 board 字段，   # 因为 None 在 diff 协议中的含义是删除这个字段，这里仅仅表示不赋新值，下面的 color, width 同理   board = data.get("".board"", [""MAIN""])[-1]   if board:    send_data[""board""] = data.get("".board"", [""MAIN""])[-1]   if data_type in {""LINE"", ""DOT"", ""DASH"", ""BAR""}:    send_data[""style""] = data_type    color = data.get("".color"", [""#FF0000""])[-1]    if color:     send_data[""color""] = color if isinstance(color, str) else int(color)    width = int(data.get("".width"", [1])[-1])    if width:     send_data[""width""] = int(data.get("".width"", [1])[-1])    for i in range(count):     send_data[""data""][i + right - count] = {      # 数据结构与 KSERIAL 保持一致，只有一列的时候，默认 key 值取 ""value""      ""value"": data[""""][i]     }    self._send_series_data(symbol, duration, col, send_data, aid=""set_chart_data"")   elif data_type == ""KSERIAL"":    for i in range(count):     send_data[""data""][i + right - count] = {      ""open"": data["".open""][i],      ""high"": data["".high""][i],      ""low"": data["".low""][i],      ""close"": data["".close""][i]     }    self._send_series_data(symbol, duration, col, send_data, aid=""set_chart_data"")  def _send_series_data(self, symbol, duration, serial_id, serial_data, aid=""set_chart_data""):   pack = {    ""aid"": aid,    ""symbol"": symbol,    ""dur_nano"": duration,    ""datas"": {     serial_id: serial_data,    }   }   self._send_pack(pack)  async def _notify_watcher(self):   """"""将从服务器收到的通知打印出来""""""   processed_notify = set()   notify = _get_obj(self._data, [""notify""])   async with self.register_update_notify(notify) as update_chan:    async for _ in update_chan:     all_notifies = {k for k in notify if not k.startswith(""_"")}     notifies = all_notifies - processed_notify     processed_notify = all_notifies     for n in notifies:      try:       level = getattr(logging, notify[n][""level""])      except (AttributeError, KeyError):       level = logging.INFO      account_name = notify[n].get('_account_name', '')      self._print(f""通知 {account_name}: {notify[n]['content']}"", level=level)  async def _fetch_msg(self):   while not self._pending_diffs:    pack = await self._recv_chan.recv()    if not self._is_slave:     for slave in self._slaves:      slave._slave_recv_pack(copy.deepcopy(pack))    self._pending_diffs.extend(pack.get(""data"", []))   self._pending_peek = False  def _gen_prototype(self):   """"""所有业务数据的原型""""""   return {    ""quotes"": {     ""#"": Quote(self), # 行情的数据原型    },    ""klines"": {     ""*"": {      ""*"": {       ""data"": {        ""@"": Kline(self), # K线的数据原型       }      }     }    },    ""ticks"": {     ""*"": {      ""data"": {       ""@"": Tick(self), # Tick的数据原型      }     }    },    ""trading_status"": {     ""#"": TradingStatus(self), # 行情的数据原型    },    ""trade"": {     ""*"": {      ""accounts"": {       ""@"": Account(self), # 账户的数据原型      },      ""orders"": {       ""@"": Order(self), # 委托单的数据原型      },      ""trades"": {       ""@"": Trade(self), # 成交的数据原型      },      ""positions"": {       ""@"": Position(self), # 持仓的数据原型      },      ""risk_management_rule"": {       ""@"": RiskManagementRule(self)      },      ""risk_management_data"": {       ""@"": RiskManagementData(self)      }     }    },   }  def _gen_security_prototype(self):   """"""所有业务数据的原型""""""   return {    ""quotes"": {     ""#"": Quote(self), # 行情的数据原型    },    ""klines"": {     ""*"": {      ""*"": {       ""data"": {        ""@"": Kline(self), # K线的数据原型       }      }     }    },    ""ticks"": {     ""*"": {      ""data"": {       ""@"": Tick(self), # Tick的数据原型      }     }    },    ""trade"": {     ""*"": {      ""accounts"": {       ""@"": SecurityAccount(self), # 账户的数据原型      },      ""orders"": {       ""@"": SecurityOrder(self), # 委托单的数据原型      },      ""trades"": {       ""@"": SecurityTrade(self), # 成交的数据原型      },      ""positions"": {       ""@"": SecurityPosition(self), # 持仓的数据原型      }     }    },   }  @staticmethod  def _deep_copy_dict(source, dest):   for key, value in source.__dict__.items():    if isinstance(value, Entity):     dest[key] = {}     TqApi._deep_copy_dict(value, dest[key])    else:     dest[key] = value  def _slave_send_pack(self, pack):   if pack.get(""aid"", None) == ""subscribe_quote"":    self._loop.call_soon_threadsafe(lambda: self._send_subscribe_quote(pack))    return   self._loop.call_soon_threadsafe(lambda: self._send_pack(pack))  def _slave_recv_pack(self, pack):   self._loop.call_soon_threadsafe(lambda: self._recv_chan.send_nowait(pack))  def _send_subscribe_quote(self, pack):   new_subscribe_set = self._requests[""quotes""] | set(pack[""ins_list""].split("",""))   if new_subscribe_set != self._requests[""quotes""]:    self._requests[""quotes""] = new_subscribe_set    self._send_pack({     ""aid"": ""subscribe_quote"",     ""ins_list"": "","".join(self._requests[""quotes""])    })  def _send_pack(self, pack):   if not self._is_slave:    self._send_chan.send_nowait(pack)   else:    self._master._slave_send_pack(pack)  def draw_text(self, base_k_dataframe: pd.DataFrame, text: str, x: Optional[int] = None, y: Optional[float] = None,     id: Optional[str] = None, board: str = ""MAIN"", color: Union[str, int] = ""red"") -> None:   """"""   配合天勤使用时, 在天勤的行情图上绘制一个字符串   Args:    base_k_dataframe (pandas.DataFrame): 基础K线数据序列, 要绘制的K线将出现在这个K线图上. 需要画图的数据以附加列的形式存在    text (str): 要显示的字符串    x (int): X 坐标, 以K线的序列号表示. 可选, 缺省为对齐最后一根K线,    y (float): Y 坐标. 可选, 缺省为最后一根K线收盘价    id (str): 字符串ID, 可选. 以相同ID多次调用本函数, 后一次调用将覆盖前一次调用的效果    board (str): 选择图板, 可选, 缺省为 ""MAIN"" 表示绘制在主图    color (str/int): 文本颜色, 可选, 缺省为 ""red""     * str : 符合 CSS Color 命名规则的字符串, 例如: ""red"", ""#FF0000"", ""#FF0000FF"", ""rgb(255, 0, 0)"", ""rgba(255, 0, 0, .5)""     * int : 十六进制整数表示颜色, ARGB, 例如: 0xffff0000   Example::    # 在主图最近K线的最低处标一个""最低""文字    klines = api.get_kline_serial(""SHFE.cu1905"", 86400)    indic = np.where(klines.low == klines.low.min())[0]    value = klines.low.min()    api.draw_text(klines, ""测试413423"", x=indic, y=value, color=0xFF00FF00)   """"""   if id is None:    id = _generate_uuid()   if y is None:    y = base_k_dataframe[""close""].iloc[-1]   serial = {    ""type"": ""TEXT"",    ""x1"": self._offset_to_x(base_k_dataframe, x),    ""y1"": y,    ""text"": text,    ""color"": color,    ""board"": board,   }   self._send_chart_data(base_k_dataframe, id, serial)  def draw_line(self, base_k_dataframe: pd.DataFrame, x1: int, y1: float, x2: int, y2: float,     id: Optional[str] = None, board: str = ""MAIN"", line_type: str = ""LINE"",     color: Union[str, int] = ""red"",     width: int = 1) -> None:   """"""   配合天勤使用时, 在天勤的行情图上绘制一个直线/线段/射线   Args:    base_k_dataframe (pandas.DataFrame): 基础K线数据序列, 要绘制的K线将出现在这个K线图上. 需要画图的数据以附加列的形式存在    x1 (int): 第一个点的 X 坐标, 以K线的序列号表示    y1 (float): 第一个点的 Y 坐标    x2 (int): 第二个点的 X 坐标, 以K线的序列号表示    y2 (float): 第二个点的 Y 坐标    id (str): 字符串ID, 可选. 以相同ID多次调用本函数, 后一次调用将覆盖前一次调用的效果    board (str): 选择图板, 可选, 缺省为 ""MAIN"" 表示绘制在主图    line_type (str): 画线类型, 目前只支持 ""SEG"" 线段    color (str/int): 线颜色, 可选, 缺省为 ""red""     * str : 符合 CSS Color 命名规则的字符串, 例如: ""red"", ""#FF0000"", ""#FF0000FF"", ""rgb(255, 0, 0)"", ""rgba(255, 0, 0, .5)""     * int : 十六进制整数表示颜色, ARGB, 例如: 0xffff0000    width (int): 线宽度, 可选, 缺省为 1   """"""   if id is None:    id = _generate_uuid()   serial = {    ""type"": line_type,    ""x1"": self._offset_to_x(base_k_dataframe, x1),    ""y1"": y1,    ""x2"": self._offset_to_x(base_k_dataframe, x2),    ""y2"": y2,    ""color"": color,    ""width"": width,    ""board"": board,   }   self._send_chart_data(base_k_dataframe, id, serial)  def draw_box(self, base_k_dataframe: pd.DataFrame, x1: int, y1: float, x2: int, y2: float, id: Optional[str] = None,     board: str = ""MAIN"", bg_color: Union[str, int] = ""black"", color: Union[str, int] = ""red"",     width: int = 1) -> None:   """"""   配合天勤使用时, 在天勤的行情图上绘制一个矩形   Args:    base_k_dataframe (pandas.DataFrame): 基础K线数据序列, 要绘制的K线将出现在这个K线图上. 需要画图的数据以附加列的形式存在    x1 (int): 矩形左上角的 X 坐标, 以K线的序列号表示    y1 (float): 矩形左上角的 Y 坐标    x2 (int): 矩形右下角的 X 坐标, 以K线的序列号表示    y2 (float): 矩形右下角的 Y 坐标    id (str): ID, 可选. 以相同ID多次调用本函数, 后一次调用将覆盖前一次调用的效果    board (str): 选择图板, 可选, 缺省为 ""MAIN"" 表示绘制在主图    bg_color (str/int): 填充颜色, 可选, 缺省为 ""black""     * str : 符合 CSS Color 命名规则的字符串, 例如: ""red"", ""#FF0000"", ""#FF0000FF"", ""rgb(255, 0, 0)"", ""rgba(255, 0, 0, .5)""     * int : 十六进制整数表示颜色, ARGB, 例如: 0xffff0000    color (str/int): 边框颜色, 可选, 缺省为 ""red""     * str : 符合 CSS Color 命名规则的字符串, 例如: ""red"", ""#FF0000"", ""#FF0000FF"", ""rgb(255, 0, 0)"", ""rgba(255, 0, 0, .5)""     * int : 十六进制整数表示颜色, ARGB, 例如: 0xffff0000    width (int): 边框宽度, 可选, 缺省为 1   Example::    # 给主图最后5根K线加一个方框    klines = api.get_kline_serial(""SHFE.cu1905"", 86400)    api.draw_box(klines, x1=-5, y1=klines.iloc[-5].close, x2=-1, \    y2=klines.iloc[-1].close, width=1, color=0xFF0000FF, bg_color=0x8000FF00)   """"""   if id is None:    id = _generate_uuid()   serial = {    ""type"": ""BOX"",    ""x1"": self._offset_to_x(base_k_dataframe, x1),    ""y1"": y1,    ""x2"": self._offset_to_x(base_k_dataframe, x2),    ""y2"": y2,    ""bg_color"": bg_color,    ""color"": color,    ""width"": width,    ""board"": board,   }   self._send_chart_data(base_k_dataframe, id, serial)  def draw_report(self, report_datas):   """"""   配合 web_gui 使用时, 在天勤的回测报告中绘制成交统计的图表   """"""   self._send_pack({    ""aid"": ""set_report_data"",    ""report_datas"": report_datas   })  def _send_chart_data(self, base_kserial_frame, serial_id, serial_data):   s = self._serials[id(base_kserial_frame)]   p = s[""root""][0][""_path""]   symbol = p[-2]   dur_nano = int(p[-1])   pack = {    ""aid"": ""set_chart_data"",    ""symbol"": symbol,    ""dur_nano"": dur_nano,    ""datas"": {     serial_id: serial_data,    }   }   self._send_pack(pack)  def _offset_to_x(self, base_k_dataframe, x):   if x is None:    return int(base_k_dataframe[""id""].iloc[-1])   elif x < 0:    return int(base_k_dataframe[""id""].iloc[-1]) + 1 + x   elif x >= 0:    return int(base_k_dataframe[""id""].iloc[0]) + x  def _symbols_to_quotes(self, symbols, keys=None):   if keys is None:    keys = set(Quote(None).keys())   quotes = _symbols_to_quotes(symbols, keys)   if isinstance(self._backtest, TqBacktest):    _quotes_add_night(quotes)    for quote in quotes.values(): # 回测时，去掉主连的 underlying_symbol     if quote.get(""ins_class"") == ""CONT"":      quote.pop(""underlying_symbol"", None)   return quotes  def _get_current_datetime(self):   if isinstance(self._backtest, TqBacktest):    current_dt = self._data.get('_tqsdk_backtest', {}).get('current_dt', 0)    return datetime.fromtimestamp(current_dt / 1e9)   else:    return datetime.now() print(""在使用天勤量化之前，默认您已经知晓并同意以下免责条款，如果不同意请立即停止使用：https://www.shinnytech.com/blog/disclaimer/"", file=sys.stderr) if platform.python_version().startswith('3.6'):  warnings.warn(""TqSdk 计划在 20220601 之后放弃支持 Python 3.6 版本，请尽快升级 Python 版本。"", FutureWarning, stacklevel=1) try:  res = requests.get(""https://shinny-tqsdk.oss-cn-shanghai.aliyuncs.com/tqsdk_metadata.json"", timeout=10)  tq_metadata = res.json()  v_tuple = lambda s: tuple(map(int, (s.split("".""))))  if tq_metadata.get('tqsdk_changelog') and v_tuple(__version__) < v_tuple(tq_metadata.get('tqsdk_version', '0.0.0')):   print(tq_metadata['tqsdk_changelog'], file=sys.stderr)  if tq_metadata.get('tqsdk_notify'):   print(tq_metadata['tqsdk_notify'], file=sys.stderr) except:  pass "
75,n\tqsdk\aut,"n\tqsdk\aut. # !usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' import json import logging import os import jwt import requests from shinny_structlog import ShinnyLoggerAdapter import tqsdk class TqAuth(object):  """"""信易用户认证类""""""  def __init__(self, user_name: str = """", password: str = """"):   """"""   创建信易用户认证类   Args:    user_name (str): [必填]信易账户，可以是 邮箱、用户名、手机号    password (str): [必填]信易账户密码   Example::    # 使用实盘帐号直连行情和交易服务器    from tqsdk import TqApi, TqAccount, TqAuth    api = TqApi(TqAccount(""H海通期货"", ""022631"", ""123456""), auth=TqAuth(""信易账户"", ""账户密码""))   """"""   self._user_name = user_name   self._password = password   self._auth_url = os.getenv(""TQ_AUTH_URL"", ""https://auth.shinnytech.com"")   self._access_token = """"   self._refresh_token = """"   self._auth_id = """"   self._mode = ""real"" # 行情模式 real bt   self._grants = {    ""features"": [],    ""accounts"": []   }   self._logger = ShinnyLoggerAdapter(logging.getLogger(""TqApi.TqAuth""), headers=self._base_headers, grants=self._grants)  @property  def _base_headers(self):   return {    ""User-Agent"": ""tqsdk-python %s"" % tqsdk.__version__,    ""Accept"": ""application/json"",    ""Authorization"": ""Bearer %s"" % self._access_token   }  def init(self, mode=""real""):   self._mode = mode  def login(self):   self._logger.debug(""login"", user_name=self._user_name)   self._access_token, self._refresh_token = self._request_token({    ""grant_type"": ""password"",    ""username"": self._user_name,    ""password"": self._password   })   content = jwt.decode(self._access_token, options={""verify_signature"": False})   self._grants = content[""grants""]   self._auth_id = content[""sub""]   self._logger = self._logger.bind(headers=self._base_headers, grants=self._grants)  def _request_token(self, payload):   data = {""client_id"": ""shinny_tq"", ""client_secret"": ""be30b9f4-6862-488a-99ad-21bde0400081""}   data.update(payload)   url = f""{self._auth_url}/auth/realms/shinnytech/protocol/openid-connect/token""   self._logger.debug(""request token"", url=url, params=data, method=""POST"")   response = requests.post(url=url, headers=self._base_headers, data=data, timeout=30)   self._logger.debug(""request token result"", url=response.url, status_code=response.status_code, headers=response.headers, reason=response.reason, text=response.text)   if response.status_code == 200:    content = json.loads(response.content)    return content[""access_token""], content[""refresh_token""]   else:    raise Exception(""用户权限认证失败 (%d,%s)"" % (response.status_code, json.loads(response.content)))  def _add_account(self, account_id):   if self._has_account(account_id):    return True   url = f""{self._auth_url}/auth/realms/shinnytech/rest/update-grant-accounts/{account_id}""   self._logger.debug(""add account"", account_id=account_id, url=url, method=""PUT"")   response = requests.put(url=url, headers=self._base_headers, timeout=30)   self._logger.debug(""add account result"", url=response.url, status_code=response.status_code, headers=response.headers, reason=response.reason, text=response.text)   if response.status_code == 200:    self._access_token, self._refresh_token = self._request_token({     ""grant_type"": ""refresh_token"",     ""refresh_token"": self._refresh_token,    })    content = jwt.decode(self._access_token, options={""verify_signature"": False})    self._grants.update(content[""grants""])    self._logger = self._logger.bind(headers=self._base_headers, grants=self._grants)   else:    raise Exception(f""添加期货账户失败。{response.status_code}, {json.loads(response.content)}"")  def _get_td_url(self, broker_id, account_id):   """"""获取交易网关地址""""""   url = f""https://files.shinnytech.com/{broker_id}.json""   params = {    ""account_id"": account_id,    ""auth"": self._user_name   }   self._logger.debug(""request td url"", url=url, params=params, method=""POST"")   response = requests.get(url=url, params=params, headers=self._base_headers, timeout=30)   self._logger.debug(""request td url result"", url=response.url, status_code=response.status_code,       headers=response.headers, reason=response.reason, text=response.text)   if response.status_code != 200:    raise Exception(f""不支持该期货公司 - {broker_id}，请联系期货公司。"")   broker_list = json.loads(response.content)   if ""TQ"" not in broker_list[broker_id][""category""]:    raise Exception(f""该期货公司 - {broker_id} 暂不支持 TqSdk 登录，请联系期货公司。"")   return broker_list[broker_id][""url""], broker_list[broker_id].get('broker_type', 'FUTURE')  def _get_md_url(self, stock, backtest):   """"""获取行情网关地址""""""   url = f""https://api.shinnytech.com/ns""   params = {""stock"": str(stock).lower(), ""backtest"": str(backtest).lower()}   self._logger.debug(""request md url"", url=url, params=params, method=""POST"")   response = requests.get(url=url, params=params, headers=self._base_headers, timeout=30)   self._logger.debug(""request md url result"", url=response.url, status_code=response.status_code,       headers=response.headers, reason=response.reason, text=response.text)   if response.status_code == 200:    content = json.loads(response.content)    if ""mdurl"" in content:     return content[""mdurl""]    else:     raise Exception(f""调用名称服务失败: {content}"")   else:    raise Exception(f""调用名称服务失败: {response.status_code}, {response.content}"")  def _has_feature(self, feature):   if self._mode == ""bt"" and feature in [""futr"", ""sec"", ""lmt_idx""]:    # 在回测模式中所有用户都有 futr sec lmt_idx 权限    return True   return feature in self._grants[""features""]  def _has_account(self, account):   return account in self._grants[""accounts""]  def _has_md_grants(self, symbol):   symbol_list = symbol if isinstance(symbol, list) else [symbol]   for symbol in symbol_list:    if symbol.split('.', 1)[0] in [""SHFE"", ""DCE"", ""CZCE"", ""INE"", ""CFFEX"", ""KQ"", ""SSWE""] and self._has_feature(""futr""):     continue    elif symbol.split('.', 1)[0] in [""SSE"", ""SZSE""] and self._has_feature(""sec""):     continue    elif symbol in [""SSE.000016"", ""SSE.000300"", ""SSE.000905"", ""SSE.000852""] and self._has_feature(""lmt_idx""):     continue    else:     raise Exception(f""您的账户不支持查看 {symbol} 的行情数据，需要购买专业版本后使用。升级网址：https://account.shinnytech.com"")   return True  def _has_td_grants(self, symbol):   # 对于 opt / cmb / adv 权限的检查由 OTG 做   if symbol.split('.', 1)[0] in [""SSE"", ""SZSE""] and self._has_feature(""sec""):    return True   if symbol.split('.', 1)[0] in [""SHFE"", ""DCE"", ""CZCE"", ""INE"", ""CFFEX"", ""KQ""] and self._has_feature(""futr""):    return True   raise Exception(f""您的账户不支持交易 {symbol}，需要购买专业版本后使用。升级网址：https://account.shinnytech.com"") "
76,n\tqsdk\backtes,"n\tqsdk\backtes. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' import asyncio import json import math import os import time from datetime import date, datetime from typing import Union import aiohttp import requests import pandas as pd from tqsdk.channel import TqChan from tqsdk.datetime import _get_trading_day_start_time, _get_trading_day_end_time, _get_trading_day_from_timestamp from tqsdk.diff import _merge_diff, _get_obj from tqsdk.entity import Entity from tqsdk.exceptions import BacktestFinished from tqsdk.objs import Kline, Tick from tqsdk.rangeset import _rangeset_range_union, _rangeset_difference, _rangeset_union from tqsdk.utils import _generate_uuid, _query_for_quote class BtQuote(Entity):  """""" Quote 是一个行情对象 """"""  def __init__(self, api):   self._api = api   self.price_tick: float = float(""nan"") class TqBacktest(object):  """"""  天勤回测类  将该类传入 TqApi 的构造函数, 则策略就会进入回测模式。  回测模式下 k线会在刚创建出来时和结束时分别更新一次, 在这之间 k线是不会更新的。  回测模式下 quote 的更新频率由所订阅的 tick 和 k线周期确定:   * 只要订阅了 tick, 则对应合约的 quote 就会使用 tick 生成, 更新频率也和 tick 一致, 但 **只有下字段** :   datetime/ask&bid_price1/ask&bid_volume1/last_price/highest/lowest/average/volume/amount/open_interest/   price_tick/price_decs/volume_multiple/max&min_limit&market_order_volume/underlying_symbol/strike_price   * 如果没有订阅 tick, 但是订阅了 k线, 则对应合约的 quote 会使用 k线生成, 更新频率和 k线的周期一致， 如果订阅了某个合约的多个周期的 k线,   则任一个周期的 k线有更新时, quote 都会更新. 使用 k线生成的 quote 的盘口由收盘价分别加/减一个最小变动单位, 并且 highest/lowest/average/amount   始终为 nan, volume 始终为0   * 如果即没有订阅 tick, 也没有订阅k线或 订阅的k线周期大于分钟线, 则 TqBacktest 会 **自动订阅分钟线** 来生成 quote   * 如果没有订阅 tick, 但是订阅了 k线, 则对应合约的 quote **只有下字段** :   datetime/ask&bid_price1/ask&bid_volume1/last_price/open_interest/   price_tick/price_decs/volume_multiple/max&min_limit&market_order_volume/underlying_symbol/strike_price  **注意** ：如果未订阅 quote，模拟交易在下单时会自动为此合约订阅 quote ，根据回测时 quote 的更新规则，如果此合约没有订阅K线或K线周期大于分钟线 **则会自动订阅一个分钟线** 。  模拟交易要求报单价格大于等于对手盘价格才会成交, 例如下买单, 要求价格大于等于卖一价才会成交, 如果不能立即成交则会等到下次行情更新再重新判断。  回测模式下 wait_update 每次最多推进一个行情时间。  回测结束后会抛出 BacktestFinished 例外。  对 **组合合约** 进行回测时需注意：只能通过订阅 tick 数据来回测，不能订阅K线，因为K线是由最新价合成的，而交易所发回的组合合约数据中无最新价。  """"""  def __init__(self, start_dt: Union[date, datetime], end_dt: Union[date, datetime]) -> None:   """"""   创建天勤回测类   Args:    start_dt (date/datetime): 回测起始时间, 如果类型为 date 则指的是交易日, 如果为 datetime 则指的是具体时间点    end_dt (date/datetime): 回测结束时间, 如果类型为 date 则指的是交易日, 如果为 datetime 则指的是具体时间点   """"""   if isinstance(start_dt, datetime):    self._start_dt = int(start_dt.timestamp() * 1e9)   elif isinstance(start_dt, date):    self._start_dt = _get_trading_day_start_time(     int(datetime(start_dt.year, start_dt.month, start_dt.day).timestamp()) * 1000000000)   else:    raise Exception(""回测起始时间(start_dt)类型 %s 错误, 请检查 start_dt 数据类型是否填写正确"" % (type(start_dt)))   if isinstance(end_dt, datetime):    self._end_dt = int(end_dt.timestamp() * 1e9)   elif isinstance(end_dt, date):    self._end_dt = _get_trading_day_end_time(     int(datetime(end_dt.year, end_dt.month, end_dt.day).timestamp()) * 1000000000)   else:    raise Exception(""回测结束时间(end_dt)类型 %s 错误, 请检查 end_dt 数据类型是否填写正确"" % (type(end_dt)))   self._current_dt = self._start_dt   # 记录当前的交易日 开始时间/结束时间   self._trading_day_start = _get_trading_day_start_time(_get_trading_day_from_timestamp(self._current_dt))   self._trading_day_end = _get_trading_day_end_time(_get_trading_day_from_timestamp(self._current_dt))  async def _run(self, api, sim_send_chan, sim_recv_chan, md_send_chan, md_recv_chan):   """"""回测task""""""   self._api = api   # 下载历史主连合约信息   rsp = requests.get(os.getenv(""TQ_CONT_TABLE_URL"", ""https://files.shinnytech.com/continuous_table.json""),       headers=self._api._base_headers,       timeout=30)   rsp.raise_for_status()   self._continuous_table = {f""KQ.m@{k}"": pd.DataFrame(data=v, columns=['date', 'underlying'])         for k, v in rsp.json().items()}   self._logger = api._logger.getChild(""TqBacktest"") # 调试信息输出   self._sim_send_chan = sim_send_chan   self._sim_recv_chan = sim_recv_chan   self._md_send_chan = md_send_chan   self._md_recv_chan = md_recv_chan   self._pending_peek = False   self._data = Entity() # 数据存储   self._data._instance_entity([])   self._prototype = {    ""quotes"": {     ""#"": BtQuote(self._api), # 行情的数据原型    },    ""klines"": {     ""*"": {      ""*"": {       ""data"": {        ""@"": Kline(self._api), # K线的数据原型       }      }     }    },    ""ticks"": {     ""*"": {      ""data"": {       ""@"": Tick(self._api), # Tick的数据原型      }     }    }   }   self._sended_to_api = {} # 已经发给 api 的 rangeset (symbol, dur)，只记录了 kline   self._serials = {} # 所有用户请求的 chart 序列，如果用户订阅行情，默认请求 1 分钟 Kline   # gc 是会循环 self._serials，来计算用户需要的数据，self._serials 不应该被删除，   self._generators = {} # 所有用户请求的 chart 序列相应的 generator 对象，创建时与 self._serials 一一对应，会在一个序列计算到最后一根 kline 时被删除   self._had_any_generator = False # 回测过程中是否有过 generator 对象   self._sim_recv_chan_send_count = 0 # 统计向下游发送的 diff 的次数，每 1w 次执行一次 gc   self._quotes = {} # 记录 min_duration 记录某一合约的最小duration； sended_init_quote 是否已经过这个合约的初始行情   self._diffs = []   self._is_first_send = True   md_task = self._api.create_task(self._md_handler())   try:    await self._send_snapshot()    async for pack in self._sim_send_chan:     if pack[""aid""] == ""ins_query"":      await self._md_send_chan.send(pack)      # 回测 query 不为空时需要ensure_query      # 1. 在api初始化时会发送初始化请求（2.5.0版本开始已经不再发送初始化请求），接着会发送peek_message，如果这里没有等到结果，那么在收到 peek_message 的时候，会发现没有数据需要发送，回测结束      # 2. api在发送请求后，会调用 wait_update 更新数据，如果这里没有等到结果，行情可能会被推进      # query 为空时，表示清空数据的请求，这个可以直接发出去，不需要等到收到回复      if pack[""query""] != """":       await self._ensure_query(pack)      await self._send_diff()     elif pack[""aid""] == ""subscribe_quote"":      # todo: 回测时，用户如果先订阅日线，再订阅行情，会直接返回以日线 datetime 标识的行情信息，而不是当前真正的行情时间      self._diffs.append({       ""ins_list"": pack[""ins_list""]      })      for ins in pack[""ins_list""].split("",""):       await self._ensure_quote(ins)      await self._send_diff() # 处理上一次未处理的 peek_message     elif pack[""aid""] == ""set_chart"":      if pack[""ins_list""]:       # 回测模块中已保证每次将一个行情时间的数据全部发送给api，因此更新行情时 保持与初始化时一样的charts信息（即不作修改）       self._diffs.append({        ""charts"": {         pack[""chart_id""]: {          # 两个id设置为0：保证api在回测中判断此值时不是-1，即直接通过对数据接收完全的验证          ""left_id"": 0,          ""right_id"": 0,          ""more_data"": False, # 直接发送False给api，表明数据发送完全，使api中通过数据接收完全的验证          ""state"": pack         }        }       })       await self._ensure_serial(pack[""ins_list""], pack[""duration""], pack[""chart_id""])      else:       self._diffs.append({        ""charts"": {         pack[""chart_id""]: None        }       })      await self._send_diff() # 处理上一次未处理的 peek_message     elif pack[""aid""] == ""peek_message"":      self._pending_peek = True      await self._send_diff()   finally:    # 关闭所有 generator    for s in self._generators.values():     await s.aclose()    md_task.cancel()    await asyncio.gather(md_task, return_exceptions=True)  async def _md_handler(self):   async for pack in self._md_recv_chan:    await self._md_send_chan.send({     ""aid"": ""peek_message""    })    for d in pack.get(""data"", []):     _merge_diff(self._data, d, self._prototype, False)     # 收到的 quotes 转发给下游     quotes = d.get(""quotes"", {})     if quotes:      quotes = self._update_valid_quotes(quotes) # 删去回测 quotes 不应该下发的字段      self._diffs.append({""quotes"": quotes})     # 收到的 symbols 应该转发给下游     if d.get(""symbols""):      self._diffs.append({""symbols"": d[""symbols""]})  def _update_valid_quotes(self, quotes):   # 从 quotes 返回只剩余合约信息的字段的 quotes，防止发生未来数据发送给下游   # backtest 模块会生成的数据   invalid_keys = {f""{d}{i+1}"" for d in ['ask_price', 'ask_volume', 'bid_price', 'bid_volume'] for i in range(5)}   invalid_keys.union({'datetime', 'last_price', 'highest', 'lowest', 'average', 'volume', 'amount', 'open_interest'})   # backtest 模块不会生成的数据，下游服务也不应该收到的数据   invalid_keys.union({'open', 'close', 'settlement', 'lowest', 'lower_limit', 'upper_limit', 'pre_open_interest', 'pre_settlement', 'pre_close', 'expired'})   for symbol, quote in quotes.items():    [quote.pop(k, None) for k in invalid_keys]    if symbol.startswith(""KQ.m""):     quote.pop(""underlying_symbol"", None)    if quote.get('expire_datetime'):     # 先删除所有的 quote 的 expired 字段，只在有 expire_datetime 字段时才会添加 expired 字段     quote['expired'] = quote.get('expire_datetime') * 1e9 <= self._trading_day_start   return quotes  async def _send_snapshot(self):   """"""发送初始合约信息""""""   async with TqChan(self._api, last_only=True) as update_chan: # 等待与行情服务器连接成功    self._data[""_listener""].add(update_chan)    while self._data.get(""mdhis_more_data"", True):     await update_chan.recv()   # 发送初始行情(合约信息截面)时   quotes = {}   for ins, quote in self._data[""quotes""].items():    if not ins.startswith(""_""):     trading_time = quote.get(""trading_time"", {})     quotes[ins] = {      ""open"": None, # 填写None: 删除api中的这个字段      ""close"": None,      ""settlement"": None,      ""lower_limit"": None,      ""upper_limit"": None,      ""pre_open_interest"": None,      ""pre_settlement"": None,      ""pre_close"": None,      ""ins_class"": quote.get(""ins_class"", """"),      ""instrument_id"": quote.get(""instrument_id"", """"),      ""exchange_id"": quote.get(""exchange_id"", """"),      ""margin"": quote.get(""margin""), # 用于内部实现模拟交易, 不作为api对外可用数据（即 Quote 类中无此字段）      ""commission"": quote.get(""commission""), # 用于内部实现模拟交易, 不作为api对外可用数据（即 Quote 类中无此字段）      ""price_tick"": quote[""price_tick""],      ""price_decs"": quote[""price_decs""],      ""volume_multiple"": quote[""volume_multiple""],      ""max_limit_order_volume"": quote[""max_limit_order_volume""],      ""max_market_order_volume"": quote[""max_market_order_volume""],      ""min_limit_order_volume"": quote[""min_limit_order_volume""],      ""min_market_order_volume"": quote[""min_market_order_volume""],      ""underlying_symbol"": quote[""underlying_symbol""],      ""strike_price"": quote[""strike_price""],      ""expired"": quote.get('expire_datetime', float('nan')) <= self._trading_day_start, # expired 默认值就是 False      ""trading_time"": {""day"": trading_time.get(""day"", []), ""night"": trading_time.get(""night"", [])},      ""expire_datetime"": quote.get(""expire_datetime""),      ""delivery_month"": quote.get(""delivery_month""),      ""delivery_year"": quote.get(""delivery_year""),      ""option_class"": quote.get(""option_class"", """"),      ""product_id"": quote.get(""product_id"", """"),     }   # 修改历史主连合约信息   dt = datetime.fromtimestamp(self._trading_day_end / 1e9).strftime(""%Y%m%d"")   quotes.update(self._get_history_cont_quotes(dt))   self._diffs.append({    ""quotes"": quotes,    ""ins_list"": """",    ""mdhis_more_data"": False,    ""_tqsdk_backtest"": {     ""start_dt"": self._start_dt,     ""current_dt"": self._current_dt,     ""end_dt"": self._end_dt    }   })  async def _send_diff(self):   """"""发送数据到 api, 如果 self._diffs 不为空则发送 self._diffs, 不推进行情时间, 否则将时间推进一格, 并发送对应的行情""""""   if self._pending_peek:    if not self._diffs:     quotes = await self._generator_diffs(False)    else:     quotes = await self._generator_diffs(True)    for ins, diff in quotes.items():     self._quotes[ins][""sended_init_quote""] = True     for d in diff:      self._diffs.append({       ""quotes"": {        ins: d       }      })    if self._diffs:     # 发送数据集中添加 backtest 字段，开始时间、结束时间、当前时间，表示当前行情推进是由 backtest 推进     if self._is_first_send:      self._diffs.append({       ""_tqsdk_backtest"": {        ""start_dt"": self._start_dt,        ""current_dt"": self._current_dt,        ""end_dt"": self._end_dt       }      })      self._is_first_send = False     else:      self._diffs.append({       ""_tqsdk_backtest"": {        ""current_dt"": self._current_dt       }      })     # 切换交易日，将历史的主连合约信息添加的 diffs     if self._current_dt > self._trading_day_end:      # 使用交易日结束时间，每个交易日切换只需要计算一次交易日结束时间      # 相比发送 diffs 前每次都用 _current_dt 计算当前交易日，计算次数更少      self._trading_day_start = _get_trading_day_start_time(_get_trading_day_from_timestamp(self._current_dt))      self._trading_day_end = _get_trading_day_end_time(_get_trading_day_from_timestamp(self._current_dt))      self._diffs.append({       ""quotes"": self._get_history_cont_quotes(        datetime.fromtimestamp(self._trading_day_end / 1e9).strftime(""%Y%m%d"")       )      })      self._diffs.append({       ""quotes"": {k: {'expired': v.get('expire_datetime', float('nan')) <= self._trading_day_start}         for k, v in self._data.get('quotes').items()}      })     self._sim_recv_chan_send_count += 1     if self._sim_recv_chan_send_count > 10000:      self._sim_recv_chan_send_count = 0      self._diffs.append(self._gc_data())     rtn_data = {      ""aid"": ""rtn_data"",      ""data"": self._diffs,     }     self._diffs = []     self._pending_peek = False     await self._sim_recv_chan.send(rtn_data)  async def _generator_diffs(self, keep_current):   """"""   keep_current 为 True 表示不会推进行情，为 False 表示需要推进行情   即 self._diffs 为 None 并且 keep_current = True 会推进行情   """"""   quotes = {}   while self._generators:    # self._generators 存储了 generator，self._serials 记录一些辅助的信息    min_request_key = min(self._generators.keys(), key=lambda serial: self._serials[serial][""timestamp""])    timestamp = self._serials[min_request_key][""timestamp""] # 所有已订阅数据中的最小行情时间    quotes_diff = self._serials[min_request_key][""quotes""]    if timestamp < self._current_dt and self._quotes.get(min_request_key[0], {}).get(""sended_init_quote""):     # 先订阅 A 合约，再订阅 A 合约日线，那么 A 合约的行情时间会回退: 2021-01-04 09:31:59.999999 -> 2021-01-01 18:00:00.000000     # 如果当前 timestamp 小于 _current_dt，那么这个 quote_diff 不需要发到下游     # 如果先订阅 A 合约（有夜盘），时间停留在夜盘开始时间， 再订阅 B 合约（没有夜盘），那么 B 合约的行情（前一天收盘时间）应该发下去，     # 否则 get_quote(B) 等到收到行情才返回，会直接把时间推进到第二天白盘。     quotes_diff = None    # 推进时间，一次只会推进最多一个(补数据时有可能是0个)行情时间，并确保<=该行情时间的行情都被发出    # 如果行情时间大于当前回测时间 则 判断是否diff中已有数据；否则表明此行情时间的数据未全部保存在diff中，则继续append    if timestamp > self._current_dt:     if self._diffs or keep_current: # 如果diffs中已有数据：退出循环并发送数据给下游api      break     else:      self._current_dt = timestamp # 否则将回测时间更新至最新行情时间    diff = self._serials[min_request_key][""diff""]    self._diffs.append(diff)    # klines 请求，需要记录已经发送 api 的数据    for symbol in diff.get(""klines"", {}):     for dur in diff[""klines""][symbol]:      for kid in diff[""klines""][symbol][dur][""data""]:       rs = self._sended_to_api.setdefault((symbol, int(dur)), [])       kid = int(kid)       self._sended_to_api[(symbol, int(dur))] = _rangeset_range_union(rs, (kid, kid + 1))    quote_info = self._quotes[min_request_key[0]]    if quotes_diff and (quote_info[""min_duration""] != 0 or min_request_key[1] == 0):     quotes[min_request_key[0]] = quotes_diff    await self._fetch_serial(min_request_key)   if self._had_any_generator and not self._generators and not self._diffs: # 当无可发送数据时则抛出BacktestFinished例外,包括未订阅任何行情 或 所有已订阅行情的最后一笔行情获取完成    self._api._print(""回测结束"")    self._logger.debug(""backtest finished"")    if self._current_dt < self._end_dt:     self._current_dt = 2145888000000000000 # 一个远大于 end_dt 的日期 20380101    await self._sim_recv_chan.send({     ""aid"": ""rtn_data"",     ""data"": [{      ""_tqsdk_backtest"": {       ""start_dt"": self._start_dt,       ""current_dt"": self._current_dt,       ""end_dt"": self._end_dt      }     }]    })    await self._api._wait_until_idle()    raise BacktestFinished(self._api) from None   return quotes  def _get_history_cont_quotes(self, dt):   quotes = {}   for symbol, df in self._continuous_table.items():    le = df['date'].le(dt)    if le.any():     quotes[symbol] = {""underlying_symbol"": df[le].iloc[-1]['underlying']}   return quotes  async def _ensure_serial(self, ins, dur, chart_id=None):   if (ins, dur) not in self._serials:    quote = self._quotes.setdefault(ins, { # 在此处设置 min_duration: 每次生成K线的时候会自动生成quote, 记录某一合约的最小duration     ""min_duration"": dur    })    quote[""min_duration""] = min(quote[""min_duration""], dur)    self._serials[(ins, dur)] = {     ""chart_id_set"": {chart_id} if chart_id else set() # 记录当前 serial 对应的 chart_id    }    self._generators[(ins, dur)] = self._gen_serial(ins, dur)    self._had_any_generator = True    await self._fetch_serial((ins, dur))   elif chart_id:    self._serials[(ins, dur)][""chart_id_set""].add(chart_id)  async def _ensure_query(self, pack):   """"""一定收到了对应 query 返回的包""""""   query_pack = {""query"": pack[""query""]}   if query_pack.items() <= self._data.get(""symbols"", {}).get(pack[""query_id""], {}).items():    return   async with TqChan(self._api, last_only=True) as update_chan:    self._data[""_listener""].add(update_chan)    while not query_pack.items() <= self._data.get(""symbols"", {}).get(pack[""query_id""], {}).items():     await update_chan.recv()  async def _ensure_quote(self, ins):   # 在接新版合约服务器后，合约信息程序运行过程中查询得到的，这里不再能保证合约一定存在，需要添加 quote 默认值   quote = _get_obj(self._data, [""quotes"", ins], BtQuote(self._api))   if math.isnan(quote.get(""price_tick"")):    query_pack = _query_for_quote(ins)    await self._md_send_chan.send(query_pack)    async with TqChan(self._api, last_only=True) as update_chan:     quote[""_listener""].add(update_chan)     while math.isnan(quote.get(""price_tick"")):      await update_chan.recv()   if ins not in self._quotes or self._quotes[ins][""min_duration""] > 60000000000:    await self._ensure_serial(ins, 60000000000)  async def _fetch_serial(self, key):   s = self._serials[key]   try:    s[""timestamp""], s[""diff""], s[""quotes""] = await self._generators[key].__anext__()   except StopAsyncIteration:    del self._generators[key] # 删除一个行情时间超过结束时间的 generator  async def _gen_serial(self, ins, dur):   """"""k线/tick 序列的 async generator, yield 出来的行情数据带有时间戳, 因此 _send_diff 可以据此归并""""""   # 先定位左端点, focus_datetime 是 lower_bound ,这里需要的是 upper_bound   # 因此将 view_width 和 focus_position 设置成一样，这样 focus_datetime 所对应的 k线刚好位于屏幕外   # 使用两个长度为 8964 的 chart，去缓存/回收下游需要的数据   chart_id_a = _generate_uuid(""PYSDK_backtest"")   chart_id_b = _generate_uuid(""PYSDK_backtest"")   chart_info = {    ""aid"": ""set_chart"",    ""chart_id"": chart_id_a,    ""ins_list"": ins,    ""duration"": dur,    ""view_width"": 8964, # 设为8964原因：可满足用户所有的订阅长度，并在backtest中将所有的 相同合约及周期 的K线用同一个serial存储    ""focus_datetime"": int(self._current_dt),    ""focus_position"": 8964,   }   chart_a = _get_obj(self._data, [""charts"", chart_id_a])   chart_b = _get_obj(self._data, [""charts"", chart_id_b])   symbol_list = ins.split(',')   current_id = None # 当前数据指针   if dur == 0:    serials = [_get_obj(self._data, [""ticks"", symbol_list[0]])]   else:    serials = [_get_obj(self._data, [""klines"", s, str(dur)]) for s in symbol_list]   async with TqChan(self._api, last_only=True) as update_chan:    for serial in serials:     serial[""_listener""].add(update_chan)    chart_a[""_listener""].add(update_chan)    chart_b[""_listener""].add(update_chan)    await self._md_send_chan.send(chart_info.copy())    try:     async for _ in update_chan:      chart = _get_obj(self._data, [""charts"", chart_info[""chart_id""]])      if not (chart_info.items() <= _get_obj(chart, [""state""]).items()):       # 当前请求还没收齐回应, 不应继续处理       continue      left_id = chart.get(""left_id"", -1)      right_id = chart.get(""right_id"", -1)      if (left_id == -1 and right_id == -1) or chart.get(""more_data"", True):       continue # 定位信息还没收到, 数据没有完全收到      last_id = serials[0].get(""last_id"", -1)      if last_id == -1:       continue # 数据序列还没收到      if self._data.get(""mdhis_more_data"", True):       self._data[""_listener""].add(update_chan)       continue      else:       self._data[""_listener""].discard(update_chan)      if current_id is None:       current_id = max(left_id, 0)      # 发送下一段 chart 8964 根 kline      chart_info[""chart_id""] = chart_id_b if chart_info[""chart_id""] == chart_id_a else chart_id_a      chart_info[""left_kline_id""] = right_id      chart_info.pop(""focus_datetime"", None)      chart_info.pop(""focus_position"", None)      await self._md_send_chan.send(chart_info.copy())      while True:       if current_id > last_id:        # 当前 id 已超过 last_id        return       # 将订阅的8964长度的窗口中的数据都遍历完后，退出循环，然后再次进入并处理下一窗口数据       if current_id > right_id:        break       item = {k: v for k, v in serials[0][""data""].get(str(current_id), {}).items()}       if dur == 0:        diff = {         ""ticks"": {          ins: {           ""last_id"": current_id,           ""data"": {            str(current_id): item,            str(current_id - 8964): None,           }          }         }        }        if item[""datetime""] > self._end_dt: # 超过结束时间         return        yield item[""datetime""], diff, self._get_quotes_from_tick(item)       else:        timestamp = item[""datetime""] if dur < 86400000000000 else _get_trading_day_start_time(         item[""datetime""])        if timestamp > self._end_dt: # 超过结束时间         return        binding = serials[0].get(""binding"", {})        diff = {         ""klines"": {          symbol_list[0]: {           str(dur): {            ""last_id"": current_id,            ""data"": {             str(current_id): {              ""datetime"": item[""datetime""],              ""open"": item[""open""],              ""high"": item[""open""],              ""low"": item[""open""],              ""close"": item[""open""],              ""volume"": 0,              ""open_oi"": item[""open_oi""],              ""close_oi"": item[""open_oi""],             }            }           }          }         }        }        for chart_id in self._serials[(ins, dur)][""chart_id_set""]:         diff[""charts""] = {          chart_id: {           ""right_id"": current_id # api 中处理多合约 kline 需要 right_id 信息          }         }        for i, symbol in enumerate(symbol_list):         if i == 0:          diff_binding = diff[""klines""][symbol_list[0]][str(dur)].setdefault(""binding"", {})          continue         other_id = binding.get(symbol, {}).get(str(current_id), -1)         if other_id >= 0:          diff_binding[symbol] = {str(current_id): str(other_id)}          other_item = serials[i][""data""].get(str(other_id), {})          diff[""klines""][symbol] = {           str(dur): {            ""last_id"": other_id,            ""data"": {             str(other_id): {              ""datetime"": other_item[""datetime""],              ""open"": other_item[""open""],              ""high"": other_item[""open""],              ""low"": other_item[""open""],              ""close"": other_item[""open""],              ""volume"": 0,              ""open_oi"": other_item[""open_oi""],              ""close_oi"": other_item[""open_oi""],             }            }           }          }        yield timestamp, diff, self._get_quotes_from_kline_open(         self._data[""quotes""][symbol_list[0]],         timestamp,         item) # K线刚生成时的数据都为开盘价        timestamp = item[""datetime""] + dur - 1000 \         if dur < 86400000000000 else _get_trading_day_start_time(item[""datetime""] + dur) - 1000        if timestamp > self._end_dt: # 超过结束时间         return        diff = {         ""klines"": {          symbol_list[0]: {           str(dur): {            ""data"": {             str(current_id): item,            }           }          }         }        }        for i, symbol in enumerate(symbol_list):         if i == 0:          continue         other_id = binding.get(symbol, {}).get(str(current_id), -1)         if other_id >= 0:          diff[""klines""][symbol] = {           str(dur): {            ""data"": {             str(other_id): {k: v for k, v in                 serials[i][""data""].get(str(other_id), {}).items()}            }           }          }        yield timestamp, diff, self._get_quotes_from_kline(self._data[""quotes""][symbol_list[0]],                    timestamp,                    item) # K线结束时生成quote数据       current_id += 1    finally:     # 释放chart资源     chart_info[""ins_list""] = """"     await self._md_send_chan.send(chart_info.copy())     chart_info[""chart_id""] = chart_id_b if chart_info[""chart_id""] == chart_id_a else chart_id_a     await self._md_send_chan.send(chart_info.copy())  def _gc_data(self):   # api 应该删除的数据 diff   need_rangeset = {}   for ins, dur in self._serials:    if dur == 0: # tick 在发送数据过程中已经回收内存     continue    symbol_list = ins.split(',')    for s in symbol_list:     need_rangeset.setdefault((s, dur), [])    main_serial = _get_obj(self._data, [""klines"", symbol_list[0], str(dur)])    main_serial_rangeset = self._sended_to_api.get((symbol_list[0], dur), []) # 此 request 还没有给 api 发送过任何数据时为 []    if not main_serial_rangeset:     continue    last_id = main_serial_rangeset[-1][-1] - 1    assert last_id > -1    need_rangeset[(symbol_list[0], dur)] = _rangeset_range_union(need_rangeset[(symbol_list[0], dur)],                   (last_id - 8963, last_id + 1))    for symbol in symbol_list[1:]:     symbol_need_rangeset = []     symbol_binding = main_serial.get(""binding"", {}).get(symbol, {})     if symbol_binding:      for i in range(last_id - 8963, last_id + 1):       other_id = symbol_binding.get(str(i))       if other_id:        symbol_need_rangeset = _rangeset_range_union(symbol_need_rangeset, (other_id, other_id + 1))     if symbol_need_rangeset:      need_rangeset[(symbol, dur)] = _rangeset_union(need_rangeset[(symbol, dur)], symbol_need_rangeset)   gc_rangeset = {}   for key, rs in self._sended_to_api.items():    gc_rangeset[key] = _rangeset_difference(rs, need_rangeset.get(key, []))   # 更新 self._sended_to_api   for key, rs in gc_rangeset.items():    self._sended_to_api[key] = _rangeset_difference(self._sended_to_api[key], rs)   gc_klines_diff = {}   for (symbol, dur), rs in gc_rangeset.items():    gc_klines_diff.setdefault(symbol, {})    gc_klines_diff[symbol][str(dur)] = {""data"": {}}    serial = _get_obj(self._data, [""klines"", symbol, str(dur)])    serial_binding = serial.get(""binding"", None)    if serial_binding:     gc_klines_diff[symbol][str(dur)][""binding""] = {s: {} for s in serial_binding.keys()}    for start_id, end_id in rs:     for i in range(start_id, end_id):      gc_klines_diff[symbol][str(dur)][""data""][str(i)] = None      if serial_binding:       for s, s_binding in serial_binding.items():        gc_klines_diff[symbol][str(dur)][""binding""][s][str(i)] = None   return {""klines"": gc_klines_diff}  @staticmethod  def _get_quotes_from_tick(tick):   quote = {k: v for k, v in tick.items()}   quote[""datetime""] = datetime.fromtimestamp(tick[""datetime""] / 1e9).strftime(""%Y-%m-%d %H:%M:%S.%f"")   return [quote]  @staticmethod  def _get_quotes_from_kline_open(info, timestamp, kline):   return [    { # K线刚生成时的数据都为开盘价     ""datetime"": datetime.fromtimestamp(timestamp / 1e9).strftime(""%Y-%m-%d %H:%M:%S.%f""),     ""ask_price1"": kline[""open""] + info[""price_tick""],     ""ask_volume1"": 1,     ""bid_price1"": kline[""open""] - info[""price_tick""],     ""bid_volume1"": 1,     ""last_price"": kline[""open""],     ""highest"": float(""nan""),     ""lowest"": float(""nan""),     ""average"": float(""nan""),     ""volume"": 0,     ""amount"": float(""nan""),     ""open_interest"": kline[""open_oi""],    },   ]  @staticmethod  def _get_quotes_from_kline(info, timestamp, kline):   """"""   分为三个包发给下游：   1. 根据 diff 协议，对于用户收到的最终结果没有影响   2. TqSim 撮合交易会按顺序处理收到的包，分别比较 high、low、close 三个价格对应的买卖价   3. TqSim 撮合交易只用到了买卖价，所以最新价只产生一次 close，而不会发送三次   """"""   return [    {     ""datetime"": datetime.fromtimestamp(timestamp / 1e9).strftime(""%Y-%m-%d %H:%M:%S.%f""),     ""ask_price1"": kline[""high""] + info[""price_tick""],     ""ask_volume1"": 1,     ""bid_price1"": kline[""high""] - info[""price_tick""],     ""bid_volume1"": 1,     ""last_price"": kline[""close""],     ""highest"": float(""nan""),     ""lowest"": float(""nan""),     ""average"": float(""nan""),     ""volume"": 0,     ""amount"": float(""nan""),     ""open_interest"": kline[""close_oi""],    },    {     ""ask_price1"": kline[""low""] + info[""price_tick""],     ""bid_price1"": kline[""low""] - info[""price_tick""],    },    {     ""ask_price1"": kline[""close""] + info[""price_tick""],     ""bid_price1"": kline[""close""] - info[""price_tick""],    }   ] class TqReplay(object):  """"""天勤复盘类""""""  def __init__(self, replay_dt: date):   """"""   除了传统的回测模式以外，TqSdk 提供独具特色的复盘模式，它与回测模式有以下区别   1.复盘模式为时间驱动，回测模式为事件驱动   复盘模式下，你可以指定任意一天交易日，后端行情服务器会传输用户订阅合约的当天的所有历史行情数据，重演当天行情，而在回测模式下，我们根据用户订阅的合约周期数据来进行推送   因此在复盘模式下K线更新和实盘一模一样，而回测模式下就算订阅了 Tick 数据，回测中任意周期 K 线最后一根的 close 和其他数据也不会随着 Tick 更新而更新，而是随着K线频率生成和结束时更新一次   2.复盘和回测的行情速度   因为两者的驱动机制不同，回测会更快，但是我们在复盘模式下也提供行情速度调节功能，可以结合web_gui来实现   3.复盘目前只支持单日复盘   因为复盘提供对应合约当日全部历史行情数据，对后端服务器会有较大压力，目前只支持复盘模式下选择单日进行复盘   Args:    replay_dt (date): 指定复盘交易日   """"""   if isinstance(replay_dt, date):    self._replay_dt = replay_dt   else:    raise Exception(""复盘时间(dt)类型 %s 错误, 请检查 dt 数据类型是否填写正确"" % (type(replay_dt)))   if self._replay_dt.weekday() >= 5:    # 0~6, 检查周末[5,6] 提前抛错退出    raise Exception(""无法创建复盘服务器，请检查复盘日期后重试。"")   self._default_speed = 1   self._api = None  def _create_server(self, api):   self._api = api   self._logger = api._logger.getChild(""TqReplay"") # 调试信息输出   self._logger.debug('replay prepare', replay_dt=self._replay_dt)   session = self._prepare_session()   self._session_url = ""http://%s:%d/t/rmd/replay/session/%s"" % (    session[""ip""], session[""session_port""], session[""session""])   self._ins_url = ""http://%s:%d/t/rmd/replay/session/%s/symbol"" % (    session[""ip""], session[""session_port""], session[""session""])   self._md_url = ""ws://%s:%d/t/rmd/front/mobile"" % (session[""ip""], session[""gateway_web_port""])   self._server_status = None   self._server_status = self._wait_server_status(""running"", 60)   if self._server_status == ""running"":    self._logger.debug('replay start successed', replay_dt=self._replay_dt)    return self._ins_url, self._md_url   else:    self._logger.debug('replay start failed', replay_dt=self._replay_dt)    raise Exception(""无法创建复盘服务器，请检查复盘日期后重试。"")  async def _run(self):   try:    self._send_chan = TqChan(self._api)    self._send_chan.send_nowait({""aid"": ""ratio"", ""speed"": self._default_speed})    _senddata_task = self._api.create_task(self._senddata_handler())    while True:     await self._send_chan.send({""aid"": ""heartbeat""})     await asyncio.sleep(30)   finally:    await self._send_chan.close()    _senddata_task.cancel()    await asyncio.gather(_senddata_task, return_exceptions=True)  def _prepare_session(self):   create_session_url = ""http://replay.api.shinnytech.com/t/rmd/replay/create_session""   response = requests.post(create_session_url,         headers=self._api._base_headers,         data=json.dumps({'dt': self._replay_dt.strftime(""%Y%m%d"")}),         timeout=5)   if response.status_code == 200:    return json.loads(response.content)   else:    raise Exception(""创建复盘服务器失败，请检查复盘日期后重试。"")  def _wait_server_status(self, target_status, timeout):   """"""等服务器状态为 target_status，超时时间 timeout 秒""""""   deadline = time.time() + timeout   server_status = self._get_server_status()   while deadline > time.time():    if target_status == server_status:     break    else:     time.sleep(1)     server_status = self._get_server_status()   return server_status  def _get_server_status(self):   try:    response = requests.get(self._session_url,          headers=self._api._base_headers,          timeout=5)    if response.status_code == 200:     return json.loads(response.content)[""status""]    else:     raise Exception(""无法创建复盘服务器，请检查复盘日期后重试。"")   except requests.exceptions.ConnectionError as e:    # 刚开始 _session_url 还不能访问的时候～    return None  async def _senddata_handler(self):   try:    session = aiohttp.ClientSession(headers=self._api._base_headers)    async for data in self._send_chan:     await session.post(self._session_url, data=json.dumps(data))   finally:    await session.post(self._session_url, data=json.dumps({""aid"": ""terminate""}))    await session.close()  def set_replay_speed(self, speed: float = 10.0) -> None:   """"""   调整复盘服务器行情推进速度   Args:    speed (float): 复盘服务器行情推进速度, 默认为 10.0   Example::    from datetime import date    from tqsdk import TqApi, TqAuth, TqReplay    replay = TqReplay(date(2020, 9, 10))    api = TqApi(backtest=replay, auth=(""信易账户,账户密码""))    replay.set_replay_speed(3.0)    quote = api.get_quote(""SHFE.cu2012"")    while True:     api.wait_update()     if api.is_changing(quote):      print(""最新价"", quote.datetime, quote.last_price)   """"""   if self._api:    self._send_chan.send_nowait({""aid"": ""ratio"", ""speed"": speed})   else:    # _api 未初始化，只记录用户设定的速度，在复盘服务器启动完成后，发动请求    self._default_speed = speed "
77,n\tqsdk\baseAp,"n\tqsdk\baseAp. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' import asyncio import functools import sys import time from asyncio import Future from typing import Optional, Coroutine class TqBaseApi(object):  """"""  天勤基类，处理 EventLoop 相关的调用  """"""  def __init__(self, loop: Optional[asyncio.AbstractEventLoop] = None) -> None:   """"""   创建天勤接口实例   Args:    loop(asyncio.AbstractEventLoop): [可选] 使用指定的 IOLoop, 默认创建一个新的.   """"""   self._loop = asyncio.SelectorEventLoop() if loop is None else loop # 创建一个新的 ioloop, 避免和其他框架/环境产生干扰   self._event_rev, self._check_rev = 0, 0   self._wait_idle_list = [] # 所有等待 loop idle 的 Future   self._wait_timeout = False # wait_update 是否触发超时   self._tasks = set() # 由api维护的所有根task，不包含子task，子task由其父task维护   self._exceptions = [] # 由api维护的所有task抛出的例外   # 回测需要行情和交易 lockstep, 而 asyncio 没有将内部的 _ready 队列暴露出来,   # 因此 monkey patch call_soon 函数用来判断是否有任务等待执行   self._loop.call_soon = functools.partial(self._call_soon, self._loop.call_soon)   # Windows系统下asyncio不支持KeyboardInterrupt的临时补丁   if sys.platform.startswith(""win""):    self._create_task(self._windows_patch())  def _create_task(self, coro: Coroutine, _caller_api: bool = False) -> asyncio.Task:   task = self._loop.create_task(coro)   py_ver = sys.version_info   current_task = asyncio.Task.current_task(loop=self._loop) if (py_ver.major == 3 and py_ver.minor < 7) else asyncio.current_task(loop=self._loop)   if current_task is None or _caller_api: # 由 api 创建的 task，需要 api 主动管理    self._tasks.add(task)    task.add_done_callback(self._on_task_done)   return task  def _call_soon(self, org_call_soon, callback, *args, **kargs):   """"""ioloop.call_soon的补丁, 用来追踪是否有任务完成并等待执行""""""   self._event_rev += 1   return org_call_soon(callback, *args, **kargs)  def _run_once(self):   """"""执行 ioloop 直到 ioloop.stop 被调用""""""   if not self._exceptions:    self._loop.run_forever()   if self._exceptions:    raise self._exceptions.pop(0)  def _run_until_idle(self, async_run=False):   """"""执行 ioloop 直到没有待执行任务   async_run is True 会从 _wait_idle_list 中取出等待的异步任务，保证同步代码优先于异步代码执行，   只有被 _run_until_task_done 调用（即 api 等待 fetch_msg）时，async_run 会为 True   """"""   while self._check_rev != self._event_rev:    check_handle = self._loop.call_soon(self._check_event, self._event_rev + 1)    try:     self._run_once()    finally:     check_handle.cancel()   if len(self._wait_idle_list) > 0 and async_run:    f = self._wait_idle_list.pop(0) # 取出 list 中的第一个 Future    f.set_result(None) # f 返回  async def _wait_until_idle(self):   """"""等待 ioloop 执行到空闲时，才从网络连接处收数据包，在 TqConnect 类中使用""""""   f = Future()   self._wait_idle_list.append(f)   self._loop.stop()   await f  def _run_until_task_done(self, task: asyncio.Task, deadline=None):   try:    self._wait_timeout = False    if deadline is not None:     deadline_handle = self._loop.call_later(max(0, deadline - time.time()), self._set_wait_timeout)    while not self._wait_timeout and not task.done():     if len(self._wait_idle_list) == 0:      self._run_once()     else:      self._run_until_idle(async_run=True)   finally:    if deadline is not None:     deadline_handle.cancel()    task.cancel()  def _check_event(self, rev):   self._check_rev = rev   self._loop.stop()  def _set_wait_timeout(self):   self._wait_timeout = True   self._loop.stop()  def _on_task_done(self, task):   """"""当由 api 维护的 task 执行完成后取出运行中遇到的例外并停止 ioloop""""""   try:    exception = task.exception()    if exception:     self._exceptions.append(exception)   except asyncio.CancelledError:    pass   finally:    self._tasks.remove(task)    self._loop.stop()  async def _windows_patch(self):   """"""Windows系统下asyncio不支持KeyboardInterrupt的临时补丁, 详见 https://bugs.python.org/issue23057""""""   while True:    await asyncio.sleep(1)  def _close(self) -> None:   self._run_until_idle(async_run=False) # 由于有的处于 ready 状态 task 可能需要报撤单, 因此一直运行到没有 ready 状态的 task   for task in self._tasks:    task.cancel()   while self._tasks: # 等待 task 执行完成    self._run_once()   self._loop.run_until_complete(self._loop.shutdown_asyncgens())   self._loop.close() "
78,n\tqsdk\baseModul,"n\tqsdk\baseModul. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' import asyncio from abc import abstractmethod class TqModule(object):  async def _run(self, api, api_send_chan, api_recv_chan, *args):   """"""   可以接入 n 个上游，1 个下游   """"""   assert len(args) % 2 == 0 and len(args) > 0   self._diffs = []   self._up_chans = [{""send_chan"": args[i], ""recv_chan"": args[i + 1]} for i in range(0, len(args), 2)]   self._up_pending_peek = [False for _ in self._up_chans] # 是否有发给上游的 peek_message，未收到过回复   self._pending_peek = False # 是否有下游收到未处理的 peek_message   up_handle_tasks = [    api.create_task(self._up_handler(api_send_chan, item[""recv_chan""], chan_index=i))    for i, item in enumerate(self._up_chans)    ]   try:    async for pack in api_send_chan:     if pack[""aid""] == ""peek_message"":      # 处理下游发送的 peek_message      self._pending_peek = True      await self._send_diff(api_recv_chan)      if self._pending_peek:       for i, pending_peek in enumerate(self._up_pending_peek):        if pending_peek is False:         # 控制""peek_message""发送: 下游发送了 peek_message，并且上游没有 pending_peek 才会发送         await self._up_chans[i][""send_chan""].send({""aid"": ""peek_message""})         self._up_pending_peek[i] = True     elif pack.get('_up_chan_index', None) is not None:      # 处理上游发送的数据包      _up_chan_index = pack.pop(""_up_chan_index"")      await self._handle_recv_data(pack, self._up_chans[_up_chan_index][""recv_chan""])      await self._send_diff(api_recv_chan)     else:      # 处理下游发送的其他请求      await self._handle_req_data(pack)      await self._send_diff(api_recv_chan)   finally:    [task.cancel() for task in up_handle_tasks]    await asyncio.gather(*up_handle_tasks, return_exceptions=True)  async def _up_handler(self, api_send_chan, recv_chan, chan_index):   async for pack in recv_chan:    pack['_up_chan_index'] = chan_index    if pack['aid'] == 'rtn_data':     self._up_pending_peek[chan_index] = False    await api_send_chan.send(pack)  async def _send_diff(self, api_recv_chan):   pk = self._pending_peek   if self._pending_peek and self._diffs:    rtn_data = {     ""aid"": ""rtn_data"",     ""data"": self._diffs,    }    self._diffs = []    self._pending_peek = False    await api_recv_chan.send(rtn_data)   await self._on_send_diff(pk)  @abstractmethod  async def _handle_recv_data(self, pack, chan):   """"""   处理所有上游收到的数据包，这里应该将需要发送给下游的数据 append 到 self._diffs   pack: 收到的数据包   chan: 收到此数据包的 channel   """"""   pass  @abstractmethod  async def _handle_req_data(self, pack):   """"""   处理所有下游发送的非 peek_message 数据包   这里应该将发送的请求转发到指定的某个上游 channel   """"""   pass  async def _on_send_diff(self, peeding_pk):   """"""   TqModule 调用 _send_diff 时，最后会执行的回调函数；   TqModule 处理所有 pack 都会调用 self._send_diff()，可以在此处处理额外业务逻辑。   pending_peek 表示调用 _send_diff 时，self._pending_peek 的值   """"""   pass "
79,n\tqsdk\calenda,"n\tqsdk\calenda. #!/usr/bin/env python # -*- coding: utf-8 -*- """""" 交易日历处理 """""" __author__ = 'mayanqiong' import os from datetime import date, datetime from typing import Union, List import pandas as pd import requests rest_days_df = None chinese_holidays_range = None def _init_chinese_rest_days(headers=None):  global rest_days_df, chinese_holidays_range  if rest_days_df is None:   url = os.getenv(""TQ_CHINESE_HOLIDAY_URL"", ""https://files.shinnytech.com/shinny_chinese_holiday.json"")   rsp = requests.get(url, timeout=30, headers=headers)   chinese_holidays = rsp.json()   _first_day = date(int(chinese_holidays[0].split('-')[0]), 1, 1) # 首个日期所在年份的第一天   _last_day = date(int(chinese_holidays[-1].split('-')[0]), 12, 31) # 截止日期所在年份的最后一天   chinese_holidays_range = (_first_day, _last_day)   rest_days_df = pd.DataFrame(data={'date': pd.Series(pd.to_datetime(chinese_holidays, format='%Y-%m-%d'))})   rest_days_df['trading_restdays'] = False # 节假日为 False  return chinese_holidays_range def _get_trading_calendar(start_dt: date, end_dt: date, headers=None):  """"""  获取一段时间内，每天是否是交易日  :return: DataFrame   date trading  2019-12-05 True  2019-12-06 True  2019-12-07 False  2019-12-08 False  2019-12-09 True  """"""  _init_chinese_rest_days(headers=headers)  df = pd.DataFrame()  df['date'] = pd.Series(pd.date_range(start=start_dt, end=end_dt, freq=""D""))  df['trading'] = df['date'].dt.dayofweek.lt(5)  result = pd.merge(rest_days_df, df, sort=True, how=""right"", on=""date"")  result.fillna(True, inplace=True)  df['trading'] = result['trading'] & result['trading_restdays']  return df class TqContCalendar(object):  """"""  主连日历  df:   date trading KQ.m@DCE.a KQ.m@DCE.eg  2019-12-06 True DCE.a2005 DCE.eg2001  2019-12-09 True DCE.a2005 DCE.eg2001  2019-12-10 True DCE.a2005 DCE.eg2005  2019-12-11 True DCE.a2005 DCE.eg2005  2019-12-12 True DCE.a2005 DCE.eg2005  """"""  continuous = None  def __init__(self, start_dt: date, end_dt: date, symbols: Union[List[str], None] = None, headers=None) -> None:   """"""   初始化主连日历表   :param date start_dt: 开始交易日日期   :param date end_dt: 结束交易日日期   :param list[str] symbols: 主连合约列表   :return:   """"""   self.df = _get_trading_calendar(start_dt=start_dt, end_dt=end_dt, headers=headers)   self.df = self.df.loc[self.df.trading, ['date']] # 只保留交易日   self.df.reset_index(inplace=True, drop=True)   if TqContCalendar.continuous is None:    rsp = requests.get(os.getenv(""TQ_CONT_TABLE_URL"", ""https://files.shinnytech.com/continuous_table.json""), headers=headers) # 下载历史主连合约信息    rsp.raise_for_status()    TqContCalendar.continuous = {f""KQ.m@{k}"": v for k, v in rsp.json().items()}   if symbols is not None:    if not all([s in TqContCalendar.continuous.keys() for s in symbols]):     raise Exception(f""参数错误，symbols={symbols} 中应该全部都是主连合约代码"")   symbols = TqContCalendar.continuous.keys() if symbols is None else symbols   self.start_dt, self.end_dt = self.df.iloc[0].date, self.df.iloc[-1].date   for s in symbols:    self._ensure_cont_on_df(s)  def _ensure_cont_on_df(self, cont):   """"""将一个主连对应的标的填在 self.df 对应位置""""""   temp_df = pd.DataFrame(data=TqContCalendar.continuous[cont], columns=['date', 'underlying'])   temp_df['date'] = pd.Series(pd.to_datetime(temp_df['date'], format='%Y%m%d'))   merge_result = pd.merge(temp_df, self.df, sort=True, how=""outer"", on=""date"")   merge_result.fillna(method=""ffill"", inplace=True)   merge_result.fillna(value="""", inplace=True)   s = merge_result.loc[merge_result.date.ge(self.start_dt) & merge_result.date.le(self.end_dt), 'underlying']   self.df[cont] = pd.Series(s.values)  def _get_cont_underlying_on_date(self, dt: datetime):   """"""返回某一交易日的全部主连""""""   df = self.df.loc[self.df.date.ge(dt), :]   return df.iloc[0:1] "
80,n\tqsdk\channe,"n\tqsdk\channe. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' import asyncio import sys from logging import Logger from typing import Any, TYPE_CHECKING, Union from shinny_structlog import ShinnyLoggerAdapter if TYPE_CHECKING:  from tqsdk.api import TqApi class TqChan(asyncio.Queue):  """"""  用于协程间通讯的channel  默认 TqChan._level = 0 ，打印日志时，tqsdk 内部 chan 发送的数据不会打印在日志文件中；  测试或开发需要打印 chan 内部数据，可以在代码开始增加  ```  from tqsdk import TqChan  TqChan._level = 10  ```  """"""  _chan_id: int = 0  _level: int = 0  def __init__(self, api: 'TqApi', last_only: bool = False, logger: Union[Logger, ShinnyLoggerAdapter, None] = None,     chan_name: str = """") -> None:   """"""   创建channel实例   Args:    api (tqsdk.api.TqApi): TqApi 实例    last_only (bool): 为True时只存储最后一个发送到channel的对象   """"""   logger = logger if logger else api._logger   if isinstance(logger, Logger):    self._logger = ShinnyLoggerAdapter(logger, chan_id=TqChan._chan_id, chan_name=chan_name)   elif isinstance(logger, ShinnyLoggerAdapter):    self._logger = logger.bind(chan_id=TqChan._chan_id, chan_name=chan_name)   TqChan._chan_id += 1   py_ver = sys.version_info   asyncio.Queue.__init__(self, loop=api._loop) if (py_ver.major == 3 and py_ver.minor < 10) else asyncio.Queue.__init__(self)   self._last_only = last_only   self._closed = False  def _logger_bind(self, **kwargs):   self._logger = self._logger.bind(**kwargs)  async def close(self) -> None:   """"""   关闭channel   关闭后send将不起作用,recv在收完剩余数据后会立即返回None   """"""   if not self._closed:    self._closed = True    await asyncio.Queue.put(self, None)  async def send(self, item: Any) -> None:   """"""   异步发送数据到channel中   Args:    item (any): 待发送的对象   """"""   if not self._closed:    if self._last_only:     while not self.empty():      asyncio.Queue.get_nowait(self)    await asyncio.Queue.put(self, item)    self._logger.log(TqChan._level, ""tqchan send"", item=item)  def send_nowait(self, item: Any) -> None:   """"""   尝试立即发送数据到channel中   Args:    item (any): 待发送的对象   Raises:    asyncio.QueueFull: 如果channel已满则会抛出 asyncio.QueueFull   """"""   if not self._closed:    if self._last_only:     while not self.empty():      asyncio.Queue.get_nowait(self)    asyncio.Queue.put_nowait(self, item)    self._logger.log(TqChan._level, ""tqchan send_nowait"", item=item)  async def recv(self) -> Any:   """"""   异步接收channel中的数据，如果channel中没有数据则一直等待   Returns:    any: 收到的数据，如果channel已被关闭则会立即收到None   """"""   if self._closed and self.empty():    return None   item = await asyncio.Queue.get(self)   self._logger.log(TqChan._level, ""tqchan recv"", item=item)   return item  def recv_nowait(self) -> Any:   """"""   尝试立即接收channel中的数据   Returns:    any: 收到的数据，如果channel已被关闭则会立即收到None   Raises:    asyncio.QueueFull: 如果channel中没有数据则会抛出 asyncio.QueueEmpty   """"""   if self._closed and self.empty():    return None   item = asyncio.Queue.get_nowait(self)   self._logger.log(TqChan._level, ""tqchan recv_nowait"", item=item)   return item  def recv_latest(self, latest: Any) -> Any:   """"""   尝试立即接收channel中的最后一个数据   Args:    latest (any): 如果当前channel中没有数据或已关闭则返回该对象   Returns:    any: channel中的最后一个数据   """"""   while (self._closed and self.qsize() > 1) or (not self._closed and not self.empty()):    latest = asyncio.Queue.get_nowait(self)   self._logger.log(TqChan._level, ""tqchan recv_latest"", item=latest)   return latest  def __aiter__(self):   return self  async def __anext__(self):   value = await asyncio.Queue.get(self)   if self._closed and self.empty():    raise StopAsyncIteration   self._logger.log(TqChan._level, ""tqchan recv_next"", item=value)   return value  async def __aenter__(self):   return self  async def __aexit__(self, exc_type, exc, tb):   await self.close() "
81,n\tqsdk\connec,"n\tqsdk\connec. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' import asyncio import json import random import ssl import time import warnings from abc import abstractmethod from datetime import datetime from logging import Logger from queue import Queue from typing import Optional import certifi import websockets from shinny_structlog import ShinnyLoggerAdapter from tqsdk.diff import _merge_diff, _get_obj from tqsdk.entity import Entity from tqsdk.exceptions import TqBacktestPermissionError from tqsdk.utils import _generate_uuid """""" 优化代码结构，修改为 TqConnect （负责连接 websocket 连接，从服务器收到数据发回下游，从下游收到指令包发给上游，生成连接建立、连接断开的通知发给下游） ｜ ｜ TqReconnectHandler (连通上下游，记录重连发生时需要重新发送的数据，在发生重连时，暂停接受下游数据、暂停转发上游数据到下游，直到从上游收到的数据集是完整数据截面，继续恢复工作) ｜ ｜ xxxxxx ｜ ｜ api """""" class ReconnectTimer(object):  def __init__(self):   # 记录最大的下次重连的时间, 所有的 ws 连接，共用一个下次发起重连的时间，这个时间只会不断增大   self.timer = time.time() + random.uniform(10, 20)  def set_count(self, count):   if self.timer < time.time():    seconds = min(2 ** count, 64) * 10 # 最大是在 1280s ～ 2560s 之间    self.timer = time.time() + random.uniform(seconds, seconds * 2) class TqStreamReader(asyncio.StreamReader):  def __init__(self, *args, **kwargs):   super(TqStreamReader, self).__init__(*args, **kwargs)   self._start_read_message = None   self._read_size = 0  async def readexactly(self, n):   data = await super(TqStreamReader, self).readexactly(n)   if not self._start_read_message:    self._start_read_message = time.time()   self._read_size += n   return data class TqWebSocketClientProtocol(websockets.WebSocketClientProtocol):  def __init__(self, *args, **kwargs):   super(TqWebSocketClientProtocol, self).__init__(*args, **kwargs)   self.reader = TqStreamReader(limit=self.read_limit // 2, loop=self.loop)  async def handshake(self, *args, **kwargs) -> None:   try:    await super(TqWebSocketClientProtocol, self).handshake(*args, **kwargs)   except websockets.exceptions.InvalidStatusCode as e:    for h_key, h_value in self.response_headers.items():     if h_key == 'x-shinny-auth-check' and h_value == 'Backtest Permission Denied':      raise TqBacktestPermissionError(       ""免费账户每日可以回测3次，今日暂无回测权限，需要购买专业版本后使用。升级网址：https://account.shinnytech.com"") from None    raise  async def read_message(self):   message = await super().read_message()   self.reader._start_read_message = None   self.reader._read_size = 0   return message class TqConnect(object):  """"""用于与 websockets 服务器通讯""""""  def __init__(self, logger, conn_id: Optional[str] = None) -> None:   """"""   创建 TqConnect 实例   """"""   self._conn_id = conn_id if conn_id else _generate_uuid()   self._logger = logger   if isinstance(logger, Logger):    self._logger = ShinnyLoggerAdapter(logger, conn_id=self._conn_id)   elif isinstance(logger, ShinnyLoggerAdapter):    self._logger = logger.bind(conn_id=self._conn_id)   self._first_connect = True   self._keywords = {""max_size"": None}  async def _run(self, api, url, send_chan, recv_chan):   """"""启动websocket客户端""""""   self._api = api   # 调整代码位置，方便 monkey patch   self._ins_list_max_length = 100000 # subscribe_quote 最大长度   self._subscribed_per_seconds = 100 # 每秒 subscribe_quote 请求次数限制   self._subscribed_queue = Queue(self._subscribed_per_seconds)   self._keywords[""extra_headers""] = self._api._base_headers   self._keywords[""create_protocol""] = TqWebSocketClientProtocol   if url.startswith(""wss://""):    ssl_context = ssl.create_default_context()    ssl_context.load_verify_locations(certifi.where())    self._keywords[""ssl""] = ssl_context   count = 0   while True:    try:     if not self._first_connect:      notify_id = _generate_uuid()      notify = {       ""type"": ""MESSAGE"",       ""level"": ""WARNING"",       ""code"": 2019112910,       ""conn_id"": self._conn_id,       ""content"": f""开始与 {url} 的重新建立网络连接"",       ""url"": url      }      self._logger.debug(""websocket connection connecting"")      await recv_chan.send({       ""aid"": ""rtn_data"",       ""data"": [{        ""notify"": {         notify_id: notify        }       }]      })     async with websockets.connect(url, **self._keywords) as client:      # 发送网络连接建立的通知，code = 2019112901      notify_id = _generate_uuid()      notify = {       ""type"": ""MESSAGE"",       ""level"": ""INFO"",       ""code"": 2019112901,       ""conn_id"": self._conn_id,       ""content"": ""与 %s 的网络连接已建立"" % url,       ""url"": url      }      if not self._first_connect: # 如果不是第一次连接, 即为重连       # 发送网络连接重新建立的通知，code = 2019112902       notify[""code""] = 2019112902       notify[""level""] = ""WARNING""       notify[""content""] = ""与 %s 的网络连接已恢复"" % url       self._logger.debug(""websocket reconnected"")      else:       self._logger.debug(""websocket connected"")      # 发送网络连接建立的通知，code = 2019112901 or 2019112902，这里区分了第一次连接和重连      await self._api._wait_until_idle()      await recv_chan.send({       ""aid"": ""rtn_data"",       ""data"": [{        ""notify"": {         notify_id: notify        }       }]      })      count = 0      self._api._reconnect_timer.set_count(count)      send_task = self._api.create_task(self._send_handler(send_chan, client))      try:       async for msg in client:        pack = json.loads(msg)        await self._api._wait_until_idle()        self._logger.debug(""websocket received data"", pack=msg)        await recv_chan.send(pack)      finally:       self._logger.debug(""websocket connection info"", current_time=time.time(),           start_read_message=client.reader._start_read_message,           read_size=client.reader._read_size)       send_task.cancel()       await send_task    # 希望做到的效果是遇到网络问题可以断线重连, 但是可能抛出的例外太多了(TimeoutError,socket.gaierror等), 又没有文档或工具可以理出 try 代码中所有可能遇到的例外    # 而这里的 except 又需要处理所有子函数及子函数的子函数等等可能抛出的例外, 因此这里只能遇到问题之后再补, 并且无法避免 false positive 和 false negative    except (websockets.exceptions.ConnectionClosed, websockets.exceptions.InvalidStatusCode,      websockets.exceptions.InvalidState, websockets.exceptions.ProtocolError, OSError, EOFError,      TqBacktestPermissionError) as e:     in_ops_time = datetime.now().hour == 19 and 0 <= datetime.now().minute <= 30     # 发送网络连接断开的通知，code = 2019112911     notify_id = _generate_uuid()     notify = {      ""type"": ""MESSAGE"",      ""level"": ""WARNING"",      ""code"": 2019112911,      ""conn_id"": self._conn_id,      ""content"": f""与 {url} 的网络连接断开，请检查客户端及网络是否正常"",      ""url"": url     }     if in_ops_time:      notify['content'] += '，每日 19:00-19:30 为日常运维时间，请稍后再试'     self._logger.debug(""websocket connection closed"", error=str(e))     await recv_chan.send({      ""aid"": ""rtn_data"",      ""data"": [{       ""notify"": {        notify_id: notify       }      }]     })     if isinstance(e, TqBacktestPermissionError):      # 如果错误类型是用户无回测权限，直接返回      raise     if self._first_connect and in_ops_time:      raise Exception(f'与 {url} 的连接失败，每日 19:00-19:30 为日常运维时间，请稍后再试')     if self._first_connect:      self._first_connect = False     # 下次重连的时间距离现在当前时间秒数，会等待相应的时间，否则立即发起重连     sleep_seconds = self._api._reconnect_timer.timer - time.time()     if sleep_seconds > 0:      await asyncio.sleep(sleep_seconds)     count += 1     self._api._reconnect_timer.set_count(count)  async def _send_handler(self, send_chan, client):   """"""websocket客户端数据发送协程""""""   try:    async for pack in send_chan:     if pack.get(""aid"") == ""subscribe_quote"":      if len(pack.get(""ins_list"", """")) > self._ins_list_max_length:       warnings.warn(f""订阅合约字符串总长度大于 {self._ins_list_max_length}，可能会引起服务器限制。"", stacklevel=3)      if self._subscribed_queue.full():       first_time = self._subscribed_queue.get()       if time.time() - first_time < 1:        warnings.warn(f""1s 内订阅请求次数超过 {self._subscribed_per_seconds} 次，订阅多合约时推荐使用 api.get_quote_list 方法。"", stacklevel=3)      self._subscribed_queue.put(time.time())     msg = json.dumps(pack)     await client.send(msg)     self._logger.debug(""websocket send data"", pack=msg)   except asyncio.CancelledError: # 取消任务不抛出异常，不然等待者无法区分是该任务抛出的取消异常还是有人直接取消等待者    pass class TqReconnect(object):  def __init__(self, logger):   self._logger = logger   self._resend_request = {} # 重连时需要重发的请求   self._un_processed = False # 重连后尚未处理完标志   self._pending_diffs = []   self._data = Entity()   self._data._instance_entity([])  async def _run(self, api, api_send_chan, api_recv_chan, ws_send_chan, ws_recv_chan):   self._api = api   send_task = self._api.create_task(self._send_handler(api_send_chan, ws_send_chan))   try:    async for pack in ws_recv_chan:     self._record_upper_data(pack)     if self._un_processed: # 处理重连后数据      pack_data = pack.get(""data"", [])      self._pending_diffs.extend(pack_data)      for d in pack_data:       # _merge_diff 之后， self._data 会用于判断是否接收到了完整截面数据       _merge_diff(self._data, d, self._api._prototype, persist=False, reduce_diff=False)      if self._is_all_received():       # 重连后收到完整数据截面       self._un_processed = False       pack = {        ""aid"": ""rtn_data"",        ""data"": self._pending_diffs       }       await api_recv_chan.send(pack)       self._logger = self._logger.bind(status=self._status)       self._logger.debug(""data completed"", pack=pack)      else:       await ws_send_chan.send({""aid"": ""peek_message""})       self._logger.debug(""wait for data completed"", pack={""aid"": ""peek_message""})     else:      is_reconnected = False      for i in range(len(pack.get(""data"", []))):       for _, notify in pack[""data""][i].get(""notify"", {}).items():        if notify[""code""] == 2019112902: # 重连建立         is_reconnected = True         self._un_processed = True         self._logger = self._logger.bind(status=self._status)         if i > 0:          ws_send_chan.send_nowait({           ""aid"": ""rtn_data"",           ""data"": pack.get(""data"", [])[0:i]          })         self._pending_diffs = pack.get(""data"", [])[i:]         break      if is_reconnected:       self._data = Entity()       self._data._instance_entity([])       for d in self._pending_diffs:        _merge_diff(self._data, d, self._api._prototype, persist=False, reduce_diff=False)       # 发送所有 resend_request       for msg in self._resend_request.values():        # 这里必须用 send_nowait 而不是 send，因为如果使用异步写法，在循环中，代码可能执行到 send_task, 可能会修改 _resend_request        ws_send_chan.send_nowait(msg)        self._logger.debug(""resend request"", pack=msg)       await ws_send_chan.send({""aid"": ""peek_message""})      else:       await api_recv_chan.send(pack)   finally:    send_task.cancel()    await asyncio.gather(send_task, return_exceptions=True)  async def _send_handler(self, api_send_chan, ws_send_chan):   async for pack in api_send_chan:    self._record_lower_data(pack)    await ws_send_chan.send(pack)  @property  def _status(self):   return ""WAIT_FOR_COMPLETED"" if self._un_processed else ""READY""  @abstractmethod  def _is_all_received(self):   """"""在重连后判断是否收到了全部的数据，可以继续处理后续的数据包""""""   pass  def _record_upper_data(self, pack):   """"""从上游收到的数据中，记录下重连时需要的数据""""""   pass  def _record_lower_data(self, pack):   """"""从下游收到的数据中，记录下重连时需要的数据""""""   pass class MdReconnectHandler(TqReconnect):  def _record_lower_data(self, pack):   """"""从下游收到的数据中，记录下重连时需要的数据""""""   aid = pack.get(""aid"")   if aid == ""subscribe_quote"":    self._resend_request[""subscribe_quote""] = pack   elif aid == ""set_chart"":    if pack[""ins_list""]:     self._resend_request[pack[""chart_id""]] = pack    else:     self._resend_request.pop(pack[""chart_id""], None)  def _is_all_received(self):   set_chart_packs = {k: v for k, v in self._resend_request.items() if v.get(""aid"") == ""set_chart""}   # 处理 seriesl(k线/tick)   if not all([v.items() <= _get_obj(self._data, [""charts"", k, ""state""]).items()      for k, v in set_chart_packs.items()]):    return False # 如果当前请求还没收齐回应, 不应继续处理   # 在接收并处理完成指令后, 此时发送给客户端的数据包中的 left_id或right_id 至少有一个不是-1 , 并且 mdhis_more_data是False；否则客户端需要继续等待数据完全发送   if not all([(_get_obj(self._data, [""charts"", k]).get(""left_id"", -1) != -1      or _get_obj(self._data, [""charts"", k]).get(""right_id"", -1) != -1)      and not self._data.get(""mdhis_more_data"", True)      for k in set_chart_packs.keys()]):    return False # 如果当前所有数据未接收完全(定位信息还没收到, 或数据序列还没收到), 不应继续处理   all_received = True # 订阅K线数据完全接收标志   for k, v in set_chart_packs.items(): # 判断已订阅的数据是否接收完全    for symbol in v[""ins_list""].split("",""):     if symbol:      path = [""klines"", symbol, str(v[""duration""])] if v[""duration""] != 0 else [""ticks"", symbol]      serial = _get_obj(self._data, path)      if serial.get(""last_id"", -1) == -1:       all_received = False       break    if not all_received:     break   if not all_received:    return False   # 处理实时行情quote   if self._data.get(""ins_list"", """") != self._resend_request.get(""subscribe_quote"", {}).get(""ins_list"", """"):    return False # 如果实时行情quote未接收完全, 不应继续处理   return True class TdReconnectHandler(TqReconnect):  def __init__(self, logger):   super().__init__(logger)   self._pos_symbols = {}  def _record_lower_data(self, pack):   """"""从下游收到的数据中，记录下重连时需要的数据""""""   aid = pack.get(""aid"")   if aid == ""req_login"":    self._resend_request[""req_login""] = pack   elif aid == ""confirm_settlement"":    self._resend_request[""confirm_settlement""] = pack  def _record_upper_data(self, pack):   """"""从上游收到的数据中，记录下重连时需要的数据""""""   for d in pack.get(""data"", []):    for user, trade_data in d.get(""trade"", {}).items():     if user not in self._pos_symbols:      self._pos_symbols[user] = set()     self._pos_symbols[user].update(trade_data.get(""positions"", {}).keys())  def _is_all_received(self):   """"""交易服务器只判断收到的 trade_more_data 是否为 False，作为收到完整数据截面的依据""""""   if not all([(not self._data.get(""trade"", {}).get(user, {}).get(""trade_more_data"", True))      for user in self._pos_symbols.keys()]):    return False # 如果交易数据未接收完全, 不应继续处理   # 有可能重连之后，持仓比原有持仓减少，需要原有的数据集中删去减少的合约的持仓   for user, trade_data in self._data.get(""trade"", {}).items():    symbols = set(trade_data.get(""positions"", {}).keys()) # 当前真实持仓中的合约    if self._pos_symbols.get(user, set()) > symbols: # 如果此用户历史持仓中的合约比当前真实持仓中更多: 删除多余合约信息     self._pending_diffs.append({      ""trade"": {       user: {        ""positions"": {symbol: None for symbol in (self._pos_symbols[user] - symbols)}       }      }     })   return True class TsReconnectHandler(TqReconnect):  def _record_lower_data(self, pack):   """"""从下游收到的数据中，记录下重连时需要的数据""""""   aid = pack.get(""aid"")   if aid == ""subscribe_trading_status"":    self._resend_request[""subscribe_trading_status""] = pack  def _is_all_received(self):   return True "
82,n\tqsdk\data extensio,"n\tqsdk\data extensio. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' from tqsdk.datetime import _get_expire_rest_days from tqsdk.datetime_state import TqDatetimeState from tqsdk.diff import _simple_merge_diff, _is_key_exist, _simple_merge_diff_and_collect_paths, _get_obj class DataExtension(object):  """"""  为数据截面添加以下字段：  {   quotes: {    *: {     expire_rest_days: int    }   },   trade: {    *: {     positions: {      *: {       'pos_long': int,       'pos_short': int,       'pos': int      }     },     orders: {      *: {       'is_dead': bool       'is_online': bool       'is_error': bool       'trade_price': float      }     }    }   }  }  """"""  def __init__(self, api):   self._api = api   self._data = {    'trade': {},    'quotes': {} # 记录 quotes 的 expire_datetime，并不是每一次 diff 更新都会重新发送 expire_datetime，重新 expire_rest_days 时需要这个信息   } # 数据截面, 现在的功能只需要记录 trade   self._diffs = []   self._diffs_paths = set()   self._prototype = {    ""trade"": {     ""*"": {      ""orders"": {       ""*"": {        ""status"": None,        ""exchange_order_id"": None       }      },      ""trades"": {       ""*"": None      },      ""positions"": {       ""*"": {        ""pos_long_his"": None,        ""pos_long_today"": None,        ""pos_short_his"": None,        ""pos_short_today"": None       }      }     }    }   }  async def _run(self, api_send_chan, api_recv_chan, md_send_chan, md_recv_chan):   self._logger = self._api._logger.getChild(""DataExtension"")   self._api_send_chan = api_send_chan   self._api_recv_chan = api_recv_chan   self._md_send_chan = md_send_chan   self._md_recv_chan = md_recv_chan   self._datetime_state = TqDatetimeState()   md_task = self._api.create_task(self._md_handler())   self._pending_peek = False # True 表示收到下游的 peek_message ，并且没有发给过下游回复；False 表示发给过下游回复，没有 pending_peek_message   self._pending_peek_md = False # True 表示发给过上游 peek_message；False 表示对上游没有 pending_peek_message   try:    async for pack in api_send_chan:     if ""_md_recv"" in pack:      if pack['aid'] == 'rtn_data':       self._pending_peek_md = False       await self._md_recv(pack)       await self._send_diff()      if self._pending_peek and self._pending_peek_md is False:       self._pending_peek_md = True       await self._md_send_chan.send({""aid"": ""peek_message""})     elif pack[""aid""] == ""peek_message"":      self._pending_peek = True      await self._send_diff()      if self._pending_peek and self._pending_peek_md is False:       self._pending_peek_md = True       await self._md_send_chan.send(pack)     else:      await self._md_send_chan.send(pack)   finally:    md_task.cancel()  async def _md_handler(self):   """"""0 接收上游数据包 """"""   async for pack in self._md_recv_chan:    pack[""_md_recv""] = True    await self._api_send_chan.send(pack)  async def _md_recv(self, pack):   """"""将行情数据和交易数据合并至 self._data """"""   for d in pack.get(""data"", []):    self._datetime_state.update_state(d)    if d.get('quotes', None):     _simple_merge_diff(      result=self._data['quotes'],      diff=d['quotes']     )    if d.get('trade', None):     _simple_merge_diff_and_collect_paths(      result=self._data['trade'],      diff=d['trade'],      path=('trade', ),      diff_paths=self._diffs_paths,      prototype=self._prototype['trade']     )    self._diffs.append(d)  def _generate_ext_diff(self):   """"""""   补充 quote, position 额外字段   此函数在 send_diff() 才会调用， self._datetime_state.data_ready 一定为 True，   调用 self._datetime_state.get_current_dt() 一定有正确的当前时间   """"""   for d in self._diffs:    if d.get('quotes', None):     self._update_quotes(d)   pend_diff = {}   _simple_merge_diff(pend_diff, self._get_positions_pend_diff())   orders_set = set() # 计算过委托单，is_dead、is_online、is_error   orders_price_set = set() # 根据成交计算哪些 order 需要重新计算平均成交价 trade_price   for path in self._diffs_paths:    if path[2] == 'orders':     _, account_key, _, order_id, _ = path     if (account_key, order_id) not in orders_set:      orders_set.add((account_key, order_id))      order = _get_obj(self._data, ['trade', account_key, 'orders', order_id])      if order:       pend_order = pend_diff.setdefault('trade', {}).setdefault(account_key, {}).setdefault('orders', {}).setdefault(order_id, {})       pend_order['is_dead'] = order['status'] == ""FINISHED""       pend_order['is_online'] = order['exchange_order_id'] != """" and order['status'] == ""ALIVE""       pend_order['is_error'] = order['exchange_order_id'] == """" and order['status'] == ""FINISHED""    elif path[2] == 'trades':     _, account_key, _, trade_id = path     trade = _get_obj(self._data, path)     order_id = trade.get('order_id', '')     if order_id:      orders_price_set.add(('trade', account_key, 'orders', order_id))   for path in orders_price_set:    _, account_key, _, order_id = path    trade_price = self._get_trade_price(account_key, order_id)    if trade_price == trade_price:     pend_order = pend_diff.setdefault('trade', {}).setdefault(account_key, {}).setdefault('orders', {}).setdefault(order_id, {})     pend_order['trade_price'] = trade_price   self._diffs_paths = set()   return pend_diff  def _update_quotes(self, diff):   for symbol in diff['quotes']:    expire_datetime = self._data['quotes'].get(symbol, {}).get('expire_datetime', None)    if expire_datetime and expire_datetime == expire_datetime: # 排除 None 和 nan     # expire_rest_days 距离到期日的剩余天数（自然日天数），正数表示距离到期日的剩余天数，0表示到期日当天，负数表示距离到期日已经过去的天数     # 直接修改在 diff 里面的数据，当 diffs 里有多个对同个合约的修改时，保持数据截面的一致     expire_rest_days = _get_expire_rest_days(expire_datetime, self._datetime_state.get_current_dt() / 1e9)     diff['quotes'][symbol]['expire_rest_days'] = expire_rest_days  def _get_positions_pend_diff(self):   pend_diff = {}   for account_key in self._data['trade']:    positions = self._data['trade'][account_key].get('positions', {})    for symbol, pos in positions.items():     paths = [('trade', account_key, 'positions', symbol) + (key, )       for key in ['pos_long_his', 'pos_long_today', 'pos_short_his', 'pos_short_today']]     if any([p in self._diffs_paths for p in paths]):      pos_long = pos['pos_long_his'] + pos['pos_long_today']      pos_short = pos['pos_short_his'] + pos['pos_short_today']      pend_diff.setdefault(account_key, {}).setdefault('positions', {})      pend_diff[account_key]['positions'][symbol] = {       'pos_long': pos_long,       'pos_short': pos_short,       'pos': pos_long - pos_short      }   return {'trade': pend_diff} if pend_diff else {}  def _get_trade_price(self, account_key, order_id):   # 计算某个 order_id 对应的成交均价   trades = self._data['trade'][account_key]['trades']   trade_id_list = [t_id for t_id in trades.keys() if trades[t_id]['order_id'] == order_id]   sum_volume = sum([trades[t_id]['volume'] for t_id in trade_id_list])   if sum_volume == 0:    return float('nan')   else:    sum_amount = sum([trades[t_id]['volume'] * trades[t_id]['price'] for t_id in trade_id_list])    return sum_amount / sum_volume  async def _send_diff(self):   if self._datetime_state.data_ready and self._pending_peek and self._diffs:    # 生成增量业务截面, 该截面包含补充的字段，只在真正需要给下游发送数据时，才将需要发送的数据放在 _diffs 中    ext_diff = self._generate_ext_diff()    rtn_data = {     ""aid"": ""rtn_data"",     ""data"": self._diffs + [ext_diff],    }    self._diffs = []    self._pending_peek = False    await self._api_recv_chan.send(rtn_data) "
83,n\tqsdk\data serie,"n\tqsdk\data serie. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' import os import shutil import struct import numpy as np import pandas as pd from filelock import FileLock from tqsdk.channel import TqChan from tqsdk.diff import _get_obj from tqsdk.rangeset import _rangeset_difference, _rangeset_intersection from tqsdk.tafunc import get_dividend_df from tqsdk.utils import _generate_uuid CACHE_DIR = os.path.join(os.path.expanduser('~'), "".tqsdk/data_series_1"") class DataSeries:  """"""  获取数据模块，支持用户获取任意时间段内的 Kline / Tick 数据，返回格式为 pandas.DataFrame  支持用户设置开始时间和结束时间，且返回的 df 不会随着行情更新  首个版本功能点：  1. 缓存数据，目录 ~/.tqsdk/data_series，文件名规则为 symbol.dur.start_id.end_id                    2. 每次下载数据先检查缓存数据是否包含需要下载数据，计算出还需要下载的数据段  3. 如果有需要下载的数据段  下载的数据先写在 symbol.dur.temp 文件，下载完成之后文件名修改为 symbol.dur.start_id.end_id  4. 下载完数据之后，合并连续的数据文件，更新缓存文件  5. 如果有复权参数，计算复权数据  6. 返回完整的 pandas.DataFrame 给用户  **功能限制说明**  * 该接口返回的 df 不会随着行情更新  * 暂不支持多合约 Kline 缓存  * 不支持用户回测/复盘使用。get_data_series() 是直接连接行情服务器，是会下载到未来数据的。  * 不支持多进程/线程/协程。每个合约+周期只能在同一个线程/进程里下载，因为需要写/读/修改文件，多个线程/进程会造成冲突。  """"""  def __init__(self, api, symbol_list, dur_nano, start_dt_nano, end_dt_nano, adj_type=None) -> None:   """"""   创建历史数据下载器实例   Args:    api (TqApi): TqApi实例，该下载器将使用指定的api下载数据    symbol_list: 需要下载数据的合约代码，当指定多个合约代码时将其他合约按第一个合约的交易时间对齐    dur_nano (int): 数据周期，纳秒数    start_dt_nano (int): 起始时间, 纳秒数    end_dt_nano (int): 结束时间, 纳秒数    adj_type (str/None): 复权计算方式，默认值为 None。""F"" 为前复权；""B"" 为后复权；None 表示不复权。只对股票、基金合约有效。   """"""   self._api = api   self._symbol_list = symbol_list if isinstance(symbol_list, list) else [symbol_list]   self._dur_nano = dur_nano   self._start_dt_nano = start_dt_nano   self._end_dt_nano = end_dt_nano + 1 # 实际上用户需要下载的时间段使用 Range 表示为 [self.start_dt_nano, self.end_dt_nano)   self._adj_type = adj_type   self._dividend_cache = {} # 缓存合约对应的复权系数矩阵，每个合约只计算一次   self.df = pd.DataFrame()   self.is_ready = False   DataSeries._ensure_cache_dir() # 确认缓存文件夹存在   self._api.create_task(self._run())  async def _run(self):   symbol = self._symbol_list[0] # todo: 目前只处理一个合约的情况   lock_path = DataSeries._get_lock_path(symbol, self._dur_nano)   with FileLock(lock_path, timeout=-1):    # 检查缓存文件，计算需要下载的数据段    rangeset_id = DataSeries._get_rangeset_id(symbol, self._dur_nano)    rangeset_dt = DataSeries._get_rangeset_dt(symbol, self._dur_nano, rangeset_id)    DataSeries._assert_rangeset_asce_sorted(rangeset_id)    DataSeries._assert_rangeset_asce_sorted(rangeset_dt)    # 计算差集 todo: 已下载数据的 rangeset_id[0][0] ~ rangeset_id[-1][1] 覆盖到的部分，可以使用 id 范围下载，未覆盖到的使用 dt 范围下载    # rangeset_dt 中的最后一个 range 的最后一根 k 线，需要重新下载，因为如果用户填写的 end_dt_nano 是未来时间，有可能这跟 k 线数据是过时的    if len(rangeset_dt) > 0:     rangeset_dt[-1] = (rangeset_dt[-1][0], rangeset_dt[-1][1] - self._dur_nano)     if rangeset_dt[-1][0] == rangeset_dt[-1][1]:      # 如果最后一个 range 的只包含最后一根 k 线，则删去最后一个 Range，最后一根 k 线需要重新下载      rangeset_dt.pop(-1)    diff_rangeset = _rangeset_difference([(self._start_dt_nano, self._end_dt_nano)], rangeset_dt)    # 下载数据并全部完成    if len(diff_rangeset) > 0:     await self._download_data_series(diff_rangeset)     self._merge_rangeset() # 归并文件     rangeset_id = DataSeries._get_rangeset_id(symbol, self._dur_nano)     rangeset_dt = DataSeries._get_rangeset_dt(symbol, self._dur_nano, rangeset_id)     DataSeries._assert_rangeset_asce_sorted(rangeset_id)     DataSeries._assert_rangeset_asce_sorted(rangeset_dt)    assert len(rangeset_id) == len(rangeset_dt) > 0    # 查找用户请求时间段与已有数据时间段的交集    target_rangeset_dt = _rangeset_intersection([(self._start_dt_nano, self._end_dt_nano)], rangeset_dt)    assert len(target_rangeset_dt) <= 1 # 用户请求应该落在一个时间段内，或者用户请求的时间段内没有任何数据    if len(target_rangeset_dt) == 0: # 用户请求的时间段内没有任何数据     self.is_ready = True     return    # 此时用户请求时间范围，转化为 target_rangeset_dt[0]    # 找到 self._start_dt_nano, self._end_dt_nano 对应的 range_id    (start_dt, end_dt) = target_rangeset_dt[0]    range_id = None    for index in range(len(rangeset_dt)):     range_dt = rangeset_dt[index]     if range_dt[0] <= start_dt and end_dt <= range_dt[1]:      range_id = rangeset_id[index]      break    assert range_id    # 返回 dataframe, 目标文件为    filename = os.path.join(CACHE_DIR, f""{symbol}.{self._dur_nano}.{range_id[0]}.{range_id[1]}"")    data_cols = DataSeries._get_data_cols(symbol=self._symbol_list[0], dur_nano=self._dur_nano)    dtype = np.dtype([('id', 'i8'), ('datetime', 'i8')] + [(col, 'f8') for col in data_cols])    fp = np.memmap(filename, dtype=dtype, mode='r', shape=range_id[1] - range_id[0])    # target_rangeset_dt[0] 对应的 id 范围是 [start_id, end_id)    start_id = fp[fp['datetime'] <= start_dt][-1][""id""]    end_id = fp[fp['datetime'] < end_dt][-1][""id""]    rows = end_id - start_id + 1 # 读取数据行数    array = fp[start_id - range_id[0]: start_id - range_id[0] + rows]    # 按列赋值，df.append 方法会返回一个新的 df，初始化构造的 df 可能（如果是异步代码下）已经返回给用户代码中；df.update 方法会导致更新的列的 type 都是 object    self.df[""id""] = array[""id""]    self.df[""datetime""] = array[""datetime""]    for c in data_cols:     self.df[c] = array[c]    self.df[""symbol""] = symbol    self.df[""duration""] = self._dur_nano    # 复权, 如果存在 STOCK / FUND 并且 adj_type is not None, 这里需要提前准备下载时间段内的复权因子    quote = self._api.get_quote(symbol)    if self._adj_type and quote.ins_class in [""STOCK"", ""FUND""]:     factor_df = await self._update_dividend_factor(symbol) # 复权需要根据日线计算除权因子，todo: 如果本地下载过日线，不需要再从服务器获取日线数据     if self._adj_type == ""F"":      # 倒序循环 factor_df, 对于小于当前 factor_df[datetime] 的行 乘以 factor_df[factor]      for i in range(factor_df.shape[0] - 1, -1, -1):       dt = factor_df.iloc[i].datetime       factor = factor_df.iloc[i].factor       adj_cols = DataSeries._get_adj_cols(symbol, self._dur_nano)       lt = self.df[""datetime""].lt(dt)       for col in adj_cols:        self.df.loc[lt, col] = self.df.loc[lt, col] * factor     if self._adj_type == ""B"":      # 正序循环 factor_df, 对于大于等于当前 factor_df[datetime] 的行 乘以 1 / factor_df[factor]      for i in range(factor_df.shape[0]):       dt = factor_df.iloc[i].datetime       factor = factor_df.iloc[i].factor       adj_cols = DataSeries._get_adj_cols(symbol, self._dur_nano)       ge = self.df[""datetime""].ge(dt)       self.df.loc[ge, adj_cols] = self.df.loc[ge, adj_cols] / factor    # 结束状态    self.is_ready = True  async def _download_data_series(self, rangeset):   symbol = self._symbol_list[0]   for start_dt, end_dt in rangeset:    try:     start_id, end_id = None, None     temp_filename = os.path.join(CACHE_DIR, f""{symbol}.{self._dur_nano}.temp"")     temp_file = open(temp_filename, ""wb"")     data_chan = TqChan(self._api)     task = self._api.create_task(self._download_data(start_dt, end_dt, data_chan))     async for item in data_chan:      temp_file.write(struct.pack(""@qq"" + ""d"" * (len(item) - 2), *item))      if start_id is None:       start_id = item[0]      end_id = item[0]    except Exception as e:     temp_file.close() # 这里如果遇到 exception，不应该再重命名文件，相当于下载失败    else:     temp_file.close()     if start_id is not None and end_id is not None:      target_filename = os.path.join(CACHE_DIR, f""{symbol}.{self._dur_nano}.{start_id}.{end_id + 1}"")      shutil.move(temp_filename, target_filename)    finally:     task.cancel()     await task  async def _download_data(self, start_dt, end_dt, data_chan):   # 下载的数据应该是 [start_dt, end_dt）   symbol = self._symbol_list[0]   chart_info = {    ""aid"": ""set_chart"",    ""chart_id"": _generate_uuid(""PYSDK_data_series""),    ""ins_list"": symbol,    ""duration"": int(self._dur_nano),    ""view_width"": 2000,    ""focus_datetime"": int(start_dt),    ""focus_position"": 0,   }   # 还没有发送过任何请求, 先请求定位左端点   self._api._send_chan.send_nowait(chart_info)   chart = _get_obj(self._api._data, [""charts"", chart_info[""chart_id""]])   current_id = None # 当前数据指针   path = [""klines"", symbol, str(self._dur_nano)] if self._dur_nano != 0 else [""ticks"", symbol]   serial = _get_obj(self._api._data, path)   cols = DataSeries._get_data_cols(symbol, self._dur_nano)   try:    async with self._api.register_update_notify() as update_chan:     async for _ in update_chan:      if not (chart_info.items() <= _get_obj(chart, [""state""]).items()):       continue # 当前请求还没收齐回应, 不应继续处理      left_id = chart.get(""left_id"", -1)      right_id = chart.get(""right_id"", -1)      if (left_id == -1 and right_id == -1) or self._api._data.get(""mdhis_more_data"", True):       continue # 定位信息还没收到, 或数据序列还没收到      # 检查合约的数据是否收到      if serial.get(""last_id"", -1) == -1:       continue      if current_id is None:       current_id = max(left_id, 0)      while current_id <= right_id:       item = serial[""data""].get(str(current_id), {})       if item.get(""datetime"", 0) == 0 or item[""datetime""] >= end_dt:        return # 当前 id 已超出 last_id 或k线数据的时间已经超过用户限定的右端       row = [current_id, item[""datetime""]] + [DataSeries._get_float_value(item, c) for c in cols]       await data_chan.send(row)       current_id += 1       self._current_dt_nano = item[""datetime""]      # 当前 id 已超出订阅范围, 需重新订阅后续数据      chart_info.pop(""focus_datetime"", None)      chart_info.pop(""focus_position"", None)      chart_info[""left_kline_id""] = current_id      await self._api._send_chan.send(chart_info)   finally:    # 释放chart资源    await data_chan.close()    await self._api._send_chan.send({     ""aid"": ""set_chart"",     ""chart_id"": chart_info[""chart_id""],     ""ins_list"": """",     ""duration"": self._dur_nano,     ""view_width"": 2000,    })  async def _update_dividend_factor(self, symbol):   quote = self._api.get_quote(symbol)   df = get_dividend_df(quote.stock_dividend_ratio, quote.cash_dividend_ratio)   between = df[""datetime""].between(self._start_dt_nano, self._end_dt_nano) # 只需要开始时间～结束时间之间的复权因子   df[""pre_close""] = float('nan')   for i in df[between].index:    chart_info = {     ""aid"": ""set_chart"",     ""chart_id"": _generate_uuid(""PYSDK_data_factor""),     ""ins_list"": symbol,     ""duration"": 86400 * 1000000000,     ""view_width"": 2,     ""focus_datetime"": int(df.iloc[i].datetime),     ""focus_position"": 1    }    await self._api._send_chan.send(chart_info)    chart = _get_obj(self._api._data, [""charts"", chart_info[""chart_id""]])    serial = _get_obj(self._api._data, [""klines"", symbol, str(86400000000000)])    try:     async with self._api.register_update_notify() as update_chan:      async for _ in update_chan:       if not (chart_info.items() <= _get_obj(chart, [""state""]).items()):        continue # 当前请求还没收齐回应, 不应继续处理       left_id = chart.get(""left_id"", -1)       right_id = chart.get(""right_id"", -1)       if (left_id == -1 and right_id == -1) or self._api._data.get(""mdhis_more_data"",                      True) or serial.get(""last_id"",                           -1) == -1:        continue # 定位信息还没收到, 或数据序列还没收到, 合约的数据是否收到       last_item = serial[""data""].get(str(left_id), {})       # 复权时间点的昨收盘       df.loc[i, 'pre_close'] = last_item['close'] if last_item.get('close') else float('nan')       break    finally:     await self._api._send_chan.send({      ""aid"": ""set_chart"",      ""chart_id"": chart_info[""chart_id""],      ""ins_list"": """",      ""duration"": 86400000000000,      ""view_width"": 2     })   df[""factor""] = (df[""pre_close""] - df[""cash_dividend""]) / df[""pre_close""] / (1 + df[""stock_dividend""])   df[""factor""].fillna(1, inplace=True)   return df  def _merge_rangeset(self):   symbol = self._symbol_list[0]   rangeset = DataSeries._get_rangeset_id(symbol, self._dur_nano)   if len(rangeset) <= 1:    return   # 可以 merge 的 rangset 分组, rangset_group 类型是 list_of_list, [[(start, end, rows), ], [], ....]   # 内层列表的每个元素值为 range 的 start, end，用来找到正确的文件名，rows 表示 merge 文件时，应该从当前一段 range 里 merge 多少行   # 主要用于有一种情况：已有 rangeset 的最后一根 kline，有可能被重新下载，导致某个待 merge 的 rangeset 形式为 [0, 50), [49, 50)   # 此时，[10, 50), [49, 50) 两个 range 应该 merge 到最终文件里的行数 rows 是 49，1; 而不是 50，1。   # 实际上除了这种情况之外，一个 range 应该 merge 到最终文件里的行数都应该是 range.end - range.start   # 所以在生产 rangset_group 时，需要把要 merge 的行数也记下来，方便后面 merge。   rangset_group = [[rangeset[0] + (rangeset[0][1] - rangeset[0][0], )]]   for i in range(1, len(rangeset)):    last_r = rangeset[i - 1]    r = rangeset[i]    assert (r[0] < r[1]) & (last_r[0] < last_r[1])    if i == len(rangeset) - 1:     # 最后一组 rangeset，last_r[1] 有可能大于 range[0]，因为每次下载过的数据都会认为最后一个数据还是需要重新下载     assert last_r[1] - 1 <= r[0]     if last_r[1] == r[0]:      rangset_group[-1].append(r + (r[1] - r[0], ))     elif last_r[1] - 1 == r[0]:      # 后一个 range 的 start_id 和与 前一个 range 的 end_id - 1 相等，前一个 range 的最后一个数据被重复下载      # 此时的前一个 range 的行数需要 -1      rangset_group[-1][-1] = last_r + (last_r[1] - 1 - last_r[0], )      rangset_group[-1].append(r + (r[1] - r[0], ))     else:      rangset_group.append([r + (r[1] - r[0], )])    else:     assert last_r[1] <= r[0] # rangeset 应该是严格递增的     if last_r[1] == r[0]:      rangset_group[-1].append(r + (r[1] - r[0], ))     else:      rangset_group.append([r + (r[1] - r[0], )])   data_cols = DataSeries._get_data_cols(symbol, self._dur_nano)   dtype = np.dtype([('id', 'i8'), ('datetime', 'i8')] + [(col, 'f8') for col in data_cols])   for rangeset in rangset_group:    if len(rangeset) == 1:     continue    first_r_0, first_r_1, first_r_rows = rangeset[0]    # 将第一个文件作为临时文件    temp_filename = os.path.join(CACHE_DIR, f""{symbol}.{self._dur_nano}.{first_r_0}.{first_r_1}"")    all_rows = first_r_rows # 临时文件中已经写入的总行数    last_r_1 = None    for s, e, rows_number in rangeset[1:]:     filename = os.path.join(CACHE_DIR, f""{symbol}.{self._dur_nano}.{s}.{e}"")     fp = np.memmap(filename, dtype=dtype, mode='r+', shape=rows_number)     temp_fp = np.memmap(temp_filename, dtype=dtype, mode='r+', offset=dtype.itemsize*all_rows, shape=rows_number)     temp_fp[0:rows_number] = fp[0:rows_number]     temp_fp._mmap.close()     fp._mmap.close() # 使用了内部变量 _mmap，fp 还未正式提供 close 方法，参见：https://github.com/numpy/numpy/pull/17941/files     os.remove(filename) # 写完后删除源文件     all_rows += rows_number     last_r_1 = e    os.rename(temp_filename, os.path.join(CACHE_DIR, f""{symbol}.{self._dur_nano}.{first_r_0}.{last_r_1}""))  @staticmethod  def _assert_rangeset_asce_sorted(rangeset):   # assert rangeset 是严格升序的，每个 range 都是升序且 前一个range.end < 后一个range.start   assert all([(rangeset[i][0] < rangeset[i][1]) & (True if i == 0 else rangeset[i-1][1] < rangeset[i][0])    for i in range(len(rangeset))])  @staticmethod  def _get_rangeset_id(symbol, dur_nano):   # 返回合约 symbol 、周期 dur_nano 的下缓存过的全部 rangeset_id   rangeset_id = []   for filename in os.listdir(CACHE_DIR):    key = f""{symbol}.{dur_nano}.""    if os.path.isfile(os.path.join(CACHE_DIR, filename)) and filename.startswith(      key) and ""temp"" not in filename:     start_id, end_id = [int(i) for i in filename.split(key)[1].split('.')[-2:]]     rangeset_id.append((start_id, end_id))   rangeset_id.sort() # 对于取到的 rangeset_id 排序， 保证其为升序   return rangeset_id  @staticmethod  def _get_rangeset_dt(symbol, dur_nano, rangeset_id):   # 返回合约 symbol 、周期 dur_nano 的下 rangeset_id 对应的 rangeset_dt   rangeset_dt = []   cols = DataSeries._get_data_cols(symbol, dur_nano)   dtype = np.dtype([('id', 'i8'), ('datetime', 'i8')] + [(col, 'f8') for col in cols])   for start_id, end_id in rangeset_id:    filename = os.path.join(CACHE_DIR, f""{symbol}.{dur_nano}.{start_id}.{end_id}"")    fp = np.memmap(filename, dtype=dtype, mode='r', shape=end_id - start_id)    first_dt, last_dt = fp[0][""datetime""], fp[-1][""datetime""]    # 如果是 kline ，range 的 start_dt = first_dt, end_dt = last_dt + dur_nano    # 如果是 tick， range 的 start_dt = first_dt, end_dt = last_dt + 100    rangeset_dt.append((first_dt, last_dt + (dur_nano if dur_nano > 0 else 100)))   return rangeset_dt  @staticmethod  def _ensure_cache_dir():   if not os.path.exists(CACHE_DIR):    os.makedirs(CACHE_DIR, exist_ok=True)  @staticmethod  def _get_lock_path(symbol, dur_nano):   return os.path.join(CACHE_DIR, f"".{symbol}.{dur_nano}.lock"")  @staticmethod  def _get_data_cols(symbol, dur_nano):   # 获取数据列   if dur_nano != 0:    return [""open"", ""high"", ""low"", ""close"", ""volume"", ""open_oi"", ""close_oi""]   else:    cols = [""last_price"", ""highest"", ""lowest"", ""average"", ""volume"", ""amount"", ""open_interest""]    price_length = 5 if symbol.split('.')[0] in {""SHFE"", ""SSE"", ""SZSE""} else 1    for i in range(1, price_length + 1):     cols.extend(f""{x}{i}"" for x in [""bid_price"", ""bid_volume"", ""ask_price"", ""ask_volume""])    return cols  @staticmethod  def _get_adj_cols(symbol, dur_nano):   # 复权需要重新计算的列名   if dur_nano != 0:    return [""open"", ""high"", ""low"", ""close""]   else:    cols = [""last_price"", ""highest"", ""lowest"", ""average""]    price_length = 5 if symbol.split('.')[0] in {""SHFE"", ""SSE"", ""SZSE""} else 1    cols.extend(f""{x}{i}"" for x in [""bid_price"", ""ask_price""] for i in range(1, price_length + 1))    return cols  @staticmethod  def _get_float_value(obj, key) -> float:   if key not in obj or isinstance(obj[key], str):    return float(""nan"")   return float(obj[key])"
84,n\tqsdk\datetim,"n\tqsdk\datetim. #!/usr/bin/env python # -*- coding: utf-8 -*- """""" 包含有关时间处理的功能函数 """""" __author__ = 'limin' import datetime import time def _datetime_to_timestamp_nano(dt: datetime.datetime) -> int:  # timestamp() 返回值精度为 microsecond，直接乘以 1e9 可能有精度问题  return int(dt.timestamp() * 1000000) * 1000 def _timestamp_nano_to_str(nano: int, fmt=""%Y-%m-%d %H:%M:%S.%f"") -> str:  return datetime.datetime.fromtimestamp(nano / 1e9).strftime(fmt) def _str_to_timestamp_nano(current_datetime: str, fmt=""%Y-%m-%d %H:%M:%S.%f"") -> int:  return _datetime_to_timestamp_nano(datetime.datetime.strptime(current_datetime, fmt)) def _get_trading_day_start_time(trading_day):  """"""给定交易日, 获得交易日起始时间""""""  begin_mark = 631123200000000000 # 1990-01-01  start_time = trading_day - 21600000000000 # 6小时  week_day = (start_time - begin_mark) // 86400000000000 % 7  if week_day >= 5:   start_time -= 86400000000000 * (week_day - 4)  return start_time def _get_trading_day_end_time(trading_day):  """"""给定交易日, 获得交易日结束时间""""""  return trading_day + 64799999999999 # 18小时 def _get_trading_day_from_timestamp(timestamp):  """"""给定时间, 获得其所属的交易日""""""  begin_mark = 631123200000000000 # 1990-01-01  days = (timestamp - begin_mark) // 86400000000000 # 自 1990-01-01 以来的天数  if (timestamp - begin_mark) % 86400000000000 >= 64800000000000: # 大于18点, 天数+1   days += 1  week_day = days % 7  if week_day >= 5: # 如果是周末则移到星期一   days += 7 - week_day  return begin_mark + days * 86400000000000 def _get_trading_timestamp(quote, current_datetime: str):  """""" 将 quote 在 current_datetime 所在交易日的所有可交易时间段转换为纳秒时间戳(tqsdk内部使用的时间戳统一为纳秒)并返回 """"""  # 获取当前交易日时间戳  current_trading_day_timestamp = _get_trading_day_from_timestamp(_str_to_timestamp_nano(current_datetime))  # 获取上一交易日时间戳  last_trading_day_timestamp = _get_trading_day_from_timestamp(   _get_trading_day_start_time(current_trading_day_timestamp) - 1)  trading_timestamp = {   ""day"": _get_period_timestamp(current_trading_day_timestamp, quote[""trading_time""].get(""day"", [])),   ""night"": _get_period_timestamp(last_trading_day_timestamp, quote[""trading_time""].get(""night"", []))  }  return trading_timestamp def _get_period_timestamp(real_date_timestamp, period_str):  """"""  real_date_timestamp：period_str 所在真实日期的纳秒时间戳（如 period_str 为周一(周二)的夜盘,则real_date_timestamp为上周五(周一)的日期; period_str 为周一的白盘,则real_date_timestamp为周一的日期）  period_str: quote[""trading_time""][""day""] or quote[""trading_time""][""night""]  """"""  period_timestamp = []  for duration in period_str: # 对于白盘（或夜盘）中的每一个可交易时间段   start = [int(i) for i in duration[0].split("":"")] # 交易时间段起始点   end = [int(i) for i in duration[1].split("":"")] # 交易时间段结束点   period_timestamp.append([real_date_timestamp + (start[0] * 3600 + start[1] * 60 + start[2]) * 1000000000,         real_date_timestamp + (end[0] * 3600 + end[1] * 60 + end[2]) * 1000000000])  return period_timestamp def _is_in_trading_time(quote, current_datetime, local_time_record):  """""" 判断是否在可交易时间段内，需在quote已收到行情后调用本函数""""""  # 只在需要用到可交易时间段时(即本函数中)才调用_get_trading_timestamp()  trading_timestamp = _get_trading_timestamp(quote, current_datetime)  now_ns_timestamp = _get_trade_timestamp(current_datetime, local_time_record) # 当前预估交易所纳秒时间戳  # 判断当前交易所时间（估计值）是否在交易时间段内  for v in trading_timestamp.values():   for period in v:    if period[0] <= now_ns_timestamp < period[1]:     return True  return False def _get_trade_timestamp(current_datetime, local_time_record):  # 根据最新行情时间获取模拟的(预估的)当前交易所纳秒时间戳（tqsdk内部使用的时间戳统一为纳秒）  # 如果local_time_record为nan，則不加时间差  cur_nano = _str_to_timestamp_nano(current_datetime)  mock_delay_nano = 0 if local_time_record != local_time_record else int((time.time() - local_time_record) * 1e6) * 1000  return cur_nano + mock_delay_nano def _get_expire_rest_days(expire_dt, current_dt):  """"""  获取当前时间到下市时间之间的天数  expire_dt, current_dt 都以 s 为单位  """"""  delta = datetime.datetime.fromtimestamp(expire_dt).date() - datetime.datetime.fromtimestamp(current_dt).date()  return delta.days "
85,n\tqsdk\datetime stat,"n\tqsdk\datetime stat. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' """""" 时间帮助函数，根据回测/实盘获取不同的当前时间 模块内部创建使用 """""" import time class TqDatetimeState:  def __init__(self):   self.data_ready = False # 是否收到了第一个 mdhis_more_data   self.tqsdk_backtest = {}  def get_current_dt(self):   """"""返回当前 nano timestamp""""""   if self.tqsdk_backtest:    return self.tqsdk_backtest.get('current_dt')   else:    return int(time.time() * 1000000) * 1000  def update_state(self, diff):   self.tqsdk_backtest.update(diff.get('_tqsdk_backtest', {}))   if not self.data_ready and diff.get('mdhis_more_data', True) is False:    self.data_ready = True "
86,n\tqsdk\dif,"n\tqsdk\dif. #!usr/bin/env python3 #-*- coding:utf-8 -*- __author__ = 'yanqiong' import copy from typing import Set, Union, Dict, Tuple from tqsdk.entity import Entity def _merge_diff(result, diff, prototype, persist, reduce_diff=False, notify_update_diff=False):  """"""  更新业务数据,并同步发送更新通知，保证业务数据的更新和通知是原子操作  :param result: 更新结果  :param diff: diff pack  :param persist: 是否保留 result 中所有字段，如果为 True，则 diff 里为 None 的对象在 result 中不会删除；如果是 False，则 result 结果中会删除 diff 里为 None 的对象  :param reduce_diff: 表示是否修改 diff 对象本身，如果为 True 函数运行完成后，diff 会更新为与 result 真正的有区别的字段；如果为 False，diff 不会修改   默认不会修改 diff，只有 api 中 is_changing 接口需要 diffs 为真正有变化的数据  :param notify_update_diff: 为 True 表示发送更新通知的发送的是包含 diff 的完整数据包（方便 TqSim 中能每个合约的 task 可以单独维护自己的数据），反之只发送 True  :return:  """"""  for key in list(diff.keys()):   value_type = type(diff[key])   if value_type is str and key in prototype and not type(prototype[key]) is str:    diff[key] = prototype[key]   if diff[key] is None:    if (persist or ""#"" in prototype) and reduce_diff:     del diff[key]    else:     if notify_update_diff:      dv = result.pop(key, None)      _notify_update(dv, True, _gen_diff_obj(None, result[""_path""] + [key]))     else:      dv = result.pop(key, None)      _notify_update(dv, True, True)   elif value_type is dict or value_type is Entity:    default = None    tpersist = persist    if key in prototype:     tpt = prototype[key]    elif ""*"" in prototype:     tpt = prototype[""*""]    elif ""@"" in prototype:     tpt = prototype[""@""]     default = tpt    elif ""#"" in prototype:     tpt = prototype[""#""]     default = tpt     tpersist = True    else:     tpt = {}    target = _get_obj(result, [key], default=default)    _merge_diff(target, diff[key], tpt, persist=tpersist, reduce_diff=reduce_diff, notify_update_diff=notify_update_diff)    if reduce_diff and len(diff[key]) == 0:     del diff[key]   elif reduce_diff and key in result and (     result[key] == diff[key] or (diff[key] != diff[key] and result[key] != result[key])):    # 判断 diff[key] != diff[key] and result[key] != result[key] 以处理 value 为 nan 的情况    del diff[key]   else:    result[key] = diff[key]  if len(diff) != 0:   diff_obj = True   if notify_update_diff:    # 这里发的数据目前是不需要 copy (浅拷贝会有坑，深拷贝的话性能不知道有多大影响)    # 因为这里现在会用到发送这个 diff 的只有 quote 对象，只有 sim 会收到使用，sim 收到之后是不会修改这个 diff    # 所以这里就约定接收方不能改 diff 中的值    diff_obj = _gen_diff_obj(diff, result[""_path""])   _notify_update(result, False, diff_obj) def _gen_diff_obj(diff, path):  """"""将 diff 根据 path 拼成一个完整的 diff 包""""""  diff_obj = diff  for i in range(len(path)):   diff_obj = {path[len(path)-i-1]: diff_obj}  return diff_obj def _notify_update(target, recursive, content):  """"""同步通知业务数据更新""""""  if isinstance(target, dict) or isinstance(target, Entity):   for q in getattr(target, ""_listener"", {}):    q.send_nowait(content)   if recursive:    for v in target.values():     _notify_update(v, recursive, content) def _get_obj(root, path, default=None):  """"""获取业务数据""""""  d = root  for i in range(len(path)):   if path[i] not in d:    if i != len(path) - 1 or default is None:     dv = Entity()    else:     dv = copy.copy(default)    dv._instance_entity(d[""_path""] + [path[i]])    d[path[i]] = dv   d = d[path[i]]  return d def _register_update_chan(objs, chan):  if not isinstance(objs, list):   objs = [objs]  for o in objs:   o[""_listener""].add(chan)  return chan def _is_key_exist(diff, path, key):  """"""判断指定数据是否存在""""""  for p in path:   if not isinstance(diff, dict) or p not in diff:    return False   diff = diff[p]  if not isinstance(diff, dict):   return False  for k in key:   if k in diff:    return True  return len(key) == 0 def _simple_merge_diff(result, diff):  """"""  更新业务数据  :param result: 更新结果  :param diff: diff pack  :return:  """"""  for key in list(diff.keys()):   if diff[key] is None:    result.pop(key, None)   elif isinstance(diff[key], dict):    target = result.setdefault(key, {})    _simple_merge_diff(target, diff[key])   else:    result[key] = diff[key] def _simple_merge_diff_and_collect_paths(result, diff, path: Tuple, diff_paths: Set, prototype: Union[Dict, None]):  """"""  更新业务数据并收集指定节点的路径  默认行为 reduce_diff=False，表示函数运行过程中不会修改 diff 本身  :param result: 更新结果  :param diff: diff pack  :param path: 当前迭代 merge_diff 的节点路径  :param diff_paths: 收集指定节点的路径  :param prototype: 数据原型, 为 None 的节点路径会被记录在 diff_paths 集合中  :return:  """"""  for key in list(diff.keys()):   if diff[key] is None:    result.pop(key, None)    if prototype and ('*' in prototype or key in prototype) and prototype['*' if '*' in prototype else key] is None:     diff_paths.add(path + (key, ))   elif isinstance(diff[key], dict):    target = result.setdefault(key, {})    sub_path = path + (key, )    sub_prototype = None    if prototype and ('*' in prototype or key in prototype):     sub_prototype = prototype['*' if '*' in prototype else key]     if sub_prototype is None:      diff_paths.add(sub_path)    _simple_merge_diff_and_collect_paths(target, diff[key], path=sub_path, prototype=sub_prototype, diff_paths=diff_paths)   elif key in result and result[key] == diff[key]:    pass   else:    result[key] = diff[key]    # 只有确实有变更的字段，会出现在 diff_paths 里    if prototype and ('*' in prototype or key in prototype) and prototype['*' if '*' in prototype else key] is None:     diff_paths.add(path + (key, )) "
87,n\tqsdk\entit,"n\tqsdk\entit. #!usr/bin/env python3 #-*- coding:utf-8 -*- __author__ = 'yanqiong' import copy import weakref from collections.abc import MutableMapping class Entity(MutableMapping):  def _instance_entity(self, path):   self._path = path   self._listener = weakref.WeakSet()  def __setitem__(self, key, value):   return self.__dict__.__setitem__(key, value)  def __delitem__(self, key):   return self.__dict__.__delitem__(key)  def __getitem__(self, key):   return self.__dict__.__getitem__(key)  def __iter__(self):   return iter({k: v for k, v in self.__dict__.items() if not k.startswith(""_"")})  def __len__(self):   return len({k: v for k, v in self.__dict__.items() if not k.startswith(""_"")})  def __str__(self):   return str({k: v for k, v in self.__dict__.items() if not k.startswith(""_"")})  def __repr__(self):   return '{}, D({})'.format(super(Entity, self).__repr__(),         {k: v for k, v in self.__dict__.items() if not k.startswith(""_"")})  def copy(self):   return copy.copy(self) "
88,n\tqsdk\exception,"n\tqsdk\exception. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' import sys class BacktestFinished(Exception):  """"""  回测结束会抛出此例外  Example::   from datetime import date   from tqsdk import TqApi, TqAuth, TqBacktest, TargetPosTask, BacktestFinished, TqSim   sim = TqSim()   api = TqApi(account=sim,      backtest=TqBacktest(start_dt=date(2018, 5, 1), end_dt=date(2018, 6, 1)),      auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""DCE.m1901"", 5 * 60, data_length=15) # 获得 m1901 5分钟K线的引用   target_pos = TargetPosTask(api, ""DCE.m1901"")   try:    while True: # 策略代码     api.wait_update()     if api.is_changing(klines):      ma = sum(klines.close.iloc[-15:]) / 15      if klines.close.iloc[-1] > ma:       target_pos.set_target_volume(5)      elif klines.close.iloc[-1] < ma:       target_pos.set_target_volume(0)   except BacktestFinished:    api.close()    print(""回测结束"")    print(sim.tqsdk_stat) # 回测时间内账户交易信息统计结果  """"""  _orig_excepthook = None  def __init__(self, api):   message = ""回测结束""   super().__init__(message)   if BacktestFinished._orig_excepthook is None:    BacktestFinished._orig_excepthook = sys.excepthook    def _except_catcher(type, value, traceback):     if type is BacktestFinished:      if api._web_gui:       try:        api._print(""----------- Backtest finished, press [Ctrl + C] to exit. -----------"")        while True:         api.wait_update()       except KeyboardInterrupt:        pass      if not api._loop.is_closed():       api.close()      sys.exit()     BacktestFinished._orig_excepthook(type, value, traceback)    sys.excepthook = _except_catcher class TqTimeoutError(Exception):  """"""  获取数据超时会抛出此例外  Example::   from tqsdk import TqApi, TqAuth, TqTimeoutError   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   symbols = [""CZCE.RS808"", ""CZCE.RS809"", ""CZCE.RS908"", ""CZCE.RS909""] # CZCE.RS808 没有任何成交数据，无法取到 kline   klines = {}   for s in symbols:    try:     klines[s] = api.get_kline_serial(s, 5 * 60, data_length=15)    except TqTimeoutError as e:     print(f""获取 {s} 合约K线 超时！！！"")   for s in klines: # 打印出成功取到的 kline    print(s, klines[s].iloc[-1])   while True:    api.wait_update()    # 策略代码 。。。。  """"""  def __init__(self, message):   super().__init__(message)   self.message = message class TqBacktestPermissionError(Exception):  """"""  没有回测权限报错  """"""  def __init__(self, message):   super().__init__(message)   self.message = message class TqRiskRuleError(Exception):  """"""  风控触发的报错  """"""  def __init__(self, message):   super().__init__(message)   self.message = message "
89,n\tqsdk\ins schem,"n\tqsdk\ins schem. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' import sgqlc.types from sgqlc.operation import Fragment ins_schema = sgqlc.types.Schema() ######################################################################## # Scalars and Enumerations ######################################################################## Boolean = sgqlc.types.Boolean class Class(sgqlc.types.Enum):  __schema__ = ins_schema  __choices__ = ('BOND', 'COMBINE', 'CONT', 'FUND', 'FUTURE', 'INDEX', 'OPTION', 'SPOT', 'STOCK') Float = sgqlc.types.Float Int = sgqlc.types.Int class Int64(sgqlc.types.Scalar):  __schema__ = ins_schema String = sgqlc.types.String ######################################################################## # Input Objects ######################################################################## ######################################################################## # Output Objects and Interfaces ######################################################################## class basic(sgqlc.types.Interface):  __schema__ = ins_schema  __field_names__ = ('price_tick', 'derivatives', 'trading_time', 'trading_day', 'instrument_name', 'english_name', 'price_decs', 'class_', 'instrument_id', 'exchange_id', 'derivative')  price_tick = sgqlc.types.Field(Float, graphql_name='price_tick')  derivatives = sgqlc.types.Field('derivativeConnection', graphql_name='derivatives', args=sgqlc.types.ArgDict((   ('class_', sgqlc.types.Arg(sgqlc.types.list_of(Class), graphql_name='class', default=None)),   ('exchange_id', sgqlc.types.Arg(sgqlc.types.list_of(String), graphql_name='exchange_id', default=None)),   ('timestamp', sgqlc.types.Arg(Int64, graphql_name='timestamp', default=None)), ))  )  trading_time = sgqlc.types.Field('tradingTime', graphql_name='trading_time')  trading_day = sgqlc.types.Field(String, graphql_name='trading_day')  instrument_name = sgqlc.types.Field(String, graphql_name='instrument_name')  english_name = sgqlc.types.Field(String, graphql_name='english_name')  price_decs = sgqlc.types.Field(Int, graphql_name='price_decs')  class_ = sgqlc.types.Field(String, graphql_name='class')  instrument_id = sgqlc.types.Field(String, graphql_name='instrument_id')  exchange_id = sgqlc.types.Field(String, graphql_name='exchange_id')  derivative = sgqlc.types.Field('derivativeConnection', graphql_name='derivative', args=sgqlc.types.ArgDict((   ('class_', sgqlc.types.Arg(Class, graphql_name='class', default=None)),   ('exchange_id', sgqlc.types.Arg(String, graphql_name='exchange_id', default=None)), ))  ) class derivative(sgqlc.types.Interface):  __schema__ = ins_schema  __field_names__ = ('underlying',)  underlying = sgqlc.types.Field('derivativeConnection', graphql_name='underlying') class derivativeConnection(sgqlc.types.Type):  __schema__ = ins_schema  __field_names__ = ('count', 'edges')  count = sgqlc.types.Field(Int, graphql_name='count')  edges = sgqlc.types.Field(sgqlc.types.list_of('derivativeEdges'), graphql_name='edges') class derivativeEdges(sgqlc.types.Type):  __schema__ = ins_schema  __field_names__ = ('node', 'underlying_multiple')  node = sgqlc.types.Field('allClassUnion', graphql_name='node')  underlying_multiple = sgqlc.types.Field(Float, graphql_name='underlying_multiple') class rootQuery(sgqlc.types.Type):  __schema__ = ins_schema  __field_names__ = ('multi_symbol_info', 'symbol_info')  multi_symbol_info = sgqlc.types.Field(sgqlc.types.list_of('allClassUnion'), graphql_name='multi_symbol_info', args=sgqlc.types.ArgDict((   ('timestamp', sgqlc.types.Arg(Int64, graphql_name='timestamp', default=None)),   ('instrument_id', sgqlc.types.Arg(sgqlc.types.list_of(String), graphql_name='instrument_id', default=None)),   ('class_', sgqlc.types.Arg(sgqlc.types.list_of(Class), graphql_name='class', default=None)),   ('exchange_id', sgqlc.types.Arg(sgqlc.types.list_of(String), graphql_name='exchange_id', default=None)),   ('product_id', sgqlc.types.Arg(sgqlc.types.list_of(String), graphql_name='product_id', default=None)),   ('expired', sgqlc.types.Arg(Boolean, graphql_name='expired', default=None)),   ('has_night', sgqlc.types.Arg(Boolean, graphql_name='has_night', default=None)),   ('has_derivatives', sgqlc.types.Arg(Boolean, graphql_name='has_derivatives', default=None)), ))  )  symbol_info = sgqlc.types.Field(sgqlc.types.list_of('allClassUnion'), graphql_name='symbol_info', args=sgqlc.types.ArgDict((   ('instrument_id', sgqlc.types.Arg(String, graphql_name='instrument_id', default=None)),   ('class_', sgqlc.types.Arg(Class, graphql_name='class', default=None)),   ('exchange_id', sgqlc.types.Arg(String, graphql_name='exchange_id', default=None)),   ('product_id', sgqlc.types.Arg(String, graphql_name='product_id', default=None)),   ('expired', sgqlc.types.Arg(Boolean, graphql_name='expired', default=None)),   ('has_night', sgqlc.types.Arg(Boolean, graphql_name='has_night', default=None)),   ('has_derivatives', sgqlc.types.Arg(Boolean, graphql_name='has_derivatives', default=None)), ))  ) class securities(sgqlc.types.Interface):  __schema__ = ins_schema  __field_names__ = ('status', 'public_float_share_quantity', 'currency', 'face_value', 'first_trading_day', 'first_trading_datetime', 'buy_volume_unit', 'sell_volume_unit')  status = sgqlc.types.Field(String, graphql_name='status')  public_float_share_quantity = sgqlc.types.Field(Int64, graphql_name='public_float_share_quantity')  currency = sgqlc.types.Field(String, graphql_name='currency')  face_value = sgqlc.types.Field(Float, graphql_name='face_value')  first_trading_day = sgqlc.types.Field(Int64, graphql_name='first_trading_day')  first_trading_datetime = sgqlc.types.Field(Int64, graphql_name='first_trading_datetime')  buy_volume_unit = sgqlc.types.Field(Float, graphql_name='buy_volume_unit')  sell_volume_unit = sgqlc.types.Field(Float, graphql_name='sell_volume_unit') class tradeable(sgqlc.types.Interface):  __schema__ = ins_schema  __field_names__ = ('quote_multiple', 'pre_close', 'upper_limit', 'lower_limit', 'volume_multiple')  quote_multiple = sgqlc.types.Field(Float, graphql_name='quote_multiple')  pre_close = sgqlc.types.Field(Float, graphql_name='pre_close')  upper_limit = sgqlc.types.Field(Float, graphql_name='upper_limit')  lower_limit = sgqlc.types.Field(Float, graphql_name='lower_limit')  volume_multiple = sgqlc.types.Field(Float, graphql_name='volume_multiple') class tradingTime(sgqlc.types.Type):  __schema__ = ins_schema  __field_names__ = ('day', 'night')  day = sgqlc.types.Field(sgqlc.types.list_of(sgqlc.types.list_of(String)), graphql_name='day')  night = sgqlc.types.Field(sgqlc.types.list_of(sgqlc.types.list_of(String)), graphql_name='night') class bond(sgqlc.types.Type, basic, tradeable, securities):  __schema__ = ins_schema  __field_names__ = ('maturity_date', 'maturity_datetime')  maturity_date = sgqlc.types.Field(Int64, graphql_name='maturity_date')  maturity_datetime = sgqlc.types.Field(Int64, graphql_name='maturity_datetime') class combine(sgqlc.types.Type, basic):  __schema__ = ins_schema  __field_names__ = ('expire_datetime', 'expired', 'leg1', 'leg2', 'max_limit_order_volume', 'max_market_order_volume', 'product_id')  expire_datetime = sgqlc.types.Field(Int64, graphql_name='expire_datetime')  expired = sgqlc.types.Field(Boolean, graphql_name='expired')  leg1 = sgqlc.types.Field('allClassUnion', graphql_name='leg1')  leg2 = sgqlc.types.Field('allClassUnion', graphql_name='leg2')  max_limit_order_volume = sgqlc.types.Field(Int, graphql_name='max_limit_order_volume')  max_market_order_volume = sgqlc.types.Field(Int, graphql_name='max_market_order_volume')  product_id = sgqlc.types.Field(String, graphql_name='product_id') class cont(sgqlc.types.Type, basic, tradeable, derivative):  __schema__ = ins_schema  __field_names__ = () class fund(sgqlc.types.Type, basic, tradeable, securities):  __schema__ = ins_schema  __field_names__ = ('cash_dividend_ratio',)  cash_dividend_ratio = sgqlc.types.Field(sgqlc.types.list_of(String), graphql_name='cash_dividend_ratio') class future(sgqlc.types.Type, basic, tradeable):  __schema__ = ins_schema  __field_names__ = ('commission', 'delivery_month', 'delivery_year', 'expire_datetime', 'expired', 'margin', 'max_limit_order_volume', 'max_market_order_volume', 'mmsa', 'pre_open_interest', 'product_id', 'product_short_name', 'settlement_price')  commission = sgqlc.types.Field(Float, graphql_name='commission')  delivery_month = sgqlc.types.Field(Int, graphql_name='delivery_month')  delivery_year = sgqlc.types.Field(Int, graphql_name='delivery_year')  expire_datetime = sgqlc.types.Field(Int64, graphql_name='expire_datetime')  expired = sgqlc.types.Field(Boolean, graphql_name='expired')  margin = sgqlc.types.Field(Float, graphql_name='margin')  max_limit_order_volume = sgqlc.types.Field(Int, graphql_name='max_limit_order_volume')  max_market_order_volume = sgqlc.types.Field(Int, graphql_name='max_market_order_volume')  mmsa = sgqlc.types.Field(Boolean, graphql_name='mmsa')  pre_open_interest = sgqlc.types.Field(Int64, graphql_name='pre_open_interest')  product_id = sgqlc.types.Field(String, graphql_name='product_id')  product_short_name = sgqlc.types.Field(String, graphql_name='product_short_name')  settlement_price = sgqlc.types.Field(Float, graphql_name='settlement_price') class index(sgqlc.types.Type, basic):  __schema__ = ins_schema  __field_names__ = ('index_multiple',)  index_multiple = sgqlc.types.Field(Float, graphql_name='index_multiple') class option(sgqlc.types.Type, basic, tradeable, derivative):  __schema__ = ins_schema  __field_names__ = ('call_or_put', 'exercise_type', 'expire_datetime', 'expired', 'last_exercise_datetime', 'last_exercise_day', 'max_limit_order_volume', 'max_market_order_volume', 'pre_open_interest', 'product_short_name', 'settlement_price', 'strike_price')  call_or_put = sgqlc.types.Field(String, graphql_name='call_or_put')  exercise_type = sgqlc.types.Field(String, graphql_name='exercise_type')  expire_datetime = sgqlc.types.Field(Int64, graphql_name='expire_datetime')  expired = sgqlc.types.Field(Boolean, graphql_name='expired')  last_exercise_datetime = sgqlc.types.Field(Int64, graphql_name='last_exercise_datetime')  last_exercise_day = sgqlc.types.Field(Int64, graphql_name='last_exercise_day')  max_limit_order_volume = sgqlc.types.Field(Int, graphql_name='max_limit_order_volume')  max_market_order_volume = sgqlc.types.Field(Int, graphql_name='max_market_order_volume')  pre_open_interest = sgqlc.types.Field(Int64, graphql_name='pre_open_interest')  product_short_name = sgqlc.types.Field(String, graphql_name='product_short_name')  settlement_price = sgqlc.types.Field(Float, graphql_name='settlement_price')  strike_price = sgqlc.types.Field(Float, graphql_name='strike_price') class spot(sgqlc.types.Type, basic, tradeable):  __schema__ = ins_schema  __field_names__ = () class stock(sgqlc.types.Type, basic, tradeable, securities):  __schema__ = ins_schema  __field_names__ = ('cash_dividend_ratio', 'stock_dividend_ratio')  cash_dividend_ratio = sgqlc.types.Field(sgqlc.types.list_of(String), graphql_name='cash_dividend_ratio')  stock_dividend_ratio = sgqlc.types.Field(sgqlc.types.list_of(String), graphql_name='stock_dividend_ratio') ######################################################################## # Unions ######################################################################## class allClassUnion(sgqlc.types.Union):  __schema__ = ins_schema  __types__ = (future, index, option, combine, spot, cont, stock, bond, fund) ######################################################################## # Schema Entry Points ######################################################################## ins_schema.query_type = rootQuery ins_schema.mutation_type = None ins_schema.subscription_type = None ######################################################################## # Fragments ######################################################################## basic_frag = Fragment(basic, 'basic') basic_frag.instrument_id() basic_frag.exchange_id() basic_frag.instrument_name() basic_frag.english_name() basic_frag.class_() basic_frag.price_tick() basic_frag.price_decs() basic_frag.trading_day() basic_frag.trading_time().day() basic_frag.trading_time().night() stock_frag = Fragment(stock, 'stock') stock_frag.stock_dividend_ratio() stock_frag.cash_dividend_ratio() fund_frag = Fragment(fund, 'fund') fund_frag.cash_dividend_ratio() bond_frag = Fragment(bond, 'bond') bond_frag.maturity_datetime() tradeable_frag = Fragment(tradeable, 'tradeable') tradeable_frag.pre_close() tradeable_frag.volume_multiple() tradeable_frag.quote_multiple() tradeable_frag.upper_limit() tradeable_frag.lower_limit() index_frag = Fragment(index, 'index') index_frag.index_multiple() securities_frag = Fragment(securities, 'securities') securities_frag.currency() securities_frag.face_value() securities_frag.first_trading_datetime() securities_frag.buy_volume_unit() securities_frag.sell_volume_unit() securities_frag.status() securities_frag.public_float_share_quantity() future_frag = Fragment(future, 'future') future_frag.pre_open_interest() future_frag.expired() future_frag.product_id() future_frag.product_short_name() future_frag.delivery_year() future_frag.delivery_month() future_frag.expire_datetime() future_frag.settlement_price() future_frag.max_market_order_volume() future_frag.max_limit_order_volume() future_frag.margin() future_frag.commission() future_frag.mmsa() option_frag = Fragment(option, 'option') option_frag.pre_open_interest() option_frag.expired() option_frag.product_short_name() option_frag.expire_datetime() option_frag.last_exercise_datetime() option_frag.settlement_price() option_frag.max_market_order_volume() option_frag.max_limit_order_volume() option_frag.strike_price() option_frag.call_or_put() option_frag.exercise_type() combine_frag = Fragment(combine, 'combine') combine_frag.expired() combine_frag.product_id() combine_frag.expire_datetime() combine_frag.max_market_order_volume() combine_frag.max_limit_order_volume() combine_frag.leg1().__as__(basic).instrument_id() combine_frag.leg2().__as__(basic).instrument_id() derivative_frag = Fragment(derivative, 'derivative') derivative_frag.underlying() derivative_frag.underlying().count() derivative_frag.underlying().edges().underlying_multiple() derivative_frag.underlying().edges().node().__fragment__(basic_frag) derivative_frag.underlying().edges().node().__fragment__(stock_frag) derivative_frag.underlying().edges().node().__fragment__(fund_frag) derivative_frag.underlying().edges().node().__fragment__(bond_frag) derivative_frag.underlying().edges().node().__fragment__(tradeable_frag) derivative_frag.underlying().edges().node().__fragment__(index_frag) derivative_frag.underlying().edges().node().__fragment__(securities_frag) derivative_frag.underlying().edges().node().__fragment__(future_frag) def _add_all_frags(field):  field.__fragment__(basic_frag)  field.__fragment__(stock_frag)  field.__fragment__(fund_frag)  field.__fragment__(bond_frag)  field.__fragment__(tradeable_frag)  field.__fragment__(index_frag)  field.__fragment__(securities_frag)  field.__fragment__(future_frag)  field.__fragment__(option_frag)  field.__fragment__(combine_frag)  field.__fragment__(derivative_frag) "
90,n\tqsdk\lo,"n\tqsdk\lo. # !usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' import datetime import os import psutil DEBUG_DIR = os.path.join(os.path.expanduser('~'), "".tqsdk/logs"") def _get_log_name():  """"""返回默认 debug 文件生成的位置""""""  if not os.path.exists(DEBUG_DIR):   os.makedirs(os.path.join(os.path.expanduser('~'), "".tqsdk/logs""), exist_ok=True)  return os.path.join(DEBUG_DIR, f""{datetime.datetime.now().strftime('%Y%m%d%H%M%S%f')}-{os.getpid()}.log"") def _get_disk_free():  free = psutil.disk_usage(DEBUG_DIR).free  return free / 1e9 def _log_path_list():  # 获取所有日志文件路径，并按照修改时间递减排序  path_list = [os.path.join(DEBUG_DIR, log) for log in os.listdir(DEBUG_DIR)]  path_list.sort(key=lambda x: _stat_dt(x))  return path_list def _stat_dt(path):  try:   return datetime.datetime.fromtimestamp(os.stat(path).st_mtime)  except:   return datetime.datetime.now() def _remove_log(path):  try:   os.remove(path)  except:   pass # 忽略抛错 def _clear_logs():  """"""清除最后修改时间是 n 天前的日志""""""  if not os.path.exists(DEBUG_DIR):   return  n = os.getenv(""TQ_SAVE_LOG_DAYS"", 30)  # 清除最后修改时间是 n 天前的日志  # 清空日志保证剩余空间大于 3G，但是最近 3 个自然日的一定不会清除，保证最近的一个交易日不会被清除日志  dt30 = datetime.datetime.now() - datetime.timedelta(days=int(n))  dt3 = datetime.datetime.now() - datetime.timedelta(days=int(3))  for path in _log_path_list():   if _stat_dt(path) < dt30 or (_get_disk_free() < 3 and _stat_dt(path) < dt3):    _remove_log(path)   else:    break "
91,n\tqsdk\multiaccoun,"n\tqsdk\multiaccoun. #!/usr/bin/env python # -*- coding: utf-8 -*- __time__ = '2020/8/5 22:45' __author__ = 'Hong Yan' from typing import List, Union, Optional from shinny_structlog import ShinnyLoggerAdapter from tqsdk.connect import TqConnect, TdReconnectHandler from tqsdk.channel import TqChan from tqsdk.tradeable import TqAccount, TqKq, TqKqStock, TqSim, TqSimStock, BaseSim, BaseOtg from tqsdk.tradeable.mixin import StockMixin class TqMultiAccount(object):  """"""  天勤多账户 - TqMultiAccount  天勤多账户模块提供了单 `api` 同时操作不同账户及其组合的功能支持，目前已支持实盘账户、模拟账户和快期模拟账户的任意组合。  使用天勤多账户进行跨市场或跨账户交易时，可以在不引入多进程和多线程的前提下, 比较方便的传递账户信息进行策略编写,  同时, 也更方便对不同账户的交易数据进行统计分析。  **注意**  - 多账户模式下, 对于 get_position，account，insert_order，set_target_volume 等函数必须指定 account 参数  - 多账户模式下, 实盘账户的数量受限于信易账户支持实盘账户数, 详见:`更多的实盘交易账户数 <https://doc.shinnytech.com/tqsdk/latest/profession.html#id2>`_  """"""  def __init__(self, accounts: Optional[List[Union[TqAccount, TqKq, TqKqStock, TqSim, TqSimStock]]] = None):   """"""   创建 TqMultiAccount 实例   Args:    accounts (List[Union[TqAccount, TqKq, TqKqStock, TqSim, TqSimStock]]): [可选] 多账户列表, 若未指定任何账户, 则为 [TqSim()]   Example1::    from tqsdk import TqApi, TqAccount, TqMultiAccount    account1 = TqAccount(""H海通期货"", ""123456"", ""123456"")    account2 = TqAccount(""H宏源期货"", ""654321"", ""123456"")    api = TqApi(TqMultiAccount([account1, account2]), auth=TqAuth(""信易账户"", ""账户密码""))    # 分别获取账户资金信息    order1 = api.insert_order(symbol=""DCE.m2101"", direction=""BUY"", offset=""OPEN"", volume=3, account=account1)    order2 = api.insert_order(symbol=""SHFE.au2012C308"", direction=""BUY"", offset=""OPEN"", volume=3, limit_price=78.0, account=account2)    while order1.status != ""FINISHED"" or order2.status != ""FINISHED"":     api.wait_update()    # 分别获取账户资金信息    account_info1 = account1.get_account()    account_info2 = account2.get_account()    api.close()   Example2::    # 多账户模式下使用 TargetPosTask    from tqsdk import TqApi, TqAccount, TqMultiAccount, TqAuth, TargetPosTask    account1 = TqAccount(""H海通期货"", ""123456"", ""123456"")    account2 = TqAccount(""H宏源期货"", ""654321"", ""123456"")    api = TqApi(TqMultiAccount([account1, account2]), auth=TqAuth(""信易账户"", ""账户密码""))    symbol1 = ""DCE.m2105""    symbol2 = ""DCE.i2101""    position1 = account1.get_position(symbol1)    position2 = account2.get_position(symbol2)    # 多账户模式下, 调仓工具需要指定账户实例    target_pos1 = TargetPosTask(api, symbol1, account=account1)    target_pos2 = TargetPosTask(api, symbol2, account=account2)    target_pos1.set_target_volume(30)    target_pos2.set_target_volume(80)    while position1.volume_long != 30 or position2.volume_long != 80:     api.wait_update()    api.close()   """"""   self._account_list = accounts if accounts else [TqSim()]   self._has_tq_account = any([True for a in self._account_list if isinstance(a, BaseOtg)]) # 是否存在实盘账户(TqAccount/TqKq/TqKqStock)   self._map_conn_id = {} # 每次建立连接时，记录每个 conn_id 对应的账户   if self._has_duplicate_account():    raise Exception(""多账户列表中不允许使用重复的账户实例."")  def _has_duplicate_account(self):   # 存在相同的账户实例   account_set = set([a._account_key for a in self._account_list])   return len(account_set) != len(self._account_list)  def _check_valid(self, account: Union[str, TqAccount, TqKq, TqKqStock, TqSim, TqSimStock, None]):   """"""   查询委托、成交、资产、委托时, 需要指定账户实例   account: 类型 str 表示 account_key，其他为账户类型或者 None   """"""   if isinstance(account, str):    selected_list = [a for a in self._account_list if a._account_key == account]    return selected_list[0] if selected_list else None   elif account is None:    return self._account_list[0] if len(self._account_list) == 1 else None   else:    return account if account in self._account_list else None  def _get_account_id(self, account):   """""" 获取指定账户实例的账户属性 """"""   acc = self._check_valid(account)   return acc._account_id if acc else None  def _get_account_key(self, account):   """""" 获取指定账户实例的账户属性 """"""   acc = self._check_valid(account)   return acc._account_key if acc else None  def _is_stock_type(self, account_or_account_key):   """""" 判断账户类型是否为股票账户 """"""   acc = self._check_valid(account_or_account_key)   return isinstance(acc, StockMixin)  def _get_trade_more_data_and_order_id(self, data):   """""" 获取业务信息截面 trade_more_data 标识，当且仅当所有账户的标识置为 false 时，业务信息截面就绪 """"""   trade_more_datas = []   for account in self._account_list:    trade_node = data.get(""trade"", {}).get(account._account_key, {})    trade_more_data = trade_node.get(""trade_more_data"", True)    trade_more_datas.append(trade_more_data)   return any(trade_more_datas)  def _run(self, api, api_send_chan, api_recv_chan, ws_md_send_chan, ws_md_recv_chan):   self._api = api   log = ShinnyLoggerAdapter(self._api._logger.getChild(""TqMultiAccount""))   for index, account in enumerate(self._account_list):    _send_chan = api_send_chan if index == len(self._account_list) - 1 else TqChan(self._api, logger=log)    _recv_chan = api_recv_chan if index == len(self._account_list) - 1 else TqChan(self._api, logger=log)    _send_chan._logger_bind(chan_name=f""send to account_{index}"")    _recv_chan._logger_bind(chan_name=f""recv from account_{index}"")    ws_md_send_chan._logger_bind(chan_from=f""account_{index}"")    ws_md_recv_chan._logger_bind(chan_to=f""account_{index}"")    if isinstance(account, BaseSim):     # 启动模拟账户实例     self._api.create_task(      account._run(self._api, _send_chan, _recv_chan, ws_md_send_chan, ws_md_recv_chan))    else:     # 连接交易服务器     ws_td_send_chan, ws_td_recv_chan = self._connect_td(account, index)     ws_td_send_chan._logger_bind(chan_from=f""account_{index}"")     ws_td_recv_chan._logger_bind(chan_to=f""account_{index}"")     # 账户处理消息     self._api.create_task(      account._run(self._api, _send_chan, _recv_chan, ws_md_send_chan, ws_md_recv_chan, ws_td_send_chan,         ws_td_recv_chan)     )    ws_md_send_chan, ws_md_recv_chan = _send_chan, _recv_chan  def _connect_td(self, account: Union[TqAccount, TqKq, TqKqStock] = None, index: int = 0):   # 连接交易服务器   td_logger = self._format_logger(""TqConnect"", account)   conn_id = f""td_{index}""   ws_td_send_chan = TqChan(self._api, chan_name=f""send to {conn_id}"", logger=td_logger)   ws_td_recv_chan = TqChan(self._api, chan_name=f""recv from {conn_id}"", logger=td_logger)   conn = TqConnect(td_logger, conn_id=conn_id)   self._api.create_task(conn._run(self._api, account._td_url, ws_td_send_chan, ws_td_recv_chan))   ws_td_send_chan._logger_bind(chan_from=f""td_reconn_{index}"")   ws_td_recv_chan._logger_bind(chan_to=f""td_reconn_{index}"")   td_handler_logger = self._format_logger(""TdReconnect"", account)   td_reconnect = TdReconnectHandler(td_handler_logger)   send_to_recon = TqChan(self._api, chan_name=f""send to td_reconn_{index}"", logger=td_handler_logger)   recv_from_recon = TqChan(self._api, chan_name=f""recv from td_reconn_{index}"", logger=td_handler_logger)   self._api.create_task(    td_reconnect._run(self._api, send_to_recon, recv_from_recon, ws_td_send_chan, ws_td_recv_chan)   )   self._map_conn_id[conn_id] = account   return send_to_recon, recv_from_recon  def _format_logger(self, log_name: str, account: Union[TqAccount, TqKq, TqKqStock, TqSim]):   return ShinnyLoggerAdapter(self._api._logger.getChild(log_name),         url=account._td_url,         broker_id=account._broker_id,         account_id=account._account_id) "
92,n\tqsdk\obj,"n\tqsdk\obj. #:!/usr/bin/env python #: -*- coding: utf-8 -*- __author__ = 'chengzhi' import copy import json import warnings from tqsdk.diff import _get_obj from tqsdk.entity import Entity from tqsdk.utils import _query_for_init, _generate_uuid class QuotesEntity(Entity):  def __init__(self, api):   self._api = api   self._not_send_init_query = True  def __iter__(self):   message = """"""    不推荐使用 api._data['quotes'] 获取全部合约，该使用方法会在 20201101 之后的版本中放弃维护。    需要注意：    * 在同步代码中，初次使用 api._data['quotes'] 获取全部合约会产生一个耗时很长的查询。    * 在协程中，api._data['quotes'] 这种用法不支持使用。    请尽快修改使用新的接口，参考链接 http://doc.shinnytech.com/tqsdk/reference/tqsdk.api.html#tqsdk.api.TqApi.query_quotes   """"""   warnings.warn(message, DeprecationWarning, stacklevel=3)   self._api._logger.warning(""deprecation"", content=""Deprecation Warning in api._data['quotes']"")   # 兼容旧版 tqsdk 所做的修改，来支持用户使用 for k,v in api._data.quotes.items() 类似的用法   # 从 api._init_() 最后 3 行移到这里   if self._not_send_init_query and self._api._stock:    self._not_send_init_query = False    q = _query_for_init()    self._api.query_graphql(q, {}, _generate_uuid(""PYSDK_quote""))   return super().__iter__() class Quote(Entity):  """""" Quote 是一个行情对象 """"""  def __init__(self, api):   self._api = api   #: 行情从交易所发出的时间(北京时间), 格式为 ""2017-07-26 23:04:21.000001""   self.datetime: str = """"   #: 卖一价   self.ask_price1: float = float(""nan"")   #: 卖一量   self.ask_volume1: int = 0   #: 买一价   self.bid_price1: float = float(""nan"")   #: 买一量   self.bid_volume1: int = 0   #: 卖二价   self.ask_price2: float = float(""nan"")   #: 卖二量   self.ask_volume2: int = 0   #: 买二价   self.bid_price2: float = float(""nan"")   #: 买二量   self.bid_volume2: int = 0   #: 卖三价   self.ask_price3: float = float(""nan"")   #: 卖三量   self.ask_volume3: int = 0   #: 买三价   self.bid_price3: float = float(""nan"")   #: 买三量   self.bid_volume3: int = 0   #: 卖四价   self.ask_price4: float = float(""nan"")   #: 卖四量   self.ask_volume4: int = 0   #: 买四价   self.bid_price4: float = float(""nan"")   #: 买四量   self.bid_volume4: int = 0   #: 卖五价   self.ask_price5: float = float(""nan"")   #: 卖五量   self.ask_volume5: int = 0   #: 买五价   self.bid_price5: float = float(""nan"")   #: 买五量   self.bid_volume5: int = 0   #: 最新价   self.last_price: float = float(""nan"")   #: 当日最高价   self.highest: float = float(""nan"")   #: 当日最低价   self.lowest: float = float(""nan"")   #: 开盘价   self.open: float = float(""nan"")   #: 收盘价   self.close: float = float(""nan"")   #: 当日均价   self.average: float = float(""nan"")   #: 成交量   self.volume: int = 0   #: 成交额   self.amount: float = float(""nan"")   #: 持仓量   self.open_interest: int = 0   #: 结算价   self.settlement: float = float(""nan"")   #: 涨停价   self.upper_limit: float = float(""nan"")   #: 跌停价   self.lower_limit: float = float(""nan"")   #: 昨持仓量   self.pre_open_interest: int = 0   #: 昨结算价   self.pre_settlement: float = float(""nan"")   #: 昨收盘价   self.pre_close: float = float(""nan"")   #: 合约价格变动单位   self.price_tick: float = float(""nan"")   #: 合约价格小数位数   self.price_decs: int = 0   #: 合约乘数   self.volume_multiple: int = 0   #: 最大限价单手数   self.max_limit_order_volume: int = 0   #: 最大市价单手数   self.max_market_order_volume: int = 0   #: 最小限价单手数   self.min_limit_order_volume: int = 0   #: 最小市价单手数   self.min_market_order_volume: int = 0   #: 标的合约   self.underlying_symbol: str = """"   #: 行权价   self.strike_price: float = float(""nan"")   #: 合约类型   self.ins_class: str = """"   #: 交易所内的合约代码   self.instrument_id: str = """"   #: 合约中文名   self.instrument_name: str = """"   #: 交易所代码   self.exchange_id: str = """"   #: 合约是否已下市   self.expired: bool = False   #: 交易时间段   self.trading_time: TradingTime = TradingTime(self._api)   #: 到期具体日，以秒为单位的 timestamp 值   self.expire_datetime: float = float(""nan"")   #: 期货交割日年份，只对期货品种有效。期权推荐使用最后行权日年份   self.delivery_year: int = 0   #: 期货交割日月份，只对期货品种有效。期权推荐使用最后行权日月份   self.delivery_month: int = 0   #: 期权最后行权日，以秒为单位的 timestamp 值   self.last_exercise_datetime: float = float(""nan"")   #: 期权最后行权日年份，只对期权品种有效。   self.exercise_year: int = 0   #: 期权最后行权日月份，只对期权品种有效。   self.exercise_month: int = 0   #: 期权方向   self.option_class: str = """"   #: 期权行权方式，美式:'A'，欧式:'E'   self.exercise_type: str = """"   #: 品种代码   self.product_id: str = """"   #: ETF实时单位基金净值   self.iopv: float = float(""nan"")   #: 日流通股数，只对证券产品有效。   self.public_float_share_quantity: int = 0   #: 除权表 [""20190601,0.15"",""20200107,0.2""…]   self.stock_dividend_ratio: list = []   #: 除息表 [""20190601,0.15"",""20200107,0.2""…]   self.cash_dividend_ratio: list = []   #: 距离到期日的剩余天数（自然日天数），正数表示距离到期日的剩余天数，0表示到期日当天，负数表示距离到期日已经过去的天数   self.expire_rest_days: int = float('nan')  def _instance_entity(self, path):   super(Quote, self)._instance_entity(path)   self.trading_time = copy.copy(self.trading_time)   self.trading_time._instance_entity(path + [""trading_time""])  @property  def underlying_quote(self):   """"""   标的合约 underlying_symbol 所指定的合约对象，若没有标的合约则为 None   :return: 标的指定的 :py:class:`~tqsdk.objs.Quote` 对象   """"""   if self.underlying_symbol:    return self._api.get_quote(self.underlying_symbol)   return None  def __await__(self):   assert self._task   return self._task.__await__() class TradingTime(Entity):  """""" TradingTime 是一个交易时间对象   它不是一个可单独使用的类，而是用于定义 Qoute 的 trading_time 字段的类型   (每个连续的交易时间段是一个列表，包含两个字符串元素，分别为这个时间段的起止点)""""""  def __init__(self, api):   self._api = api   #: 白盘   self.day: list = []   #: 夜盘（注意：本字段中过了 24：00 的时间则在其基础往上加，如凌晨1点为 '25:00:00' ）   self.night: list = []  def __repr__(self):   return json.dumps({""day"": self.day, ""night"": self.night}) class TradingStatus(Entity):  """""" TradingStatus 是一个交易状态对象 """"""  def __init__(self, api):   self._api = api   #: 合约   self.symbol: str = """"   #: 交易状态, AUCTIONORDERING: 集合竞价报单; CONTINOUS: 连续交易; NOTRADING: 非交易时段   self.trade_status: str = """"  def __await__(self):   assert self._task   return self._task.__await__() class Kline(Entity):  """""" Kline 是一个K线对象 """"""  def __init__(self, api):   self._api = api   #: K线起点时间(按北京时间)，自unix epoch(1970-01-01 00:00:00 GMT)以来的纳秒数   self.datetime: int = 0   #: K线起始时刻的最新价   self.open: float = float(""nan"")   #: K线时间范围内的最高价   self.high: float = float(""nan"")   #: K线时间范围内的最低价   self.low: float = float(""nan"")   #: K线结束时刻的最新价   self.close: float = float(""nan"")   #: K线时间范围内的成交量   self.volume: int = 0   #: K线起始时刻的持仓量   self.open_oi: int = 0   #: K线结束时刻的持仓量   self.close_oi: int = 0 class Tick(Entity):  """""" Tick 是一个tick对象 """"""  def __init__(self, api):   self._api = api   #: tick从交易所发出的时间(按北京时间)，自unix epoch(1970-01-01 00:00:00 GMT)以来的纳秒数   self.datetime: int = 0   #: 最新价   self.last_price: float = float(""nan"")   #: 当日均价   self.average: float = float(""nan"")   #: 当日最高价   self.highest: float = float(""nan"")   #: 当日最低价   self.lowest: float = float(""nan"")   #: 卖1价   self.ask_price1: float = float(""nan"")   #: 卖1量   self.ask_volume1: int = 0   #: 买1价   self.bid_price1: float = float(""nan"")   #: 买1量   self.bid_volume1: int = 0   #: 卖2价   self.ask_price2: float = float(""nan"")   #: 卖2量   self.ask_volume2: int = 0   #: 买2价   self.bid_price2: float = float(""nan"")   #: 买2量   self.bid_volume2: int = 0   #: 卖3价   self.ask_price3: float = float(""nan"")   #: 卖3量   self.ask_volume3: int = 0   #: 买3价   self.bid_price3: float = float(""nan"")   #: 买3量   self.bid_volume3: int = 0   #: 卖4价   self.ask_price4: float = float(""nan"")   #: 卖4量   self.ask_volume4: int = 0   #: 买4价   self.bid_price4: float = float(""nan"")   #: 买4量   self.bid_volume4: int = 0   #: 卖5价   self.ask_price5: float = float(""nan"")   #: 卖5量   self.ask_volume5: int = 0   #: 买5价   self.bid_price5: float = float(""nan"")   #: 买5量   self.bid_volume5: int = 0   #: 当日成交量   self.volume: int = 0   #: 成交额   self.amount: float = float(""nan"")   #: 持仓量   self.open_interest: int = 0 class Account(Entity):  """""" Account 是一个账户对象 """"""  def __init__(self, api):   self._api = api   #: 币种   self.currency: str = """"   #: 昨日账户权益(不包含期权)   self.pre_balance: float = float(""nan"")   #: 静态权益 （静态权益 = 昨日结算的权益 + 今日入金 - 今日出金, 以服务器查询ctp后返回的金额为准）(不包含期权)   self.static_balance: float = float(""nan"")   #: 账户权益 （账户权益 = 动态权益 = 静态权益 + 平仓盈亏 + 持仓盈亏 - 手续费 + 权利金 + 期权市值）   self.balance: float = float(""nan"")   #: 可用资金（可用资金 = 账户权益 - 冻结保证金 - 保证金 - 冻结权利金 - 冻结手续费 - 期权市值）   self.available: float = float(""nan"")   #: 期货公司返回的balance（ctp_balance = 静态权益 + 平仓盈亏 + 持仓盈亏 - 手续费 + 权利金）   self.ctp_balance: float = float(""nan"")   #: 期货公司返回的available（ctp_available = ctp_balance - 保证金 - 冻结保证金 - 冻结手续费 - 冻结权利金）   self.ctp_available: float = float(""nan"")   #: 浮动盈亏   self.float_profit: float = float(""nan"")   #: 持仓盈亏   self.position_profit: float = float(""nan"")   #: 本交易日内平仓盈亏   self.close_profit: float = float(""nan"")   #: 冻结保证金   self.frozen_margin: float = float(""nan"")   #: 保证金占用   self.margin: float = float(""nan"")   #: 冻结手续费   self.frozen_commission: float = float(""nan"")   #: 本交易日内交纳的手续费   self.commission: float = float(""nan"")   #: 冻结权利金   self.frozen_premium: float = float(""nan"")   #: 本交易日内收入-交纳的权利金   self.premium: float = float(""nan"")   #: 本交易日内的入金金额   self.deposit: float = float(""nan"")   #: 本交易日内的出金金额   self.withdraw: float = float(""nan"")   #: 风险度（风险度 = 保证金 / 账户权益）   self.risk_ratio: float = float(""nan"")   #: 期权市值   self.market_value: float = float(""nan"") class Position(Entity):  """""" Position 是一个持仓对象 """"""  def __init__(self, api):   self._api = api   #: 交易所   self.exchange_id: str = """"   #: 交易所内的合约代码   self.instrument_id: str = """"   #: 多头老仓手数   self.pos_long_his: int = 0   #: 多头今仓手数   self.pos_long_today: int = 0   #: 空头老仓手数   self.pos_short_his: int = 0   #: 空头今仓手数   self.pos_short_today: int = 0   #: 期货公司查询的多头今仓手数 (不推荐, 推荐使用pos_long_today)   self.volume_long_today: int = 0   #: 期货公司查询的多头老仓手数 (不推荐, 推荐使用pos_long_his)   self.volume_long_his: int = 0   #: 期货公司查询的多头手数 (不推荐, 推荐使用pos_long)   self.volume_long: int = 0   #: 期货公司查询的多头今仓冻结 (不推荐)   self.volume_long_frozen_today: int = 0   #: 期货公司查询的多头老仓冻结 (不推荐)   self.volume_long_frozen_his: int = 0   #: 期货公司查询的多头持仓冻结 (不推荐)   self.volume_long_frozen: int = 0   #: 期货公司查询的空头今仓手数 (不推荐, 推荐使用pos_short_today)   self.volume_short_today: int = 0   #: 期货公司查询的空头老仓手数 (不推荐, 推荐使用pos_short_his)   self.volume_short_his: int = 0   #: 期货公司查询的空头手数 (不推荐, 推荐使用pos_short)   self.volume_short: int = 0   #: 期货公司查询的空头今仓冻结 (不推荐)   self.volume_short_frozen_today: int = 0   #: 期货公司查询的空头老仓冻结 (不推荐)   self.volume_short_frozen_his: int = 0   #: 期货公司查询的空头持仓冻结 (不推荐)   self.volume_short_frozen: int = 0   #: 多头开仓均价,以开仓价来统计   self.open_price_long: float = float(""nan"")   #: 空头开仓均价,以开仓价来统计   self.open_price_short: float = float(""nan"")   #: 多头开仓成本,为开仓价乘以手数   self.open_cost_long: float = float(""nan"")   #: 空头开仓成本,为开仓价乘以手数   self.open_cost_short: float = float(""nan"")   #: 多头持仓均价,为多头持仓成本除以多头数量   self.position_price_long: float = float(""nan"")   #: 空头持仓均价,为空头持仓成本除以空头数量   self.position_price_short: float = float(""nan"")   #: 多头持仓成本,为今仓的开仓价乘以手数加上昨仓的昨结算价乘以手数的和   self.position_cost_long: float = float(""nan"")   #: 空头持仓成本,为今仓的开仓价乘以手数加上昨仓的昨结算价乘以手数的和   self.position_cost_short: float = float(""nan"")   #: 多头浮动盈亏   self.float_profit_long: float = float(""nan"")   #: 空头浮动盈亏   self.float_profit_short: float = float(""nan"")   #: 浮动盈亏 （浮动盈亏: 相对于开仓价的盈亏）   self.float_profit: float = float(""nan"")   #: 多头持仓盈亏   self.position_profit_long: float = float(""nan"")   #: 空头持仓盈亏   self.position_profit_short: float = float(""nan"")   #: 持仓盈亏 （持仓盈亏: 相对于上一交易日结算价的盈亏），期权持仓盈亏为 0   self.position_profit: float = float(""nan"")   #: 多头占用保证金   self.margin_long: float = float(""nan"")   #: 空头占用保证金   self.margin_short: float = float(""nan"")   #: 占用保证金   self.margin: float = float(""nan"")   #: 期权权利方市值(始终 >= 0)   self.market_value_long: float = float(""nan"")   #: 期权义务方市值(始终 <= 0)   self.market_value_short: float = float(""nan"")   #: 期权市值   self.market_value: float = float(""nan"")   #: 净持仓手数, ==0表示无持仓或多空持仓手数相等. <0表示空头持仓大于多头持仓, >0表示多头持仓大于空头持仓   self.pos: int = 0   #: 多头持仓手数, ==0表示无多头持仓. >0表示多头持仓手数   self.pos_long: int = 0   #: 空头持仓手数, ==0表示无空头持仓. >0表示空头持仓手数   self.pos_short: int = 0  @property  def orders(self):   """"""   与此持仓相关的且目前委托单状态为ALIVE的开仓/平仓挂单   :return: dict, 其中每个元素的key为委托单ID, value为 :py:class:`~tqsdk.objs.Order`   """"""   tdict = _get_obj(self._api._data, [""trade"", self._path[1], ""orders""])   fts = {order_id: order for order_id, order in tdict.items() if (not order_id.startswith(    ""_"")) and order.instrument_id == self.instrument_id and order.exchange_id == self.exchange_id and order.status == ""ALIVE""}   return fts class Order(Entity):  """""" Order 是一个委托单对象 """"""  def __init__(self, api):   self._api = api   #: 委托单ID, 对于一个用户的所有委托单，这个ID都是不重复的   self.order_id: str = """"   #: 交易所单号   self.exchange_order_id: str = """"   #: 交易所   self.exchange_id: str = """"   #: 交易所内的合约代码   self.instrument_id: str = """"   #: 下单方向, BUY=买, SELL=卖   self.direction: str = """"   #: 开平标志, OPEN=开仓, CLOSE=平仓, CLOSETODAY=平今   self.offset: str = """"   #: 总报单手数   self.volume_orign: int = 0   #: 未成交手数   self.volume_left: int = 0   #: 委托价格, 仅当 price_type = LIMIT 时有效   self.limit_price: float = float(""nan"")   #: 价格类型, ANY=市价, LIMIT=限价   self.price_type: str = """"   #: 手数条件, ANY=任何数量, MIN=最小数量, ALL=全部数量   self.volume_condition: str = """"   #: 时间条件, IOC=立即完成，否则撤销, GFS=本节有效, GFD=当日有效, GTC=撤销前有效, GFA=集合竞价有效   self.time_condition: str = """"   #: 下单时间，自unix epoch(1970-01-01 00:00:00 GMT)以来的纳秒数.   self.insert_date_time: int = 0   #: 委托单状态信息   self.last_msg: str = """"   #: 委托单状态, ALIVE=有效, FINISHED=已完   self.status: str = """"   #: 委托单是否确定已死亡（以后一定不会再产生成交）(注意，False 不代表委托单还存活，有可能交易所回来的信息还在路上或者丢掉了)   self.is_dead: bool = None   #: 委托单是否确定已报入交易所并等待成交 (注意，返回 False 不代表确定未报入交易所，有可能交易所回来的信息还在路上或者丢掉了)   self.is_online: bool = None   #: 委托单是否确定是错单（即下单失败，一定不会有成交）(注意，返回 False 不代表确定不是错单，有可能交易所回来的信息还在路上或者丢掉了)   self.is_error: bool = None   #: 平均成交价   self.trade_price: float = float('nan')   self._this_session = False  @property  def trade_records(self):   """"""   成交记录   :return: dict, 其中每个元素的key为成交ID, value为 :py:class:`~tqsdk.objs.Trade`   """"""   tdict = _get_obj(self._api._data, [""trade"", self._path[1], ""trades""])   fts = {trade_id: trade for trade_id, trade in tdict.items() if    (not trade_id.startswith(""_"")) and trade.order_id == self.order_id}   return fts class Trade(Entity):  """""" Trade 是一个成交对象 """"""  def __init__(self, api):   self._api = api   #: 委托单ID, 对于一个用户的所有委托单，这个ID都是不重复的   self.order_id: str = """"   #: 成交ID, 对于一个用户的所有成交，这个ID都是不重复的   self.trade_id: str = """"   #: 交易所成交编号   self.exchange_trade_id: str = """"   #: 交易所   self.exchange_id: str = """"   #: 交易所内的合约代码   self.instrument_id: str = """"   #: 下单方向, BUY=买, SELL=卖   self.direction: str = """"   #: 开平标志, OPEN=开仓, CLOSE=平仓, CLOSETODAY=平今   self.offset: str = """"   #: 成交价格   self.price: float = float(""nan"")   #: 成交手数   self.volume: int = 0   #: 成交时间，自unix epoch(1970-01-01 00:00:00 GMT)以来的纳秒数   self.trade_date_time: int = 0 class RiskManagementRule(Entity):  def __init__(self, api):   self._api = api   self.user_id = """"   self.exchange_id = """"   self.enable = False   self.self_trade = SelfTradeRule(self._api)   self.frequent_cancellation = FrequentCancellationRule(self._api)   self.trade_position_ratio = TradePositionRatioRule(self._api)  def _instance_entity(self, path):   super(RiskManagementRule, self)._instance_entity(path)   self.self_trade = copy.copy(self.self_trade)   self.self_trade._instance_entity(path + [""self_trade""])   self.frequent_cancellation = copy.copy(self.frequent_cancellation)   self.frequent_cancellation._instance_entity(path + [""frequent_cancellation""])   self.trade_position_ratio = copy.copy(self.trade_position_ratio)   self.trade_position_ratio._instance_entity(path + [""trade_position_ratio""]) class SelfTradeRule(Entity):  """"""自成交风控规则""""""  def __init__(self, api):   self._api = api   #: 最大自成交次数限制   self.count_limit = 0  def __repr__(self):   return json.dumps({""count_limit"": self.count_limit}) class FrequentCancellationRule(Entity):  """"""频繁报撤单风控规则""""""  def __init__(self, api):   self._api = api   #: 频繁报撤单起算报单次数   self.insert_order_count_limit = 0   #: 频繁报撤单起算撤单次数   self.cancel_order_count_limit = 0   #: 频繁报撤单撤单比例限额,为百分比   self.cancel_order_percent_limit = float(""nan"")  def __repr__(self):   return json.dumps({    ""insert_order_count_limit"": self.insert_order_count_limit,    ""cancel_order_count_limit"": self.cancel_order_count_limit,    ""cancel_order_percent_limit"": self.cancel_order_percent_limit   }) class TradePositionRatioRule(Entity):  """"""成交持仓比风控规则""""""  def __init__(self, api):   self._api = api   #: 成交持仓比起算成交手数   self.trade_units_limit = 0   #: 成交持仓比例限额,为百分比   self.trade_position_ratio_limit = float(""nan"")  def __repr__(self):   return json.dumps({    ""trade_units_limit"": self.trade_units_limit,    ""trade_position_ratio_limit"": self.trade_position_ratio_limit   }) class RiskManagementData(Entity):  def __init__(self, api):   self._api = api   #: 用户ID   self.user_id = """"   #: 交易所ID   self.exchange_id = """"   #: 合约ID   self.instrument_id = """"   #: 自成交情况   self.self_trade = SelfTrade(self._api)   #: 频繁报撤单情况   self.frequent_cancellation = FrequentCancellation(self._api)   #: 成交持仓比情况   self.trade_position_ratio = TradePositionRatio(self._api)  def _instance_entity(self, path):   super(RiskManagementData, self)._instance_entity(path)   self.self_trade = copy.copy(self.self_trade)   self.self_trade._instance_entity(path + [""self_trade""])   self.frequent_cancellation = copy.copy(self.frequent_cancellation)   self.frequent_cancellation._instance_entity(path + [""frequent_cancellation""])   self.trade_position_ratio = copy.copy(self.trade_position_ratio)   self.trade_position_ratio._instance_entity(path + [""trade_position_ratio""]) class SelfTrade(Entity):  """"""自成交情况""""""  def __init__(self, api):   self._api = api   #: 当前最高买价   self.highest_buy_price = float(""nan"")   #: 当前最低卖价   self.lowest_sell_price = float(""nan"")   #: 当天已经发生的自成交次数   self.self_trade_count = 0   #: 当天由于自成交而被拒的报单次数   self.rejected_count = 0  def __repr__(self):   return json.dumps({    ""highest_buy_price"": self.highest_buy_price,    ""lowest_sell_price"": self.lowest_sell_price,    ""self_trade_count"": self.self_trade_count,    ""rejected_count"": self.rejected_count   }) class FrequentCancellation(Entity):  """"""频繁报撤单情况""""""  def __init__(self, api):   self._api = api   #: 当天已经发生的报单次数   self.insert_order_count = 0   #: 当天已经发生的撤单次数   self.cancel_order_count = 0   #: 当天的撤单比例，为百分比   self.cancel_order_percent = float(""nan"")   #: 当天由于撤单比例超限而被拒的撤单次数   self.rejected_count = 0  def __repr__(self):   return json.dumps({    ""insert_order_count"": self.insert_order_count,    ""cancel_order_count"": self.cancel_order_count,    ""cancel_order_percent"": self.cancel_order_percent,    ""rejected_count"": self.rejected_count   }) class TradePositionRatio(Entity):  """"""成交持仓比情况""""""  def __init__(self, api):   self._api = api   #: 当天已经发生的成交手数   self.trade_units = 0   #: 当前的净持仓手数, 正为多仓, 负为空仓   self.net_position_units = 0   #: 当前的成交持仓比, 为百分比   self.trade_position_ratio = float(""nan"")   #: 当天由于成交持仓比超限而被拒的报单次数   self.rejected_count = 0  def __repr__(self):   return json.dumps({    ""trade_units"": self.trade_units,    ""net_position_units"": self.net_position_units,    ""trade_position_ratio"": self.trade_position_ratio,    ""rejected_count"": self.rejected_count   }) class SecurityAccount(Entity):  """""" SecurityAccount 是一个股票账户对象""""""  def __init__(self, api):   self._api = api   #: 用户客户号   self.user_id: str = """"   #: 币种, CNY=人民币, USD=美元, HKD=港币   self.currency: str = ""CNY""   #: 当前市值   self.market_value: float = float(""nan"")   #: 当前资产 = 当前市值 + 可用金额 + 委托冻结金额 + 委托冻结费用   self.asset: float = float(""nan"")   #: 期初资产   self.asset_his: float = float(""nan"")   #: 当前可用余额 = 期初可用 + 当日入金 - 当日出金 + 当日分红金额 - 当日买入金额 - 当日买入费用 + 当日卖出金额 - 当日卖出费用 - 委托冻结金额 - 委托冻结手续费   self.available: float = float(""nan"")   #: 期初可用余额   self.available_his: float = float(""nan"")   #: 当前买入成本   self.cost: float = float(""nan"")   #: 当前可取余额 = MAX(期初余额 + 当日入金 – 当日出金 + MIN(0，当日卖出释放资金 - 当日买入占用资金 - 委托冻结金额), 0)   self.drawable: float = float(""nan"")   #: 本交易日内累计入金金额   self.deposit: float = float(""nan"")   #: 本交易日内累计出金金额   self.withdraw: float = float(""nan"")   #: 当前交易冻结金额（不含费用）= sum(order.volume_orign * order.limit_price)   self.buy_frozen_balance: float = float(""nan"")   #: 当前交易冻结费用 = sum(order.frozen_fee)   self.buy_frozen_fee: float = float(""nan"")   #: 当日买入占用资金（不含费用）   self.buy_balance_today: float = float(""nan"")   #: 当日买入累计费用   self.buy_fee_today: float = float(""nan"")   #: 当日卖出释放资金   self.sell_balance_today: float = float(""nan"")   #: 当日卖出累计费用   self.sell_fee_today: float = float(""nan"")   #: 当日持仓盈亏 = 当前市值 - 当前买入成本   self.hold_profit: float = float(""nan"")   #: 当日浮动盈亏 = SUM(持仓当日浮动盈亏)   self.float_profit_today: float = float(""nan"")   #: 当日实现盈亏 = SUM(持仓当日实现盈亏)   self.real_profit_today: float = float(""nan"")   #: 当日盈亏 = 当日浮动盈亏 + 当日实现盈亏   self.profit_today: float = float(""nan"")   #: 当日盈亏比 = 当日盈亏 / (当前买入成本 if 当前买入成本 > 0 else 期初资产)   self.profit_rate_today: float = float(""nan"")   #: 当日分红金额   self.dividend_balance_today: float = float(""nan"") class SecurityPosition(Entity):  """""" SecurityPosition 是一个股票账户持仓对象 """"""  def __init__(self, api):   self._api = api   #: 用户客户号   self.user_id: str = """"   #: 交易所   self.exchange_id: str = """"   #: 证券代码   self.instrument_id: str = """"   #: 建仓日期   self.create_date: str = """"   #: 当前成本 = 昨买入成本 + 今买金额 + 今买费用 - 今卖数量 × (昨买入成本 / 昨持仓数量)   self.cost: float = float(""nan"")   #: 期初成本   self.cost_his: float = float(""nan"")   #: 今持仓数量 = 昨持仓数量 + 今买数量 - 今卖数量 + 送股数量   self.volume: int = 0   #: 昨持仓数量   self.volume_his: int = 0   #: 最新价   self.last_price: float = float(""nan"")   #: 当日累计买入持仓   self.buy_volume_today: int = 0   #: 当日累计买入金额 (不包括费用)   self.buy_balance_today: float = float(""nan"")   #: 当日累计买入费用   self.buy_fee_today: float = float(""nan"")   #: 当日累计卖出持仓   self.sell_volume_today: int = 0   #: 当日累计卖出金额(不包括费用)   self.sell_balance_today: float = float(""nan"")   #: 当日累计卖出费用   self.sell_fee_today: float = float(""nan"")   #: 期初累计买入持仓   self.buy_volume_his: int = 0   #: 期初累计买入金额   self.buy_balance_his: float = float(""nan"")   #: 期初累计买入费用   self.buy_fee_his: float = float(""nan"")   #: 期初累计卖出持仓   self.sell_volume_his: int = 0   #: 期初累计卖出金额   self.sell_balance_his: float = float(""nan"")   #: 期初累计卖出费用   self.sell_fee_his: float = float(""nan"")   #: 今送股数量   self.shared_volume_today: float = float(""nan"")   #: 今分红金额   self.devidend_balance_today: float = float(""nan"")   #: 当前市值 = 持仓数量 × 行情最新价   self.market_value: float = float(""nan"")   #: 期初市值   self.market_value_his: float = float(""nan"")   #: 当日浮动盈亏 = (昨持仓数量 - 今卖数量) * (最新价 - 昨收盘价) + (今持仓数量 - (昨持仓数量 - 今卖数量)) * (最新价 - 买入均价)   self.float_profit_today: float = float(""nan"")   #: 当日实现盈亏 = 今卖数量 * (最新价 - 昨收盘价) - 今卖费用 + 今派息金额   self.real_profit_today: float = float(""nan"")   #: 期初实现盈亏   self.real_profit_his: float = float(""nan"")   #: 当日盈亏 = 当日浮动盈亏 + 当日实现盈亏   self.profit_today: float = float(""nan"")   #: 当日收益率   self.profit_rate_today: float = float(""nan"")   #: 当日持仓盈亏 = 当前持仓市值 – 当前买入成本   self.hold_profit: float = float(""nan"")   #: 累计实现盈亏 += 当日实现盈亏（成本）   self.real_profit_total: float = float(""nan"")   #: 总盈亏 = 累计实现盈亏 + 持仓盈亏   self.profit_total: float = float(""nan"")   #: 累计收益率 = 总盈亏 / (期初成本 if 当前成本==0 else 当前成本)   self.profit_rate_total: float = float(""nan"")  @property  def orders(self):   tdict = _get_obj(self._api._data, [""trade"", self._path[1], ""orders""])   fts = {order_id: order for order_id, order in tdict.items() if (not order_id.startswith(    ""_"")) and order.instrument_id == self.instrument_id and order.exchange_id == self.exchange_id and order.status == ""ALIVE""}   return fts class SecurityOrder(Entity):  """""" SecurityOrder 是一个股票账户委托单对象 """"""  def __init__(self, api):   self._api = api   #: 用户客户号   self.user_id: str = """"   #: 订单号,要求客户端保证其在一个交易日内的唯一性   self.order_id: str = """"   #: 交易所委托合同编号   self.exchange_order_id: str = """"   #: 交易所代码   self.exchange_id: str = """"   #: 证券代码   self.instrument_id: str = """"   #: 下单方向, BUY=买, SELL=卖   self.direction: str = """"   #: 委托股数（A 股委托数量必须为 100 倍数；科创板股票必须为 200 倍数；零股卖出: 由于部分成交或分红导致持仓数量小于 100 股时，该部分持仓可一次性卖出，数量不为 100 或 200 倍数）   self.volume_orign: int = 0   #: 剩余股数   self.volume_left: int = 0   #: 报单价格类型，LIMIT=限价单，ANY=市价单   self.price_type: str = """"   #: 报单委托价格   self.limit_price: float = float(""nan"")   #: 冻结费用   self.frozen_fee: float = float(""nan"")   #: 委托时间，自unix epoch(1970-01-01 00:00:00 GMT)以来的纳秒数.   self.insert_date_time: int = 0   #: 委托单当前状态   self.status: str = """"   #: 委托单状态信息   self.last_msg: str = """"  @property  def trade_records(self):   """"""   成交记录   :return: dict, 其中每个元素的key为成交ID, value为 :py:class:`~tqsdk.objs.Trade`   """"""   tdict = _get_obj(self._api._data, [""trade"", self._path[1], ""trades""])   fts = {trade_id: trade for trade_id, trade in tdict.items() if    (not trade_id.startswith(""_"")) and trade.order_id == self.order_id}   return fts class SecurityTrade(Entity):  """""" SecurityTrade 是一个股票账户成交对象 """"""  def __init__(self, api):   self._api = api   #: 用户客户号   self.user_id: str = """"   #: 成交编号   self.trade_id: str = """"   #: 交易所代码   self.exchange_id: str = """"   #: 证券代码   self.instrument_id: str = """"   #: 委托单编号   self.order_id: str = """"   #: 交易所订单编号   self.exchange_order_id: str = """"   #: 下单方向, BUY=买, SELL=卖，SHARED=送股，DEVIDEND=分红   self.direction: str = """"   #: 成交数量或者送股数量   self.volume: int = 0   #: 成交价格   self.price: float = float(""nan"")   #: 成交发生金额或分红金额   self.balance: float = float(""nan"")   #: 费用   self.fee: float = float(""nan"")   #: 成交时间，自unix epoch(1970-01-01 00:00:00 GMT)以来的纳秒数.   self.trade_date_time: int = 0 "
93,n\tqsdk\objs not entit,"n\tqsdk\objs not entit. #:!/usr/bin/env python #: -*- coding: utf-8 -*- __author__ = 'mayanqiong' from collections import namedtuple from datetime import datetime from typing import Callable, Tuple import aiohttp from pandas import DataFrame, Series from sgqlc.operation import Operation from tqsdk.backtest import TqBacktest from tqsdk.datetime import _get_expire_rest_days, _str_to_timestamp_nano from tqsdk.ins_schema import ins_schema, _add_all_frags from tqsdk.objs import Quote from tqsdk.diff import _get_obj from tqsdk.utils import _query_for_quote, _generate_uuid from tqsdk.tafunc import _get_t_series, get_impv, _get_d1, get_delta, get_theta, get_gamma, get_vega, get_rho """""" 这两个类只在 api 中用到，主要为了支持用户异步中 await 没有继承 Entity 类 """""" async def ensure_quote(api, quote):  if quote.price_tick > 0 and quote.datetime != """":   return quote  async with api.register_update_notify(quote) as update_chan:   async for _ in update_chan:    if quote.price_tick > 0 and quote.datetime != """":     return quote async def ensure_quote_with_underlying(api, quote):  await ensure_quote(api, quote)  if quote.underlying_symbol:   await ensure_quote(api, quote.underlying_quote)  return quote class QuoteList(list):  """"""  请求合约信息和行情信息，self._task 完成时，所有的合约已经收到了合约信息和行情信息  """"""  def __init__(self, api, quotes):   self._api = api   list.__init__(self, quotes)   self._task = api.create_task(self._ensure_quotes(), _caller_api=True)   for quote in quotes:    # 为每个 quote 对象创建 _task    if not hasattr(quote, '_task'):     quote._task = api.create_task(ensure_quote_with_underlying(api, quote), _caller_api=True)  async def _ensure_symbols(self):   if all([q.price_tick > 0 for q in self]):    return   query_symbols = [q._path[-1] for q in self if not q.price_tick > 0]   query_pack = _query_for_quote(query_symbols)   self._api._send_pack(query_pack)   async with self._api.register_update_notify(self) as update_chan:    async for _ in update_chan:     if all([q.price_tick > 0 for q in self]):      return  async def _ensure_quotes(self):   await self._ensure_symbols()   self._api._auth._has_md_grants([q._path[-1] for q in self]) # 权限检查   # 发送的请求会请求到所有字段，如果是期权也会请求标的的合约信息   underlying_symbols = set([q.underlying_symbol for q in self if q.underlying_symbol])   need_quotes = set([q._path[-1] for q in self]).union(underlying_symbols)   if need_quotes - self._api._requests[""quotes""] != set():    self._api._requests[""quotes""] = self._api._requests[""quotes""].union(need_quotes)    self._api._send_pack({     ""aid"": ""subscribe_quote"",     ""ins_list"": "","".join(self._api._requests[""quotes""]),    })   if all([q.datetime != """" for q in self]):    return self   all_quotes = self + [_get_obj(self._api._data, [""quotes"", s], self._api._prototype[""quotes""][""#""]) for s in underlying_symbols]   async with self._api.register_update_notify(self) as update_chan:    async for _ in update_chan:     if all([q.datetime != """" for q in all_quotes]):      return self  def __await__(self):   return self._task.__await__() async def _query_graphql_async(api, query_id, query):  api._send_pack({   ""aid"": ""ins_query"",   ""query_id"": query_id,   ""query"": query  })  symbols = _get_obj(api._data, [""symbols""])  async with api.register_update_notify(symbols) as update_chan:   async for _ in update_chan:    s = symbols.get(query_id, {})    if s.get(""query"") == query:     break class SymbolList(list):  """"""  query 系列函数返回对象  """"""  def __init__(self, api, query_id: str, query: str, filter: Callable[[dict], list]):   self._api = api   self._query_id = query_id   self._query = query   self._filter = filter   list.__init__(self, [])   self._task = api.create_task(self._query_graphql(), _caller_api=True)  async def _query_graphql(self):   pack = {""query"": self._query}   symbols = _get_obj(self._api._data, [""symbols""])   query_result = None   for symbol in symbols.values():    if symbol.items() >= pack.items(): # 检查是否发送过相同的请求     query_result = symbol   if query_result is None:    await _query_graphql_async(self._api, self._query_id, self._query)    query_result = symbols.get(self._query_id)   self += self._filter(query_result)   if isinstance(self._api._backtest, TqBacktest): # 回测时，清空缓存的请求    self._api._send_pack({     ""aid"": ""ins_query"",     ""query_id"": self._query_id,     ""query"": """"    })   return self  def __await__(self):   return self._task.__await__() class SymbolLevelList(namedtuple('SymbolLevel', ['in_money_options', 'at_money_options', 'out_of_money_options'])):  """"""  query 系列函数返回对象  """"""  def __new__(cls, *args, **kwargs):   return super(SymbolLevelList, cls).__new__(cls, in_money_options=[], at_money_options=[], out_of_money_options=[])  def __init__(self, api, query_id: str, query: str, filter: Callable[[dict], Tuple[list, list, list]]):   self._api = api   self._query_id = query_id   self._query = query   self._filter = filter   self._task = api.create_task(self._query_graphql(), _caller_api=True)  async def _query_graphql(self):   pack = {""query"": self._query}   symbols = _get_obj(self._api._data, [""symbols""])   query_result = None   for symbol in symbols.values():    if symbol.items() >= pack.items(): # 检查是否发送过相同的请求     query_result = symbol   if query_result is None:    await _query_graphql_async(self._api, self._query_id, self._query)    query_result = symbols.get(self._query_id)   l0, l1, l2 = self._filter(query_result)   self[0].extend(l0)   self[1].extend(l1)   self[2].extend(l2)   if isinstance(self._api._backtest, TqBacktest): # 回测时，清空缓存的请求    self._api._send_pack({     ""aid"": ""ins_query"",     ""query_id"": self._query_id,     ""query"": """"    })   return self  def __await__(self):   return self._task.__await__() class TqDataFrame(DataFrame):  def __init__(self, api, *args, **kwargs):   super(TqDataFrame, self).__init__(*args, **kwargs)   self.__dict__[""_api""] = api   self.__dict__[""_task""] = api.create_task(self.async_update(), _caller_api=True)  async def async_update(self):   async with self._api.register_update_notify(self) as update_chan:    async for _ in update_chan:     if self._api._serials.get(id(self))[""init""]:      return self  def __await__(self):   return self.__dict__[""_task""].__await__() class TqSymbolDataFrame(DataFrame):  def __init__(self, api, symbol_list, backtest_timestamp, *args, **kwargs):   self.__dict__[""_api""] = api   self.__dict__[""_symbol_list""] = symbol_list   self.__dict__[""_backtest_timestamp""] = backtest_timestamp   self.__dict__[""_columns""] = [    ""ins_class"",    ""instrument_id"",    ""instrument_name"",    ""price_tick"",    ""volume_multiple"",    ""max_limit_order_volume"",    ""max_market_order_volume"",    ""underlying_symbol"",    ""strike_price"",    ""exchange_id"",    ""product_id"",    ""expired"",    ""expire_datetime"",    ""expire_rest_days"",    ""delivery_year"",    ""delivery_month"",    ""last_exercise_datetime"",    ""exercise_year"",    ""exercise_month"",    ""option_class"",    ""upper_limit"",    ""lower_limit"",    ""pre_settlement"",    ""pre_open_interest"",    ""pre_close"",    ""trading_time_day"",    ""trading_time_night""   ]   default_quote = Quote(None)   data = [{k: (s if k == ""instrument_id"" else default_quote.get(k, None)) for k in self.__dict__[""_columns""]} for s in symbol_list]   super(TqSymbolDataFrame, self).__init__(data=data, columns=self.__dict__[""_columns""], *args, **kwargs)   self.__dict__[""_task""] = api.create_task(self.async_update(), _caller_api=True)  async def async_update(self):   query_id = _generate_uuid(""PYSDK_api"")   op = Operation(ins_schema.rootQuery)   variables = {""instrument_id"": self.__dict__[""_symbol_list""]}   if self.__dict__[""_backtest_timestamp""]:    variables[""timestamp""] = self.__dict__[""_backtest_timestamp""]   query = op.multi_symbol_info(**variables)   _add_all_frags(query)   self.__dict__[""_api""]._send_pack({    ""aid"": ""ins_query"",    ""query_id"": query_id,    ""query"": op.__to_graphql__()   })   symbols = _get_obj(self.__dict__[""_api""]._data, [""symbols""])   async with self.__dict__[""_api""].register_update_notify(symbols) as update_chan:    async for _ in update_chan:     query_result = symbols.get(query_id, {})     if query_result:      all_keys = set(self.__dict__[""_columns""])      all_keys.add('trading_time')      quotes = self.__dict__[""_api""]._symbols_to_quotes(query_result, keys=all_keys)      self._quotes_to_dataframe(quotes)      if self.__dict__[""_backtest_timestamp""]:       # 回测时这些字段应该为 nan       self.loc[:, [""upper_limit"", ""lower_limit"", ""pre_settlement"", ""pre_open_interest"", ""pre_close""]] = float('nan')       # 回测时清空请求，不缓存请求内容       self.__dict__[""_api""]._send_pack({        ""aid"": ""ins_query"",        ""query_id"": query_id,        ""query"": """"       })      return self  def _get_trading_time(self, quotes, symbol, key):   v = quotes[symbol].get('trading_time', {'day': [], 'night': []}).get(key, [])   return v if v else None  def _quotes_to_dataframe(self, quotes):   default_quote = Quote(None)   for col in self.__dict__[""_columns""]:    if col == ""expire_rest_days"":     current_dt = self._api._get_current_datetime().timestamp()     self[col] = [_get_expire_rest_days(quotes[s]['expire_datetime'], current_dt)          if quotes[s].get('expire_datetime') else float('nan')          for s in self.__dict__[""_symbol_list""]]    elif col == ""trading_time_day"" or col == ""trading_time_night"":     k = 'day' if col == ""trading_time_day"" else 'night'     self[col] = Series([self._get_trading_time(quotes, s, k) for s in self.__dict__[""_symbol_list""]])    else:     self[col] = Series([quotes[s].get(col, default_quote[col]) for s in self.__dict__[""_symbol_list""]])  def __await__(self):   return self.__dict__[""_task""].__await__() class TqSymbolRankingDataFrame(DataFrame):  def __init__(self, api, symbol, ranking_type, days, start_dt, broker):   self.__dict__[""_api""] = api   params = {'symbol': symbol}   if days is not None:    params['days'] = days   if start_dt is not None:    params['start_date'] = start_dt.strftime(""%Y%m%d"")   if broker is not None:    params['broker'] = broker   self.__dict__[""_params""] = params   self.__dict__[""_symbol""] = symbol   self.__dict__[""_ranking_type""] = f""{ranking_type.lower()}_ranking""   self.__dict__[""_columns""] = [    ""datetime"",    ""symbol"",    ""exchange_id"",    ""instrument_id"",    ""broker"",    ""volume"",    ""volume_change"",    ""volume_ranking"",    ""long_oi"",    ""long_change"",    ""long_ranking"",    ""short_oi"",    ""short_change"",    ""short_ranking""   ]   super(TqSymbolRankingDataFrame, self).__init__(data=[], columns=self.__dict__[""_columns""])   self.__dict__[""_task""] = api.create_task(self.async_update(), _caller_api=True)  async def _get_ranking_data(self, ranking_id):   # 下载持仓排名数据，并将数据发回到 api.recv_chan   async with aiohttp.ClientSession(headers=self.__dict__[""_api""]._base_headers) as session:    url = ""https://symbol-ranking-system-fc-api.shinnytech.com/srs""    async with session.get(url, params=self.__dict__[""_params""]) as response:     response.raise_for_status()     content = await response.json()     await self.__dict__[""_api""]._ws_md_recv_chan.send({      ""aid"": ""rtn_data"",      ""data"": [{       ""_symbol_rankings"": {        ranking_id: content       },       ""_symbol_rankings_finished"": {        ranking_id: True       }      }]     })  async def async_update(self):   await self.__dict__[""_api""]._ensure_symbol_async(self.__dict__[""_symbol""])   ranking_id = _generate_uuid(""PYSDK_rank"")   self.__dict__[""_api""].create_task(self._get_ranking_data(ranking_id), _caller_api=True) # 错误会抛给 api 处理   symbol_rankings_finished = _get_obj(self.__dict__[""_api""]._data, [""_symbol_rankings_finished""])   async with self.__dict__[""_api""].register_update_notify(symbol_rankings_finished) as update_chan:    async for _ in update_chan:     if not symbol_rankings_finished.get(ranking_id, False):      continue     content = self.__dict__[""_api""]._data.get(""_symbol_rankings"", {}).get(ranking_id, {})     data = self._content_to_list(content)     for i, d in enumerate(data):      self.loc[i] = d     self.dropna(subset=[self.__dict__[""_ranking_type""]], inplace=True)     self.sort_values(by=['datetime', self.__dict__[""_ranking_type""]], inplace=True, ignore_index=True)     # 读完数据，清空数据     await self.__dict__[""_api""]._ws_md_recv_chan.send({      ""aid"": ""rtn_data"",      ""data"": [{       ""_symbol_rankings"": {        ranking_id: None       },       ""_symbol_rankings_finished"": {        ranking_id: None       }      }]     })     return self  def _content_to_list(self, content):   data = {}   for dt in content.keys():    for symbol in content[dt].keys():     if content[dt][symbol] is None:      continue     for data_type, rankings in content[dt][symbol].items():      for broker, rank_item in rankings.items():       item = data.setdefault((dt, symbol, broker), self._get_default_item(dt, symbol, broker))       if data_type == 'volume_ranking':        item['volume'] = rank_item['volume']        item['volume_change'] = rank_item['varvolume']        item['volume_ranking'] = rank_item['ranking']       elif data_type == 'long_ranking':        item['long_oi'] = rank_item['volume']        item['long_change'] = rank_item['varvolume']        item['long_ranking'] = rank_item['ranking']       elif data_type == 'short_ranking':        item['short_oi'] = rank_item['volume']        item['short_change'] = rank_item['varvolume']        item['short_ranking'] = rank_item['ranking']   return data.values()  def _get_default_item(self, dt, symbol, broker):   return {    ""datetime"": dt,    ""symbol"": symbol,    ""exchange_id"": symbol.split(""."", maxsplit=1)[0],    ""instrument_id"": symbol.split(""."", maxsplit=1)[1],    ""broker"": broker,    ""volume"": float('nan'),    ""volume_change"": float('nan'),    ""volume_ranking"": float('nan'),    ""long_oi"": float('nan'),    ""long_change"": float('nan'),    ""long_ranking"": float('nan'),    ""short_oi"": float('nan'),    ""short_change"": float('nan'),    ""short_ranking"": float('nan')   }  def __await__(self):   return self.__dict__[""_task""].__await__() class TqOptionGreeksDataFrame(DataFrame):  def __init__(self, api, symbol_list, v_list, r):   self.__dict__[""_api""] = api   self.__dict__[""_symbol_list""] = symbol_list   self.__dict__[""_v_list""] = v_list   self.__dict__[""_r""] = r   self.__dict__[""_columns""] = [    ""instrument_id"",    ""instrument_name"",    ""option_class"",    ""expire_rest_days"",    ""expire_datetime"",    ""underlying_symbol"",    ""strike_price"",    ""delta"",    ""gamma"",    ""theta"",    ""vega"",    ""rho""   ]   super(TqOptionGreeksDataFrame, self).__init__(data=[], columns=self.__dict__[""_columns""])   self.__dict__[""_task""] = api.create_task(self.async_update(), _caller_api=True)  async def async_update(self):   symbol_list = self.__dict__[""_symbol_list""]   quotes = await self.__dict__[""_api""].get_quote_list(symbol_list)   if not all([q.ins_class.endswith(""OPTION"") for q in quotes]):    raise Exception(""quote 参数列表中元素必须是期权类型"")   for i, q in enumerate(quotes):    self.loc[i] = {k: q.get(k, float('nan')) for k in self.__dict__[""_columns""]}   self._get_greeks(quotes)   return self  def _get_greeks(self, quotes):   series_close = Series(data=[q.last_price for q in quotes]) # 期权最新价   series_close1 = Series(data=[q.underlying_quote.last_price for q in quotes]) # 标的最新价   series_o = Series(data=[q.option_class for q in quotes])   series_datetime = Series(data=[_str_to_timestamp_nano(q.datetime) for q in quotes])   series_expire_datetime = Series(data=[q.expire_datetime for q in quotes])   series_t = _get_t_series(series_datetime, 0, series_expire_datetime) # 到期时间   if self.__dict__[""_v_list""] is None:    series_v = get_impv(series_close1, series_close, self[""strike_price""], self.__dict__[""_r""], 0.3, series_t, series_o)   else:    series_v = Series(data=self.__dict__[""_v_list""])   series_d1 = _get_d1(series_close1, self[""strike_price""], self.__dict__[""_r""], series_v, series_t)   self[""delta""] = get_delta(series_close1, self[""strike_price""], self.__dict__[""_r""], series_v, series_t, series_o, series_d1)   self[""theta""] = get_theta(series_close1, self[""strike_price""], self.__dict__[""_r""], series_v, series_t, series_o, series_d1)   self[""gamma""] = get_gamma(series_close1, self[""strike_price""], self.__dict__[""_r""], series_v, series_t, series_d1)   self[""vega""] = get_vega(series_close1, self[""strike_price""], self.__dict__[""_r""], series_v, series_t, series_d1)   self[""rho""] = get_rho(series_close1, self[""strike_price""], self.__dict__[""_r""], series_v, series_t, series_o, series_d1)  def __await__(self):   return self.__dict__[""_task""].__await__() "
94,n\tqsdk\rangese,"n\tqsdk\rangese. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'yanqiong' from typing import Tuple, List """""" Range 用来表示一个数据段，包含 start, end 之间的 int64 类型连续整数集合，包含 end - start - 1 个数据点 (左闭右开区间) 一个 Range 用元组来表示，例如: (0, 100), (8000, 10000) RangeSet 是一组有序的递增的 Range """""" Range = Tuple[int, int] RangeSet = List[Range] def _range_intersection(range1: Range, range2: Range) -> RangeSet:  # 两个 range 的交集  s1, e1 = range1  s2, e2 = range2  if s2 >= e1:   return []  elif s2 >= s1:   return [(s2, min(e1, e2))]  elif e2 <= s1:   return []  else:   return [(s1, min(e1, e2))] def _range_union(range1: Range, range2: Range) -> RangeSet:  # 两个 range 的并集  s1, e1 = range1  s2, e2 = range2  if s2 > e1:   return [(s1, e1), (s2, e2)]  elif s2 >= s1:   return [(s1, max(e1, e2))]  elif e2 < s1:   return [(s2, e2), (s1, e1)]  else:   return [(s2, max(e1, e2))] def _range_subtraction(range1: Range, range2: Range) -> RangeSet:  # 两个 range 的差集，在 range1 中但是不在 range2 中  s1, e1 = range1  s2, e2 = range2  if s2 >= e1:   return [(s1, e1)]  elif s2 > s1:   if e2 < e1:    return [(s1, s2), (e2, e1)]   else:    return [(s1, s2)]  elif e2 <= s1:   return [(s1, e1)]  elif e2 < e1:   return [(e2, e1)]  else:   return [] def _rangeset_length(rangeset: RangeSet) -> int:  """"""返回 rangeset 长度""""""  l = 0  for s, e in rangeset:   l += e - s  return l def _rangeset_head(rangeSet: RangeSet, n: int) -> RangeSet:  """"""  求出在集合 rangeSet 中, 头部 n 个元素  :return: RangeSet  """"""  r = []  for s, e in rangeSet:   if n <= 0:    break   if e - s <= n:    r.append((s, e))    n -= (e - s)   else:    r.append((s, s + n))    break  return r def _rangeset_slice(rangeset: RangeSet, start: int, end: int = None) -> RangeSet:  """"""  求出集合 rangeset 中, start ~ end 构成的 rangeset  ## 等价于 _rangeset_intersection(rangeset, [(start, end)])  rangeset 是一个列表，里面包含的元素格式为 [S1,E1] 表示一个数据段，其中每段包括S~E-1数据点(左闭右开区间)  任意两个数据段都不重叠且不连续  数据段总是从小到大排序  :param rangeset start: 时间1  :param rangeset end: 时间2，不填表示到 rangeset 的结尾  :return: rangeset，两个集合的交集  """"""  r = []  for s, e in rangeset:   if start >= e:    continue   if end and end <= s:    break   r.append((max(s, start), e if end is None else min(e, end)))  return r def _rangeset_intersection(rangeset_a: RangeSet, rangeset_b: RangeSet) -> RangeSet:  """"""  求既在集合 rangeset_a 中又在集合 rangeset_b 中的元素组成的 rangeset  rangeset_a - rangeset_b  :param rangeset rangeset_a:  :param rangeset rangeset_b:  :return: rangeset，两个集合的交集  """"""  if len(rangeset_a) == 0 or len(rangeset_b) == 0:   return []  r = []  index_a, index_b = 0, 0  while index_a < len(rangeset_a) and index_b < len(rangeset_b):   r_a = rangeset_a[index_a]   r_b = rangeset_b[index_b]   intersection = _range_intersection(r_a, r_b)   if intersection:    r += intersection   if r_a[1] <= r_b[1]:    index_a += 1   else:    index_b += 1  return r def _rangeset_difference(rangeset_a: RangeSet, rangeset_b: RangeSet) -> RangeSet:  """"""  求出在集合 rangeset_a 中但是不在集合 rangeset_b 中的元素组成的 rangeset  rangeset_a - rangeset_b  :param rangeset rangeset_a:  :param rangeset rangeset_b:  :return: rangeset，两个集合的差集  """"""  if len(rangeset_a) == 0 or len(rangeset_b) == 0:   return rangeset_a  intersetction = _rangeset_intersection(rangeset_a, rangeset_b) # rangeset_a 和 rangeset_b 的交集  # rangeset_a - intersetction 等价于 rangeset_a - rangeset_b，此时 intersetction 一定是 rangeset_a 的子集  if len(intersetction) == 0:   return rangeset_a  r = []  index_a, index_b = 0, 0  rangeset_a = rangeset_a.copy()  rangeset_b = intersetction # 此时 rangeset_b 一定是 rangeset_a 的子集  while index_a < len(rangeset_a):   r_a = rangeset_a[index_a]   r_b = rangeset_b[index_b] if index_b < len(rangeset_b) else rangeset_b[-1]   inter = _range_intersection(r_a, r_b)   if inter:    sub = _range_subtraction(r_a, r_b)    if len(sub) == 0:     index_a += 1    elif len(sub) == 1:     if sub[0][1] == inter[0][0]:      r.append(sub[0])      index_a += 1     else:      rangeset_a[index_a] = (inter[0][1], r_a[1])    else:     r.append(sub[0])     rangeset_a[index_a] = (inter[0][1], r_a[1])    index_b += 1   else:    r.append(r_a)    index_a += 1  return r def _rangeset_range_union(rangeset: RangeSet, other_range: Range) -> RangeSet:  # 将 other_range 并入 rangeset, 求交集  start_index = None  for i in range(len(rangeset)):   r = rangeset[i]   if other_range[0] <= r[1]:    start_index = i    break  if start_index is None:   return rangeset + [other_range]  union = rangeset[:start_index]  end = None  for i in range(start_index, len(rangeset)):   r = rangeset[i]   if other_range[1] < r[0]:    end = other_range[1]    break   elif r[0] <= other_range[1] <= r[1]:    end = r[1]    i += 1    break  start = min(other_range[0], rangeset[start_index][0])  if end:   union.append((start, end))   union += rangeset[i:]  else:   union.append((start, other_range[1]))  return union def _rangeset_union(rangeset_a: RangeSet, rangeset_b: RangeSet) -> RangeSet:  """"""  求既在集合 rangeset_a 中或者在集合 rangeset_b 中的元素组成的 rangeset  rangeset_a + rangeset_b  :param rangeset rangeset_a:  :param rangeset rangeset_b:  :return: rangeset，两个集合的并集  """"""  if len(rangeset_a) == 0:   return rangeset_b  if len(rangeset_b) == 0:   return rangeset_a  if rangeset_a == rangeset_b:   return rangeset_a  rangeset_union = rangeset_a.copy()  for r_b in rangeset_b: # 将 r 并入 rangeset_union   rangeset_union = _rangeset_range_union(rangeset_union, r_b)  return rangeset_union "
95,n\tqsdk\repor,"n\tqsdk\repor. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' from typing import Dict, Optional import numpy as np from pandas import DataFrame, Series from tqsdk.objs import Account, Trade, SecurityAccount, SecurityTrade from tqsdk.tafunc import get_sharp, get_sortino, get_calmar, _cum_counts TRADING_DAYS_OF_YEAR = 250 TRADING_DAYS_OF_MONTH = 21 class TqReport(object):  """"""  天勤报告类，辅助 web_gui 显示回测统计信息和统计图表  1. 目前只针对 TqSim 账户回测有意义  2. 每份报告针对一组对应的账户截面记录和成交记录  """"""  def __init__(self, report_id: str, trade_log: Optional[Dict] = None, quotes: Optional[Dict] = None, account_type: str = ""FUTURE""):   """"""   本模块为给 TqSim 提供交易成交统计   Args:    report_id (str): 报告Id    trade_log (dict): TqSim 交易结束之后生产的每日账户截面和交易记录     {      '2020-09-01': {       ""trades"": [],       ""account"": {},       ""positions"": {},      '2020-09-02': {....},     }    quotes (dict): 合约信息   Example::    TODO: 补充示例   """"""   self.report_id = report_id   self.trade_log = trade_log   self.quotes = quotes   self.account_type = account_type   self.date_keys = sorted(trade_log.keys())   self.account_df, self.trade_df = self._get_df()   # default metrics   self.default_metrics = self._get_default_metrics() if self.account_type == ""FUTURE"" else self._get_stock_metrics()  def _get_df(self):   type_account = Account if self.account_type == ""FUTURE"" else SecurityAccount   type_trade = Trade if self.account_type == ""FUTURE"" else SecurityTrade   account_data = [{'date': dt} for dt in self.date_keys]   for item in account_data:    item.update(self.trade_log[item['date']]['account'])   account_df = DataFrame(data=account_data, columns=['date'] + list(type_account(None).keys()))   trade_array = []   for date in self.date_keys:    trade_array.extend(self.trade_log[date]['trades'])   trade_df = DataFrame(data=trade_array, columns=list(type_trade(None).keys()))   if type_trade == Trade:    trade_df[""offset1""] = trade_df[""offset""].replace(""CLOSETODAY"", ""CLOSE"")   return account_df, trade_df  def _get_default_metrics(self):   if self.account_df.shape[0] > 0:    result = self._get_account_stat_metrics()    result.update(self._get_trades_stat_metrics())    return result   else:    return {     ""winning_rate"": float('nan'), # 胜率     ""profit_loss_ratio"": float('nan'), # 盈亏额比例     ""ror"": float('nan'), # 收益率     ""annual_yield"": float('nan'), # 年化收益率     ""max_drawdown"": float('nan'), # 最大回撤     ""sharpe_ratio"": float('nan'), # 年化夏普率     ""sortino_ratio"": float('nan'), # 年化索提诺比率     ""commission"": 0, # 总手续费     ""tqsdk_punchline"": """"    }  def _get_stock_metrics(self):   if self.account_df.shape[0] > 0:    init_asset = self.account_df.iloc[0]['asset_his']    asset = self.account_df.iloc[-1]['asset']    self.account_df['profit'] = self.account_df['asset'] - self.account_df['asset'].shift(fill_value=init_asset) # 每日收益    self.account_df['is_profit'] = np.where(self.account_df['profit'] > 0, 1, 0) # 是否收益    self.account_df['is_loss'] = np.where(self.account_df['profit'] < 0, 1, 0) # 是否亏损    self.account_df['daily_yield'] = self.account_df['asset'] / self.account_df['asset'].shift(fill_value=init_asset) - 1 # 每日收益率    self.account_df['max_asset'] = self.account_df['asset'].cummax() # 当前单日最大权益    self.account_df['drawdown'] = (self.account_df['max_asset'] - self.account_df['asset']) / self.account_df['max_asset'] # 回撤    _ror = asset / init_asset    return {     ""start_date"": self.account_df.iloc[0][""date""],     ""end_date"": self.account_df.iloc[-1][""date""],     ""init_asset"": init_asset,     ""asset"": init_asset,     ""start_asset"": init_asset,     ""end_asset"": asset,     ""ror"": _ror - 1, # 收益率     ""annual_yield"": _ror ** (TRADING_DAYS_OF_YEAR / self.account_df.shape[0]) - 1, # 年化收益率     ""trading_days"": self.account_df.shape[0], # 总交易天数     ""cum_profit_days"": self.account_df['is_profit'].sum(), # 累计盈利天数     ""cum_loss_days"": self.account_df['is_loss'].sum(), # 累计亏损天数     ""max_drawdown"": self.account_df['drawdown'].max(), # 最大回撤     ""fee"": self.account_df['buy_fee_today'].sum() + self.account_df['sell_fee_today'].sum(), # 总手续费     ""buy_times"": self.trade_df.loc[self.trade_df[""direction""] == ""BUY""].shape[0], # 买次数     ""sell_times"": self.trade_df.loc[self.trade_df[""direction""] == ""SELL""].shape[0], # 卖次数     ""max_cont_profit_days"": _cum_counts(self.account_df['is_profit']).max(), # 最大连续盈利天数     ""max_cont_loss_days"": _cum_counts(self.account_df['is_loss']).max(), # 最大连续亏损天数     ""sharpe_ratio"": get_sharp(self.account_df['daily_yield']), # 年化夏普率     ""calmar_ratio"": get_calmar(self.account_df['daily_yield'], self.account_df['drawdown'].max()), # 年化卡玛比率     ""sortino_ratio"": get_sortino(self.account_df['daily_yield']), # 年化索提诺比率     ""tqsdk_punchline"": self._get_tqsdk_punchlines(_ror - 1)    }   else:    return {     ""profit_loss_ratio"": float('nan'), # 盈亏额比例     ""ror"": float('nan'), # 收益率     ""annual_yield"": float('nan'), # 年化收益率     ""max_drawdown"": float('nan'), # 最大回撤     ""sharpe_ratio"": float('nan'), # 年化夏普率     ""sortino_ratio"": float('nan'), # 年化索提诺比率     ""fee"": 0, # 总手续费     ""tqsdk_punchline"": """"    }  def _get_account_stat_metrics(self):   init_balance = self.account_df.iloc[0]['pre_balance']   balance = self.account_df.iloc[-1]['balance']   self.account_df['profit'] = self.account_df['balance'] - self.account_df['balance'].shift(fill_value=init_balance) # 每日收益   self.account_df['is_profit'] = np.where(self.account_df['profit'] > 0, 1, 0) # 是否收益   self.account_df['is_loss'] = np.where(self.account_df['profit'] < 0, 1, 0) # 是否亏损   self.account_df['daily_yield'] = self.account_df['balance'] / self.account_df['balance'].shift(fill_value=init_balance) - 1 # 每日收益率   self.account_df['max_balance'] = self.account_df['balance'].cummax() # 当前单日最大权益   self.account_df['drawdown'] = (self.account_df['max_balance'] - self.account_df['balance']) / self.account_df['max_balance'] # 回撤   _ror = self.account_df.iloc[-1]['balance'] / self.account_df.iloc[0]['pre_balance']   return {    ""start_date"": self.account_df.iloc[0][""date""],    ""end_date"": self.account_df.iloc[-1][""date""],    ""init_balance"": init_balance,    ""balance"": balance,    ""start_balance"": init_balance,    ""end_balance"": balance,    ""ror"": _ror - 1, # 收益率    ""annual_yield"": _ror ** (TRADING_DAYS_OF_YEAR / self.account_df.shape[0]) - 1, # 年化收益率    ""trading_days"": self.account_df.shape[0], # 总交易天数    ""cum_profit_days"": self.account_df['is_profit'].sum(), # 累计盈利天数    ""cum_loss_days"": self.account_df['is_loss'].sum(), # 累计亏损天数    ""max_drawdown"": self.account_df['drawdown'].max(), # 最大回撤    ""commission"": self.account_df['commission'].sum(), # 总手续费    ""open_times"": self.trade_df.loc[self.trade_df[""offset1""] == ""OPEN""].shape[0], # 开仓次数    ""close_times"": self.trade_df.loc[self.trade_df[""offset1""] == ""CLOSE""].shape[0], # 平仓次数    ""daily_risk_ratio"": self.account_df['risk_ratio'].mean(), # 提供日均风险度    ""max_cont_profit_days"": _cum_counts(self.account_df['is_profit']).max(), # 最大连续盈利天数    ""max_cont_loss_days"": _cum_counts(self.account_df['is_loss']).max(), # 最大连续亏损天数    ""sharpe_ratio"": get_sharp(self.account_df['daily_yield']), # 年化夏普率    ""calmar_ratio"": get_calmar(self.account_df['daily_yield'], self.account_df['drawdown'].max()), # 年化卡玛比率    ""sortino_ratio"": get_sortino(self.account_df['daily_yield']), # 年化索提诺比率    ""tqsdk_punchline"": self._get_tqsdk_punchlines(_ror - 1)   }  def _get_trades_stat_metrics(self):   """"""   根据成交手数计算 胜率，盈亏额比例   self.quotes 主要需要合约乘数，用于计算盈亏额   """"""   trade_array = []   for date in self.date_keys:    for trade in self.trade_log[date]['trades']:     # 每一行都是 1 手的成交记录     trade_array.extend([{      ""symbol"": f""{trade['exchange_id']}.{trade['instrument_id']}"",      ""direction"": trade[""direction""],      ""offset"": ""CLOSE"" if trade[""offset""] == ""CLOSETODAY"" else trade[""offset""],      ""price"": trade[""price""]     } for i in range(trade['volume'])])   trade_df = DataFrame(data=trade_array, columns=['symbol', 'direction', 'offset', 'price'])   profit_volumes = 0 # 盈利手数   loss_volumes = 0 # 亏损手数   profit_value = 0 # 盈利额   loss_value = 0 # 亏损额   all_symbols = trade_df['symbol'].drop_duplicates()   for symbol in all_symbols:    for direction in [""BUY"", ""SELL""]:     open_df = self._get_sub_df(trade_df, symbol, dir=direction, offset='OPEN')     close_df = self._get_sub_df(trade_df, symbol, dir=(""SELL"" if direction == ""BUY"" else ""BUY""), offset='CLOSE')     close_df['profit'] = (close_df['price'] - open_df['price']) * (1 if direction == ""BUY"" else -1)     profit_volumes += close_df.loc[close_df['profit'] >= 0].shape[0] # 盈利手数     loss_volumes += close_df.loc[close_df['profit'] < 0].shape[0] # 亏损手数     profit_value += close_df.loc[close_df['profit'] >= 0, 'profit'].sum() * self.quotes[symbol]['volume_multiple']     loss_value += close_df.loc[close_df['profit'] < 0, 'profit'].sum() * self.quotes[symbol]['volume_multiple']   winning_rate = profit_volumes / (profit_volumes + loss_volumes) if profit_volumes + loss_volumes else 0   profit_pre_volume = profit_value / profit_volumes if profit_volumes else 0   loss_pre_volume = loss_value / loss_volumes if loss_volumes else 0   profit_loss_ratio = abs(profit_pre_volume / loss_pre_volume) if loss_pre_volume else float(""inf"")   return {    ""profit_volumes"": profit_volumes,    ""loss_volumes"": loss_volumes,    ""profit_value"": profit_value,    ""loss_value"": loss_value,    ""winning_rate"": winning_rate,    ""profit_loss_ratio"": profit_loss_ratio   }  def _get_tqsdk_punchlines(self, ror):   tqsdk_punchlines = [    '幸好是模拟账户，不然你就亏完啦',    '触底反弹,与其执迷修改参数，不如改变策略思路去天勤官网策略库进修',    '越挫越勇，不如去天勤量化官网策略库进修',    '不要灰心，少侠重新来过',    '策略看来小有所成',    '策略看来的得心应手',    '策略看来春风得意，堪比当代索罗斯',    '策略看来独孤求败，小心过拟合噢'   ]   ror_level = [i for i, k in enumerate([-1, -0.5, -0.2, 0, 0.2, 0.5, 1]) if ror < k]   if len(ror_level) > 0:    return tqsdk_punchlines[ror_level[0]]   else:    return tqsdk_punchlines[-1]  def _get_sub_df(self, origin_df, symbol, dir, offset):   df = origin_df.where(    (origin_df['symbol'] == symbol) & (origin_df['offset'] == offset) & (origin_df['direction'] == dir))   df.dropna(inplace=True)   df.reset_index(drop=True, inplace=True)   return df  def metrics(self, **kwargs):   self.default_metrics.update(kwargs)   return [{    self.report_id: {""metrics"": self.default_metrics.copy()}   }]  def full(self):   data = self.metrics()   data += self.daily_balance()   data += self.daily_profit()   data += self.drawdown()   data += self.sharp_rolling()   data += self.sortino_rolling()   # data += self.calmar_rolling()   return data  def daily_balance(self):   """"""每日资金曲线""""""   return [{    self.report_id: {     ""charts"": {      ""daily_balance"": {       ""title"": {        ""left"": 'center',        ""text"": ""每日账户资金""       },       ""xAxis"": {        ""type"": 'category',        ""data"": self.account_df['date'].to_dict()       },       ""yAxis"": {        ""type"": 'value',        ""min"": 'dataMin',        ""max"": 'dataMax',       },       ""series"": {        ""0"": {         ""data"": self.account_df['balance'].map(lambda x: '%.2f' % x).to_dict(),         ""type"": 'line'        }       }      }     }    }   }]  def daily_profit(self):   """"""每日盈亏""""""   profit = Series(np.where(self.account_df['profit'] >= 0, self.account_df['profit'], float('nan'))) # 收益   loss = Series(np.where(self.account_df['profit'] < 0, self.account_df['profit'], float('nan'))) # 亏损   return [{    self.report_id: {     ""charts"": {      ""daily_profit"": {       ""title"": {        ""left"": 'center',        ""text"": ""每日盈亏""       },       ""xAxis"": {        ""type"": 'category',        ""data"": self.account_df['date'].to_dict()       },       ""yAxis"": {        ""type"": 'value'       },       ""series"": {        ""0"": {         ""data"": profit.to_dict(),         ""type"": 'bar',         ""itemStyle"": {          ""color"": ""#ee6666""         },         ""stack"": 'one',        },        ""1"": {         ""data"": loss.to_dict(),         ""type"": 'bar',         ""itemStyle"": {          ""color"": ""#91cc75""         },         ""stack"": 'one',        }       }      }     }    }   }]  def drawdown(self):   """"""回撤""""""   return [{    self.report_id: {     ""charts"": {      ""drawdown"": {       ""title"": {        ""left"": 'center',        ""text"": ""回撤""       },       ""xAxis"": {        ""type"": 'category',        ""data"": self.account_df['date'].to_dict()       },       ""yAxis"": {        ""type"": 'value'       },       ""series"": {        ""0"": {         ""data"": self.account_df['drawdown'].to_dict(),         ""type"": 'line'        }       }      }     }    }   }]  def sharp_rolling(self):   """"""滚动夏普比率图表""""""   rolling_sharp = self.account_df['daily_yield'].rolling(TRADING_DAYS_OF_MONTH).apply(get_sharp)   return [{    self.report_id: {     ""charts"": {      ""sharp_rolling"": {       ""title"": {        ""left"": 'center',        ""text"": ""滚动夏普比率图表""       },       ""xAxis"": {        ""type"": 'category',        ""data"": self.account_df['date'].to_dict()       },       ""yAxis"": {        ""type"": 'value'       },       ""series"": {        ""0"": {         ""data"": rolling_sharp.to_dict(),         ""type"": 'line'        }       }      }     }    }   }]  def sortino_rolling(self):   """"""滚动索提诺比率图表""""""   rolling_sortino = self.account_df['daily_yield'].rolling(TRADING_DAYS_OF_MONTH).apply(get_sortino)   return [{    self.report_id: {     ""charts"": {      ""sortino_rolling"": {       ""title"": {        ""left"": 'center',        ""text"": ""滚动索提诺比率图表""       },       ""xAxis"": {        ""type"": 'category',        ""data"": self.account_df['date'].to_dict()       },       ""yAxis"": {        ""type"": 'value'       },       ""series"": {        ""0"": {         ""name"": ""滚动索提诺比率图表"",         ""data"": rolling_sortino.to_dict(),         ""type"": 'line'        }       }      }     }    }   }]  def calmar_rolling(self):   """"""滚动卡玛比率图表""""""   rolling_calmar = self.account_df['daily_yield'].rolling(TRADING_DAYS_OF_MONTH).apply(    lambda x: get_calmar(x, self.account_df.loc[x.index]['drawdown'].max()))   return [{    self.report_id: {     ""charts"": {      ""calmar_rolling"": {       ""title"": {        ""left"": 'center',        ""text"": ""滚动卡玛比率图表""       },       ""xAxis"": {        ""type"": 'category',        ""data"": self.account_df['date'].to_dict()       },       ""yAxis"": {        ""type"": 'value'       },       ""series"": {        ""0"": {         ""data"": rolling_calmar.to_dict(),         ""type"": 'line'        },       }      }     }    }   }] "
96,n\tqsdk\risk manage,"n\tqsdk\risk manage. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' from tqsdk.datetime import _get_trading_day_from_timestamp, _get_trading_day_end_time from tqsdk.datetime_state import TqDatetimeState from tqsdk.exceptions import TqRiskRuleError class TqRiskManager(list):  def __init__(self):   self._datetime_state = TqDatetimeState()   self._trading_day_end = 0   super(TqRiskManager, self).__init__()  def _on_recv_data(self, diffs):   for d in diffs:    self._datetime_state.update_state(d)   current = self._datetime_state.get_current_dt()   if current > self._trading_day_end:    # 切换交易日    self._trading_day_end = _get_trading_day_end_time(_get_trading_day_from_timestamp(current))    [r._on_settle() for r in self]  def append(self, rule):   if rule not in self:    super(TqRiskManager, self).append(rule)  def remove(self, rule):   if rule in self:    super(TqRiskManager, self).remove(rule)  def _could_insert_order(self, pack):   # 是否可以下单   for r in self:    is_valid, err_msg = r._could_insert_order(pack)    if not is_valid:     raise TqRiskRuleError(err_msg)   return True  def _on_insert_order(self, pack):   # 需要更新风控对象内部统计值   for r in self:    r._on_insert_order(pack) "
97,n\tqsdk\risk rul,"n\tqsdk\risk rul. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' from abc import abstractmethod class TqRiskRule(object):  def __init__(self, api, account=None):   # 记录必要参数， 每个风控规则都需要继承这个基类   self._api = api   account = self._api._account._check_valid(account)   if account is None:    raise Exception(f""多账户模式下, 需要指定账户实例 account"")   self._account = account   self._account_key = self._account._account_key  @abstractmethod  def _could_insert_order(self, pack) -> (bool, str): # 是否可以下单   pass  @abstractmethod  def _on_insert_order(self, pack):   pass  @abstractmethod  def _on_settle(self):   pass class TqRuleOpenCountsLimit(TqRiskRule):  """"""  风控规则类 - 交易日内开仓次数限制。  此功能为 TqSdk 专业版提供，如需使用此功能，可以点击 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_ 申请试用或购买  """"""  def __init__(self, api, open_counts_limit, symbol, account=None):   """"""   Args:    api (TqApi): TqApi 实例    open_volumes_limit (int): 交易日内开仓手数上限    symbol (str/list of str): 负责限制的合约代码或合约代码列表.     * str: 一个合约代码     * list of str: 合约代码列表    account (TqAccount/TqKq/TqSim): [可选] 指定发送下单指令的账户实例, 多账户模式下，该参数必须指定   Example1::    from tqsdk import TqApi    from tqsdk.risk_rule import TqRuleOpenCountsLimit    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    rule = TqRuleOpenCountsLimit(api, open_counts_limit=10, symbol=""DCE.m2112"") # 创建风控规则实例    api.add_risk_rule(rule) # 添加风控规则    quote = api.get_quote(""DCE.m2112"")    try:     # 每次最新价变动，下一笔订单，直到超过开仓次数风控限制     while True:      api.wait_update()      if api.is_changing(quote, ['last_price']):       order = api.insert_order(symbol=""DCE.m2112"", direction=""BUY"", offset=""OPEN"", volume=1)       while order.status != ""FINISHED"":        api.wait_update()    except TqRiskRuleError as e:     print('!!!', e)    api.close()   """"""   super(TqRuleOpenCountsLimit, self).__init__(api=api, account=account)   if open_counts_limit < 0:    raise Exception(""参数 open_volumes_limit 必须大于 0 的数字"")   self.open_counts_limit = open_counts_limit   self.symbol_list = [symbol] if isinstance(symbol, str) else symbol   self.data = {s: 0 for s in self.symbol_list}   for order_id, order in self._api._data.get('trade', {}).get(self._account_key, {}).get('orders', {}).items():    symbol = order[""exchange_id""] + ""."" + order[""instrument_id""]    if order[""offset""] == ""OPEN"" and symbol in self.data:     self.data[symbol] += 1  def _could_insert_order(self, pack) -> {bool, str}:   if pack['account_key'] == self._account_key:    symbol = pack[""exchange_id""] + ""."" + pack[""instrument_id""]    if pack[""offset""] == ""OPEN"" and symbol in self.symbol_list:     if self.data[symbol] + 1 > self.open_counts_limit:      return False, f""触发风控规则，合约 {symbol} 开仓到达交易日内开仓次数限制 {self.open_counts_limit}, "" \         f""已下单次数 {self.data[symbol]}""   return True, """"  def _on_insert_order(self, pack):   if pack['account_key'] == self._account_key:    symbol = pack[""exchange_id""] + ""."" + pack[""instrument_id""]    if pack[""offset""] == ""OPEN"" and symbol in self.symbol_list:     self.data[symbol] += 1  def _on_settle(self):   for k in self.data.keys():    self.data[k] = 0 class TqRuleOpenVolumesLimit(TqRiskRule):  """"""  风控规则类 - 交易日内开仓手数限制  此功能为 TqSdk 专业版提供，如需使用此功能，可以点击 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_ 申请试用或购买  """"""  def __init__(self, api, open_volumes_limit, symbol, account=None):   """"""   Args:    api (TqApi): TqApi 实例    open_volumes_limit (int): 交易日内开仓手数上限    symbol (str/list of str): 负责限制的合约代码或合约代码列表.     * str: 一个合约代码     * list of str: 合约代码列表    account (TqAccount/TqKq/TqSim): [可选] 指定发送下单指令的账户实例, 多账户模式下，该参数必须指定   Example1::    from tqsdk import TqApi    from tqsdk.risk_rule import TqRuleOpenVolumesLimit    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    rule = TqRuleOpenVolumesLimit(api, open_volumes_limit=10, symbol=""DCE.m2112"") # 创建风控规则实例    api.add_risk_rule(rule) # 添加风控规则    # 下单 5 手，不会触发风控规则    order1 = api.insert_order(symbol=""DCE.m2112"", direction=""BUY"", offset=""OPEN"", volume=5)    while order1.status != ""FINISHED"":     api.wait_update()    # 继续下单 8 手，会触发风控规则    order2 = api.insert_order(symbol=""DCE.m2112"", direction=""BUY"", offset=""OPEN"", volume=8)    while order2.status != ""FINISHED"":     api.wait_update()    api.close()   Example2::    from tqsdk import TqApi, TqKq, TqRiskRuleError    from tqsdk.risk_rule import TqRuleOpenVolumesLimit    account = TqKq()    api = TqApi(account=account, auth=TqAuth(""信易账户"", ""账户密码""))    rule = TqRuleOpenVolumesLimit(api, open_volumes_limit=10, symbol=""DCE.m2112"", account=account) # 创建风控规则实例    api.add_risk_rule(rule) # 添加风控规则    try:     # 下单 11 手，触发风控规则     order1 = api.insert_order(symbol=""DCE.m2112"", direction=""BUY"", offset=""OPEN"", volume=11)     while order1.status != ""FINISHED"":      api.wait_update()    except TqRiskRuleError as e:     print(""!!!"", e)    api.close()   """"""   super(TqRuleOpenVolumesLimit, self).__init__(api=api, account=account)   if open_volumes_limit < 0:    raise Exception(""参数 open_volumes_limit 必须大于 0 的数字"")   self.open_volumes_limit = open_volumes_limit   self.symbol_list = [symbol] if isinstance(symbol, str) else symbol   self.data = {s: 0 for s in self.symbol_list}   for trade_id, trade in self._api._data.get('trade', {}).get(self._account_key, {}).get('trades', {}).items():    symbol = trade[""exchange_id""] + ""."" + trade[""instrument_id""]    if trade[""offset""] == ""OPEN"" and symbol in self.data:     self.data[symbol] += trade[""volume""]  def _could_insert_order(self, pack) -> {bool, str}:   if pack['account_key'] == self._account_key:    symbol = pack[""exchange_id""] + ""."" + pack[""instrument_id""]    if pack[""offset""] == ""OPEN"" and symbol in self.symbol_list:     if self.data[symbol] + pack[""volume""] > self.open_volumes_limit:      return False, f""触发风控规则，合约 {symbol} 开仓到达交易日内开仓手数限制 {self.open_volumes_limit}, "" \         f""已下单手数 {self.data[symbol]}, 即将下单手数 {pack['volume']}""   return True, """"  def _on_insert_order(self, pack):   if pack['account_key'] == self._account_key:    symbol = pack[""exchange_id""] + ""."" + pack[""instrument_id""]    if pack[""offset""] == ""OPEN"" and symbol in self.symbol_list:     self.data[symbol] += pack[""volume""]  def _on_settle(self):   for k in self.data.keys():    self.data[k] = 0 class TqRuleAccOpenVolumesLimit(TqRiskRule):  """"""  风控规则类 - 累计开仓手数限制。  限制合约开仓手数之和。  此功能为 TqSdk 专业版提供，如需使用此功能，可以点击 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_ 申请试用或购买  """"""  def __init__(self, api, open_volumes_limit, symbol, account=None):   """"""   Args:    api (TqApi): TqApi 实例    open_volumes_limit (int): 交易日内开仓手数之和上限    symbol (str/list of str): 负责限制的合约代码或合约代码列表.     * str: 一个合约代码     * list of str: 合约代码列表    account (TqAccount/TqKq/TqSim): [可选] 指定发送下单指令的账户实例, 多账户模式下，该参数必须指定   Example::    from tqsdk import TqApi, TqKq, TqRiskRuleError    from tqsdk.risk_rule import TqRuleAccOpenVolumesLimit    account = TqKq()    api = TqApi(account=account, auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SSE.000300"")    call_in, call_at, call_out = api.query_all_level_finance_options(""SSE.000300"", quote.last_price, ""CALL"", nearbys=0)    put_in, put_at, put_out = api.query_all_level_finance_options(""SSE.000300"", quote.last_price, ""PUT"", nearbys=0)    near_symbols = call_in + call_at + call_out + put_in + put_at + put_out # 找到所有当月期权合约    symbols = api.query_options(""SSE.000300"", expired=False) # 找到所有中金所期权合约    # 规则1: 中金所当月期权合约日内开仓不超过 100 手    # 规则2: 中金所所有期权合约日内合约开仓不超过 200 手    rule1 = TqRuleAccOpenVolumesLimit(api, open_volumes_limit=100, symbol=near_symbols, account=account) # 创建风控规则实例    rule2 = TqRuleAccOpenVolumesLimit(api, open_volumes_limit=200, symbol=symbols, account=account) # 创建风控规则实例    api.add_risk_rule(rule1) # 添加风控规则    api.add_risk_rule(rule2) # 添加风控规则    try:     # 下单 101 手，触发风控规则     order1 = api.insert_order(symbol=""CFFEX.IO2111-C-4900"", direction=""BUY"", offset=""OPEN"", volume=101, limit_price=35.6)     while order1.status != ""FINISHED"":      api.wait_update()    except TqRiskRuleError as e:     print(""!!!"", e) # 报错，当月期权合约日内合约开仓不超过 100 手, 已下单次数 0    api.close()   """"""   super(TqRuleAccOpenVolumesLimit, self).__init__(api=api, account=account)   if open_volumes_limit < 0:    raise Exception(""参数 open_volumes_limit 必须大于 0 的数字"")   self.open_volumes_limit = open_volumes_limit   self.open_volumes = 0 # 所有合约日内合约开仓手数   self.symbol_list = [symbol] if isinstance(symbol, str) else symbol   for trade_id, trade in self._api._data.get('trade', {}).get(self._account_key, {}).get('trades', {}).items():    if trade[""offset""] == ""OPEN"" and f'{trade[""exchange_id""]}.{trade[""instrument_id""]}' in self.symbol_list:     self.open_volumes += trade['volume']  def _could_insert_order(self, pack) -> {bool, str}:   symbol = pack[""exchange_id""] + ""."" + pack[""instrument_id""]   if pack['account_key'] == self._account_key and symbol in self.symbol_list: # 当前账户下单    if pack[""offset""] == ""OPEN"" and self.open_volumes + pack['volume'] > self.open_volumes_limit:     return False, f""触发风控规则，所有合约日内合约开仓不超过 {self.open_volumes_limit} 手, 已下单手数 {self.open_volumes}""   return True, """"  def _on_insert_order(self, pack):   symbol = pack[""exchange_id""] + ""."" + pack[""instrument_id""]   if pack['account_key'] == self._account_key and symbol in self.symbol_list: # 当前账户下单    if pack[""offset""] == ""OPEN"": # 开仓单把手数累加     self.open_volumes += pack['volume']  def _on_settle(self):   self.open_volumes = 0 "
98,n\tqsdk\stockprofi,"n\tqsdk\stockprofi. #!/usr/bin/env python # -*- coding: utf-8 -*- import math from tqsdk.entity import Entity from tqsdk.diff import _simple_merge_diff, _get_obj class TqStockProfit():  """"""  股票盈亏计算模块  * 订阅已有持仓股票合约和行情  * 计算股票持仓与资产的盈亏  """"""  def __init__(self, api):   self._api = api   self._data = Entity() # 业务信息截面   self._data._instance_entity([])   self._diffs = []   self._all_subscribe = set()  async def _run(self, api_send_chan, api_recv_chan, md_send_chan, md_recv_chan):   self._logger = self._api._logger.getChild(""TqStockProfit"")   self._api_send_chan = api_send_chan   self._api_recv_chan = api_recv_chan   self._md_send_chan = md_send_chan   self._md_recv_chan = md_recv_chan   md_task = self._api.create_task(self._md_handler())   self._pending_peek = False   try:    async for pack in api_send_chan:     if ""_md_recv"" in pack:      await self._md_recv(pack)      await self._send_diff()      if not self._is_diff_complete():       await self._md_send_chan.send({""aid"": ""peek_message""})     elif pack[""aid""] == ""subscribe_quote"":      await self._subscribe_quote(set(pack[""ins_list""].split("","")))     elif pack[""aid""] == ""peek_message"":      self._pending_peek = True      await self._send_diff()      if self._pending_peek:       await self._md_send_chan.send(pack)     else:      await self._md_send_chan.send(pack)   finally:    md_task.cancel()  async def _md_handler(self):   """"""0 接收上游数据包 """"""   async for pack in self._md_recv_chan:    pack[""_md_recv""] = True    await self._api_send_chan.send(pack)  async def _md_recv(self, pack):   """""" 处理下行数据包   0 将行情数据和交易数据合并至 self._data   1 生成增量业务截面, 该截面包含 持仓盈亏和资产盈亏信息   """"""   for d in pack.get(""data"", {}):    if ""quotes"" in d:     # 行情数据仅仅合并沪深两市的行情数据     stock_quote = {k: v for k, v in d.get('quotes').items() if k.startswith(""SSE"") or k.startswith(""SZSE"")}     _simple_merge_diff(self._data, {""quotes"": stock_quote})    if ""trade"" in d:     _simple_merge_diff(self._data, d)    # 添加至 self._diff 等待被发送    self._diffs.append(d)   # 计算持仓和账户资产的盈亏增量截面   pend_diff = await self._generate_pend_diff()   self._diffs.append(pend_diff)  async def _generate_pend_diff(self):   """""""" 盈亏计算 """"""   pend_diff = {}   pend_diff.setdefault('trade', {k: {'accounts': {'CNY': {}}, 'positions': {}} for k in self._data.get('trade', {})})   # 计算持仓盈亏   for account_key in self._data.get('trade', {}):    # 盈亏计算仅仅计算股票账户    if self._data['trade'].get(account_key, {}).get(""account_type"", ""FUTURE"") == ""FUTURE"":     continue    for symbol, _ in self._data['trade'][account_key].get('positions', {}).items():     await self._subscribe_quote(symbol)     last_price = self._data[""quotes""].get(symbol, {}).get('last_price', float(""nan""))     if not math.isnan(last_price):      diff = self._update_position(account_key, symbol, last_price)      pend_diff['trade'][account_key]['positions'][symbol] = diff      _simple_merge_diff(self._data[""trade""][account_key][""positions""], {symbol: diff})   # 当截面完整时, 全量刷新所有账户的资产盈亏   if self._is_diff_complete():    for account_key in self._data.get('trade', {}):     if self._data['trade'].get(account_key, {}).get(""account_type"", ""FUTURE"") == ""FUTURE"":      continue     all_position =self._data[""trade""][account_key].get(""positions"", {})     pend_diff['trade'][account_key]['accounts']['CNY']['float_profit'] = \      sum([v.get('float_profit', 0) for k, v in all_position.items()])   return pend_diff  async def _send_diff(self):   if self._pending_peek and self._is_diff_complete() and self._diffs:    rtn_data = {     ""aid"": ""rtn_data"",     ""data"": self._diffs,    }    self._diffs = []    self._pending_peek = False    await self._api_recv_chan.send(rtn_data)  async def _subscribe_quote(self, symbols: [set, str]):   """"""这里只会增加订阅合约，不会退订合约""""""   symbols = symbols if isinstance(symbols, set) else {symbols}   if symbols - self._all_subscribe:    self._all_subscribe |= symbols    await self._md_send_chan.send({     ""aid"": ""subscribe_quote"",     ""ins_list"": "","".join(self._all_subscribe)    })  def _update_position(self, key, symbol, last_price):   """"""更新持仓盈亏""""""   diff = {}   position = self._data[""trade""][key][""positions""][symbol]   diff[""last_price""] = last_price   diff[""cost""] = position['cost_price'] * position['volume']   diff[""float_profit""] = (last_price - position['cost_price']) * position['volume']   return diff  def _is_diff_complete(self):   """"""当前账户截面是否已经完全处理完整, 即当所有股票的最新价不为空时""""""   for account_key in self._data.get('trade', {}):    for symbol, _ in self._data['trade'][account_key].get('positions', {}).items():     quote = self._data[""quotes""].get(symbol, {})     if math.isnan(quote.get('last_price', float(""nan""))):      return False   return True "
99,n\tqsdk\symbol,"n\tqsdk\symbol. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' import asyncio from tqsdk.objs import Quote class TqSymbols(object):  """"""  天勤合约服务类  """"""  async def _run(self, api, sim_send_chan, sim_recv_chan, md_send_chan, md_recv_chan):   """"""回测task""""""   self._api = api   self._sim_send_chan = sim_send_chan   self._sim_recv_chan = sim_recv_chan   self._md_send_chan = md_send_chan   self._md_recv_chan = md_recv_chan   self._etf_options = set()   self._quotes_all_keys = set(Quote(None).keys())   self._quotes_all_keys = self._quotes_all_keys.union({'margin', 'commission'})   # 以下字段合约服务也会请求，但是不应该记在 quotes 中，quotes 中的这些字段应该有行情服务负责   self._quotes_all_keys.difference_update({'pre_open_interest', 'pre_close', 'upper_limit', 'lower_limit'})   sim_task = self._api.create_task(self._sim_handler())   try:    async for pack in self._md_recv_chan:     if pack.get(""aid"") == ""rtn_data"":      data = pack.setdefault(""data"", [])      # 对于收到的数据，全部转发给下游      # 对于合约服务信息，query_id 为 PYSDK_quote_xxx 开头的，一定是请求了合约的全部合约信息，需要转为 quotes 转发给下游      updated_quotes = {} # 合约服务内容转为的 quotes 对象      # 分两次循环，第一次循环找到所有的 SSE 期权，第二次循环将从行情收到的 SSE 期权的 pre_settlement 删掉      # 最终将 updated_quotes 发送给下游      for d in data:       for query_id, query_result in d.get(""symbols"", {}).items():        if query_result:         if query_result.get(""error"", None):          raise Exception(f""查询合约服务报错 {query_result['error']}"")         elif query_id.startswith(""PYSDK_quote""):          quotes = self._api._symbols_to_quotes(query_result, self._quotes_all_keys)          for quote in quotes.values():           if quote[""ins_class""] == ""OPTION"" and quote[""exchange_id""] in [""SSE"", ""SZSE""]:            self._etf_options.add(quote[""instrument_id""])           else:            # quotes 中的 pre_settlement 字段应该由行情服务负责，行情没有上交所期权的 pre_settlement，需要从合约服务取，其他合约不变            quote.pop(""pre_settlement"", None)          updated_quotes.update(quotes)          self._md_send_chan.send_nowait({           ""aid"": ""ins_query"",           ""query_id"": query_id,           ""query"": """"          })      for d in data:       for symbol, quote in d.get(""quotes"", {}).items():        if symbol in self._etf_options:         quote.pop(""pre_settlement"", None)      data.append({""quotes"": updated_quotes})     await self._sim_recv_chan.send(pack)   finally:    sim_task.cancel()    await asyncio.gather(sim_task, return_exceptions=True)  async def _sim_handler(self):   # 下游发来的数据包，直接转发到上游   async for pack in self._sim_send_chan:    await self._md_send_chan.send(pack) "
100,n\tqsdk\t,"n\tqsdk\t. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' """""" tqsdk.ta 模块包含了一批常用的技术指标计算函数 (函数返回值类型保持为 pandas.Dataframe) """""" import math import numpy as np import pandas as pd import tqsdk.tafunc def ATR(df, n):  """"""  平均真实波幅  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 平均真实波幅的周期  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 分别是""tr""和""atr"", 分别代表真实波幅和平均真实波幅  Example::   # 获取 CFFEX.IF1903 合约的平均真实波幅   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import ATR   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   atr = ATR(klines, 14)   print(atr.tr) # 真实波幅   print(atr.atr) # 平均真实波幅   # 预计的输出是这样的:   [..., 143.0, 48.0, 80.0, ...]   [..., 95.20000000000005, 92.0571428571429, 95.21428571428575, ...]  """"""  new_df = pd.DataFrame()  pre_close = df[""close""].shift(1)  new_df[""tr""] = np.where(df[""high""] - df[""low""] > np.absolute(pre_close - df[""high""]),        np.where(df[""high""] - df[""low""] > np.absolute(pre_close - df[""low""]),          df[""high""] - df[""low""], np.absolute(pre_close - df[""low""])),        np.where(np.absolute(pre_close - df[""high""]) > np.absolute(pre_close - df[""low""]),          np.absolute(pre_close - df[""high""]), np.absolute(pre_close - df[""low""])))  new_df[""atr""] = tqsdk.tafunc.ma(new_df[""tr""], n)  return new_df def BIAS(df, n):  """"""  乖离率  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 移动平均的计算周期  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""bias"", 代表计算出来的乖离率值  Example::   # 获取 CFFEX.IF1903 合约的乖离率   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import BIAS   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   bias = BIAS(klines, 6)   print(list(bias[""bias""])) # 乖离率   # 预计的输出是这样的:   [..., 2.286835533357118, 2.263301549041151, 0.7068445823271412, ...]  """"""  ma1 = tqsdk.tafunc.ma(df[""close""], n)  new_df = pd.DataFrame(data=list((df[""close""] - ma1) / ma1 * 100), columns=[""bias""])  return new_df def BOLL(df, n, p):  """"""  布林线  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n   p (int): 计算参数p  Returns:   pandas.DataFrame: 返回的dataframe包含3列, 分别是""mid"", ""top""和""bottom"", 分别代表布林线的中、上、下轨  Example::   # 获取 CFFEX.IF1903 合约的布林线   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import BOLL   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   boll=BOLL(klines, 26, 2)   print(list(boll[""mid""]))   print(list(boll[""top""]))   print(list(boll[""bottom""]))   # 预计的输出是这样的:   [..., 3401.338461538462, 3425.600000000001, 3452.3230769230777, ...]   [..., 3835.083909752222, 3880.677579320277, 3921.885406954584, ...]   [..., 2967.593013324702, 2970.5224206797247, 2982.760746891571, ...]  """"""  new_df = pd.DataFrame()  mid = tqsdk.tafunc.ma(df[""close""], n)  std = df[""close""].rolling(n).std()  new_df[""mid""] = mid  new_df[""top""] = mid + p * std  new_df[""bottom""] = mid - p * std  return new_df def DMI(df, n, m):  """"""  动向指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n   m (int): 周期m  Returns:   pandas.DataFrame: 返回的DataFrame包含5列, 是""atr"", ""pdi"", ""mdi"", ""adx""和""adxr"", 分别代表平均真实波幅, 上升方向线, 下降方向线, 趋向平均值以及评估数值  Example::   # 获取 CFFEX.IF1903 合约的动向指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import DMI   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   dmi=DMI(klines, 14, 6)   print(list(dmi[""atr""]))   print(list(dmi[""pdi""]))   print(list(dmi[""mdi""]))   print(list(dmi[""adx""]))   print(list(dmi[""adxr""]))   # 预计的输出是这样的:   [..., 95.20000000000005, 92.0571428571429, 95.21428571428575, ...]   [..., 51.24549819927972, 46.55493482309126, 47.14178544636161, ...]   [..., 6.497599039615802, 6.719428926132791, 6.4966241560389655, ...]   [..., 78.80507786697127, 76.8773544355082, 75.11662664555287, ...]   [..., 70.52493837227118, 73.28531799111778, 74.59341569051983, ...]  """"""  new_df = pd.DataFrame()  new_df[""atr""] = ATR(df, n)[""atr""]  pre_high = df[""high""].shift(1)  pre_low = df[""low""].shift(1)  hd = df[""high""] - pre_high  ld = pre_low - df[""low""]  admp = tqsdk.tafunc.ma(pd.Series(np.where((hd > 0) & (hd > ld), hd, 0)), n)  admm = tqsdk.tafunc.ma(pd.Series(np.where((ld > 0) & (ld > hd), ld, 0)), n)  new_df[""pdi""] = pd.Series(np.where(new_df[""atr""] > 0, admp / new_df[""atr""] * 100, np.NaN)).ffill()  new_df[""mdi""] = pd.Series(np.where(new_df[""atr""] > 0, admm / new_df[""atr""] * 100, np.NaN)).ffill()  ad = pd.Series(np.absolute(new_df[""mdi""] - new_df[""pdi""]) / (new_df[""mdi""] + new_df[""pdi""]) * 100)  new_df[""adx""] = tqsdk.tafunc.ma(ad, m)  new_df[""adxr""] = (new_df[""adx""] + new_df[""adx""].shift(m)) / 2  return new_df def KDJ(df, n, m1, m2):  """"""  随机指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n   m1 (int): 参数m1   m2 (int): 参数m2  Returns:   pandas.DataFrame: 返回的DataFrame包含3列, 是""k"", ""d""和""j"", 分别代表计算出来的K值, D值和J值  Example::   # 获取 CFFEX.IF1903 合约的随机指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import KDJ   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   kdj = KDJ(klines, 9, 3, 3)   print(list(kdj[""k""]))   print(list(kdj[""d""]))   print(list(kdj[""j""]))   # 预计的输出是这样的:   [..., 80.193148635668, 81.83149521546302, 84.60665654726242, ...]   [..., 82.33669997171852, 82.16829838630002, 82.98108443995415, ...]   [..., 77.8451747299365, 75.90604596356695, 81.15788887378903, ...]  """"""  new_df = pd.DataFrame()  hv = df[""high""].rolling(n).max()  lv = df[""low""].rolling(n).min()  rsv = pd.Series(np.where(hv == lv, 0, (df[""close""] - lv) / (hv - lv) * 100))  new_df[""k""] = tqsdk.tafunc.sma(rsv, m1, 1)  new_df[""d""] = tqsdk.tafunc.sma(new_df[""k""], m2, 1)  new_df[""j""] = 3 * new_df[""k""] - 2 * new_df[""d""]  return new_df def MACD(df, short, long, m):  """"""  异同移动平均线  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   short (int): 短周期   long (int): 长周期   m (int): 移动平均线的周期  Returns:   pandas.DataFrame: 返回的DataFrame包含3列, 是""diff"", ""dea""和""bar"", 分别代表离差值, DIFF的指数加权移动平均线, MACD的柱状线   (注: 因 DataFrame 有diff()函数，因此获取到此指标后：""diff""字段使用 macd[""diff""] 方式来取值，而非 macd.diff )  Example::   # 获取 CFFEX.IF1903 合约的异同移动平均线   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import MACD   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   macd = MACD(klines, 12, 26, 9)   print(list(macd[""diff""]))   print(list(macd[""dea""]))   print(list(macd[""bar""]))   # 预计的输出是这样的:   [..., 149.58313904045826, 155.50790712365142, 160.27622505636737, ...]   [..., 121.46944573796466, 128.27713801510203, 134.6769554233551, ...]   [..., 56.2273866049872, 54.46153821709879, 51.19853926602451, ...]  """"""  new_df = pd.DataFrame()  eshort = tqsdk.tafunc.ema(df[""close""], short)  elong = tqsdk.tafunc.ema(df[""close""], long)  new_df[""diff""] = eshort - elong  new_df[""dea""] = tqsdk.tafunc.ema(new_df[""diff""], m)  new_df[""bar""] = 2 * (new_df[""diff""] - new_df[""dea""])  return new_df # @numba.njit def _sar(open, high, low, close, range_high, range_low, n, step, maximum):  n = max(np.sum(np.isnan(range_high)), np.sum(np.isnan(range_low))) + 2  sar = np.empty_like(close)  sar[:n] = np.NAN  af = 0  ep = 0  trend = 1 if (close[n] - open[n]) > 0 else -1  if trend == 1:   sar[n] = min(range_low[n - 2], low[n - 1])  else:   sar[n] = max(range_high[n - 2], high[n - 1])  for i in range(n, len(sar)):   if i != n:    if abs(trend) > 1:     sar[i] = sar[i - 1] + af * (ep - sar[i - 1])    elif trend == 1:     sar[i] = min(range_low[i - 2], low[i - 1])    elif trend == -1:     sar[i] = max(range_high[i - 2], high[i - 1])   if trend > 0:    if sar[i - 1] > low[i]:     ep = low[i]     af = step     trend = -1    else:     ep = high[i]     af = min(af + step, maximum) if ep > range_high[i - 1] else af     trend += 1   else:    if sar[i - 1] < high[i]:     ep = high[i]     af = step     trend = 1    else:     ep = low[i]     af = min(af + step, maximum) if ep < range_low[i - 1] else af     trend -= 1  return sar def SAR(df, n, step, max):  """"""  抛物线指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): SAR的周期n   step (float): 步长   max (float): 极值  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""sar"", 代表计算出来的SAR值  Example::   # 获取 CFFEX.IF1903 合约的抛物线指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import SAR   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   sar=SAR(klines, 4, 0.02, 0.2)   print(list(sar[""sar""]))   # 预计的输出是这样的:   [..., 3742.313604622293, 3764.5708836978342, 3864.4, ...]  """"""  range_high = df[""high""].rolling(n - 1).max()  range_low = df[""low""].rolling(n - 1).min()  sar = _sar(df[""open""].values, df[""high""].values, df[""low""].values, df[""close""].values, range_high.values,    range_low.values, n, step, max)  new_df = pd.DataFrame(data=sar, columns=[""sar""])  return new_df def WR(df, n):  """"""  威廉指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""wr"", 代表计算出来的威廉指标  Example::   # 获取 CFFEX.IF1903 合约的威廉指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import WR   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   wr = WR(klines, 14)   print(list(wr[""wr""]))   # 预计的输出是这样的:   [..., -12.843029637760672, -8.488840102451537, -16.381322957198407, ...]  """"""  hn = df[""high""].rolling(n).max()  ln = df[""low""].rolling(n).min()  new_df = pd.DataFrame(data=list((hn - df[""close""]) / (hn - ln) * (-100)), columns=[""wr""])  return new_df def RSI(df, n):  """"""  相对强弱指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""rsi"", 代表计算出来的相对强弱指标  Example::   # 获取 CFFEX.IF1903 合约的相对强弱指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import RSI   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   rsi = RSI(klines, 7)   print(list(rsi[""rsi""]))   # 预计的输出是这样的:   [..., 80.21169825630794, 81.57315806032297, 72.34968324924667, ...]  """"""  lc = df[""close""].shift(1)  rsi = tqsdk.tafunc.sma(pd.Series(np.where(df[""close""] - lc > 0, df[""close""] - lc, 0)), n, 1) / \   tqsdk.tafunc.sma(np.absolute(df[""close""] - lc), n, 1) * 100  new_df = pd.DataFrame(data=rsi, columns=[""rsi""])  return new_df def ASI(df):  """"""  振动升降指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""asi"", 代表计算出来的振动升降指标  Example::   # 获取 CFFEX.IF1903 合约的振动升降指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import ASI   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   asi = ASI(klines)   print(list(asi[""asi""]))   # 预计的输出是这样的:   [..., -4690.587005986468, -4209.182816350308, -4699.742010304962, ...]  """"""  lc = df[""close""].shift(1) # 上一交易日的收盘价  aa = np.absolute(df[""high""] - lc)  bb = np.absolute(df[""low""] - lc)  cc = np.absolute(df[""high""] - df[""low""].shift(1))  dd = np.absolute(lc - df[""open""].shift(1))  r = np.where((aa > bb) & (aa > cc), aa + bb / 2 + dd / 4,     np.where((bb > cc) & (bb > aa), bb + aa / 2 + dd / 4, cc + dd / 4))  x = df[""close""] - lc + (df[""close""] - df[""open""]) / 2 + lc - df[""open""].shift(1)  si = np.where(r == 0, 0, 16 * x / r * np.where(aa > bb, aa, bb))  new_df = pd.DataFrame(data=list(pd.Series(si).cumsum()), columns=[""asi""])  return new_df def VR(df, n):  """"""  VR 容量比率  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""vr"", 代表计算出来的VR  Example::   # 获取 CFFEX.IF1903 合约的VR   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import VR   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   vr = VR(klines, 26)   print(list(vr[""vr""]))   # 预计的输出是这样的:   [..., 150.1535316212112, 172.2897559521652, 147.04236342791924, ...]  """"""  lc = df[""close""].shift(1)  vr = pd.Series(np.where(df[""close""] > lc, df[""volume""], 0)).rolling(n).sum() / pd.Series(   np.where(df[""close""] <= lc, df[""volume""], 0)).rolling(n).sum() * 100  new_df = pd.DataFrame(data=list(vr), columns=[""vr""])  return new_df def ARBR(df, n):  """"""  人气意愿指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""ar""和""br"" , 分别代表人气指标和意愿指标  Example::   # 获取 CFFEX.IF1903 合约的人气意愿指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import ARBR   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   arbr = ARBR(klines, 26)   print(list(arbr[""ar""]))   print(list(arbr[""br""]))   # 预计的输出是这样的:   [..., 183.5698517817721, 189.98732572877034, 175.08802816901382, ...]   [..., 267.78549382716034, 281.567546278062, 251.08041091037902, ...]  """"""  new_df = pd.DataFrame()  new_df[""ar""] = (df[""high""] - df[""open""]).rolling(n).sum() / (df[""open""] - df[""low""]).rolling(n).sum() * 100  new_df[""br""] = pd.Series(   np.where(df[""high""] - df[""close""].shift(1) > 0, df[""high""] - df[""close""].shift(1), 0)).rolling(   n).sum() / pd.Series(   np.where(df[""close""].shift(1) - df[""low""] > 0, df[""close""].shift(1) - df[""low""], 0)).rolling(n).sum() * 100  return new_df def DMA(df, short, long, m):  """"""  平均线差  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   short (int): 短周期   long (int): 长周期   m (int): 计算周期m  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""ddd""和""ama"", 分别代表长短周期均值的差和ddd的简单移动平均值  Example::   # 获取 CFFEX.IF1903 合约的平均线差   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import DMA   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   dma = DMA(klines, 10, 50, 10)   print(list(dma[""ddd""]))   print(list(dma[""ama""]))   # 预计的输出是这样的:   [..., 409.2520000000022, 435.68000000000166, 458.3360000000025, ...]   [..., 300.64360000000147, 325.0860000000015, 349.75200000000166, ...]  """"""  new_df = pd.DataFrame()  new_df[""ddd""] = tqsdk.tafunc.ma(df[""close""], short) - tqsdk.tafunc.ma(df[""close""], long)  new_df[""ama""] = tqsdk.tafunc.ma(new_df[""ddd""], m)  return new_df def EXPMA(df, p1, p2):  """"""  指数加权移动平均线组合  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   p1 (int): 周期1   p2 (int): 周期2  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""ma1""和""ma2"", 分别代表指数加权移动平均线1和指数加权移动平均线2  Example::   # 获取 CFFEX.IF1903 合约的指数加权移动平均线组合   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import EXPMA   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   expma = EXPMA(klines, 5, 10)   print(list(expma[""ma1""]))   print(list(expma[""ma2""]))   # 预计的输出是这样的:   [..., 3753.679549224137, 3784.6530328160916, 3792.7020218773946, ...]   [..., 3672.4492964832566, 3704.113060759028, 3723.1470497119317, ...]  """"""  new_df = pd.DataFrame()  new_df[""ma1""] = tqsdk.tafunc.ema(df[""close""], p1)  new_df[""ma2""] = tqsdk.tafunc.ema(df[""close""], p2)  return new_df def CR(df, n, m):  """"""  CR能量  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n   m (int): 周期m  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""cr""和""crma"", 分别代表CR值和CR值的简单移动平均值  Example::   # 获取 CFFEX.IF1903 合约的CR能量   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import CR   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   cr = CR(klines, 26, 5)   print(list(cr[""cr""]))   print(list(cr[""crma""]))   # 预计的输出是这样的:   [..., 291.5751884671343, 316.71058105671943, 299.50578748862046, ...]   [..., 316.01257308163747, 319.3545725665982, 311.8275184876805, ...]  """"""  new_df = pd.DataFrame()  mid = (df[""high""] + df[""low""] + df[""close""]) / 3  new_df[""cr""] = pd.Series(np.where(0 > df[""high""] - mid.shift(1), 0, df[""high""] - mid.shift(1))).rolling(   n).sum() / pd.Series(np.where(0 > mid.shift(1) - df[""low""], 0, mid.shift(1) - df[""low""])).rolling(n).sum() * 100  new_df[""crma""] = tqsdk.tafunc.ma(new_df[""cr""], m).shift(int(m / 2.5 + 1))  return new_df def CCI(df, n):  """"""  顺势指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""cci"", 代表计算出来的CCI值  Example::   # 获取 CFFEX.IF1903 合约的顺势指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import CCI   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   cci = CCI(klines, 14)   print(list(cci[""cci""]))   # 预计的输出是这样的:   [..., 98.13054698810375, 93.57661788413617, 77.8671380173813, ...]  """"""  typ = (df[""high""] + df[""low""] + df[""close""]) / 3  ma = tqsdk.tafunc.ma(typ, n)  def mad(x):   return np.fabs(x - x.mean()).mean()  md = typ.rolling(window=n).apply(mad, raw=True) # 平均绝对偏差  new_df = pd.DataFrame(data=list((typ - ma) / (md * 0.015)), columns=[""cci""])  return new_df def OBV(df):  """"""  能量潮  Args:   df (pandas.DataFrame): Dataframe格式的K线序列  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""obv"", 代表计算出来的OBV值  Example::   # 获取 CFFEX.IF1903 合约的能量潮   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import OBV   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   obv = OBV(klines)   print(list(obv[""obv""]))   # 预计的输出是这样的:   [..., 267209, 360351, 264476, ...]  """"""  lc = df[""close""].shift(1)  obv = (np.where(df[""close""] > lc, df[""volume""], np.where(df[""close""] < lc, -df[""volume""], 0))).cumsum()  new_df = pd.DataFrame(data=obv, columns=[""obv""])  return new_df def CDP(df, n):  """"""  逆势操作  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n  Returns:   pandas.DataFrame: 返回的DataFrame包含4列, 是""ah"", ""al"", ""nh"", ""nl"", 分别代表最高值, 最低值, 近高值, 近低值  Example::   # 获取 CFFEX.IF1903 合约的逆势操作指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import CDP   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   cdp = CDP(klines, 3)   print(list(cdp[""ah""]))   print(list(cdp[""al""]))   print(list(cdp[""nh""]))   print(list(cdp[""nl""]))   # 预计的输出是这样的:   [..., 3828.244444444447, 3871.733333333336, 3904.37777777778, ...]   [..., 3656.64444444444, 3698.3999999999955, 3734.9111111111065, ...]   [..., 3743.8888888888837, 3792.3999999999946, 3858.822222222217, ...]   [..., 3657.2222222222213, 3707.6666666666656, 3789.955555555554, ...]  """"""  new_df = pd.DataFrame()  pt = df[""high""].shift(1) - df[""low""].shift(1)  cdp = (df[""high""].shift(1) + df[""low""].shift(1) + df[""close""].shift(1)) / 3  new_df[""ah""] = tqsdk.tafunc.ma(cdp + pt, n)  new_df[""al""] = tqsdk.tafunc.ma(cdp - pt, n)  new_df[""nh""] = tqsdk.tafunc.ma(2 * cdp - df[""low""], n)  new_df[""nl""] = tqsdk.tafunc.ma(2 * cdp - df[""high""], n)  return new_df def HCL(df, n):  """"""  均线通道  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n  Returns:   pandas.DataFrame: 返回的DataFrame包含3列, 是""mah"", ""mal"", ""mac"", 分别代表最高价的移动平均线, 最低价的移动平均线以及收盘价的移动平均线  Example::   # 获取 CFFEX.IF1903 合约的均线通道指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import HCL   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   hcl = HCL(klines, 10)   print(list(hcl[""mah""]))   print(list(hcl[""mal""]))   print(list(hcl[""mac""]))   # 预计的输出是这样的:   [..., 3703.5400000000022, 3743.2800000000025, 3778.300000000002, ...]   [..., 3607.339999999999, 3643.079999999999, 3677.579999999999, ...]   [..., 3666.1600000000008, 3705.8600000000006, 3741.940000000001, ...]  """"""  new_df = pd.DataFrame()  new_df[""mah""] = tqsdk.tafunc.ma(df[""high""], n)  new_df[""mal""] = tqsdk.tafunc.ma(df[""low""], n)  new_df[""mac""] = tqsdk.tafunc.ma(df[""close""], n)  return new_df def ENV(df, n, k):  """"""  包略线 (Envelopes)  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n   k (float): 参数k  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""upper"", ""lower"", 分别代表上线和下线  Example::   # 获取 CFFEX.IF1903 合约的包略线   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import ENV   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   env = ENV(klines, 14, 6)   print(list(env[""upper""]))   print(list(env[""lower""]))   # 预计的输出是这样的:   [..., 3842.2122857142863, 3876.7531428571433, 3893.849428571429, ...]   [..., 3407.244857142857, 3437.875428571429, 3453.036285714286, ...]  """"""  new_df = pd.DataFrame()  new_df[""upper""] = tqsdk.tafunc.ma(df[""close""], n) * (1 + k / 100)  new_df[""lower""] = tqsdk.tafunc.ma(df[""close""], n) * (1 - k / 100)  return new_df def MIKE(df, n):  """"""  麦克指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n  Returns:   pandas.DataFrame: 返回的DataFrame包含6列, 是""wr"", ""mr"", ""sr"", ""ws"", ""ms"", ""ss"", 分别代表初级压力价,中级压力,强力压力,初级支撑,中级支撑和强力支撑  Example::   # 获取 CFFEX.IF1903 合约的麦克指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import MIKE   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   mike = MIKE(klines, 12)   print(list(mike[""wr""]))   print(list(mike[""mr""]))   print(list(mike[""sr""]))   print(list(mike[""ws""]))   print(list(mike[""ms""]))   print(list(mike[""ss""]))   # 预计的输出是这样的:   [..., 4242.4, 4203.333333333334, 3986.266666666666, ...]   [..., 4303.6, 4283.866666666667, 4175.333333333333, ...]   [..., 4364.8, 4364.4, 4364.4, ...]   [..., 3770.5999999999995, 3731.9333333333343, 3514.866666666666, ...]   [..., 3359.9999999999995, 3341.066666666667, 3232.533333333333, ...]   [..., 2949.3999999999996, 2950.2, 2950.2, ...]  """"""  new_df = pd.DataFrame()  typ = (df[""high""] + df[""low""] + df[""close""]) / 3  ll = df[""low""].rolling(n).min()  hh = df[""high""].rolling(n).max()  new_df[""wr""] = typ + (typ - ll)  new_df[""mr""] = typ + (hh - ll)  new_df[""sr""] = 2 * hh - ll  new_df[""ws""] = typ - (hh - typ)  new_df[""ms""] = typ - (hh - ll)  new_df[""ss""] = 2 * ll - hh  return new_df def PUBU(df, m):  """"""  瀑布线  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   m (int): 周期m  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""pb"", 代表计算出的瀑布线  Example::   # 获取 CFFEX.IF1903 合约的瀑布线   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import PUBU   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   pubu = PUBU(klines, 4)   print(list(pubu[""pb""]))   # 预计的输出是这样的:   [..., 3719.087702972829, 3728.9326217836974, 3715.7537397368856, ...]  """"""  pb = (tqsdk.tafunc.ema(df[""close""], m) + tqsdk.tafunc.ma(df[""close""], m * 2) + tqsdk.tafunc.ma(df[""close""], m * 4)) / 3  new_df = pd.DataFrame(data=list(pb), columns=[""pb""])  return new_df def BBI(df, n1, n2, n3, n4):  """"""  多空指数  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n1 (int): 周期n1   n2 (int): 周期n2   n3 (int): 周期n3   n4 (int): 周期n4  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""bbi"", 代表计算出的多空指标  Example::   # 获取 CFFEX.IF1903 合约的多空指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import BBI   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   bbi = BBI(klines, 3, 6, 12, 24)   print(list(bbi[""bbi""]))   # 预计的输出是这样的:   [..., 3679.841666666668, 3700.9645833333348, 3698.025000000002, ...]  """"""  bbi = (tqsdk.tafunc.ma(df[""close""], n1) + tqsdk.tafunc.ma(df[""close""], n2) + tqsdk.tafunc.ma(df[""close""], n3) + tqsdk.tafunc.ma(   df[""close""], n4)) / 4  new_df = pd.DataFrame(data=list(bbi), columns=[""bbi""])  return new_df def DKX(df, m):  """"""  多空线  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   m (int): 周期m  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""b"", ""d"", 分别代表计算出来的DKX指标及DKX的m日简单移动平均值  Example::   # 获取 CFFEX.IF1903 合约的多空线   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import DKX   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   dkx = DKX(klines, 10)   print(list(dkx[""b""]))   print(list(dkx[""d""]))   # 预计的输出是这样的:   [..., 3632.081746031746, 3659.4501587301593, 3672.744761904762, ...]   [..., 3484.1045714285706, 3516.1797301587294, 3547.44857142857, ...]  """"""  new_df = pd.DataFrame()  a = (3 * df[""close""] + df[""high""] + df[""low""] + df[""open""]) / 6  new_df[""b""] = (20 * a + 19 * a.shift(1) + 18 * a.shift(2) + 17 * a.shift(3) + 16 * a.shift(4) + 15 * a.shift(   5) + 14 * a.shift(6)     + 13 * a.shift(7) + 12 * a.shift(8) + 11 * a.shift(9) + 10 * a.shift(10) + 9 * a.shift(     11) + 8 * a.shift(     12) + 7 * a.shift(13) + 6 * a.shift(14) + 5 * a.shift(15) + 4 * a.shift(16) + 3 * a.shift(     17) + 2 * a.shift(18) + a.shift(20)     ) / 210  new_df[""d""] = tqsdk.tafunc.ma(new_df[""b""], m)  return new_df def BBIBOLL(df, n, m):  """"""  多空布林线  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 参数n   m (int): 参数m  Returns:   pandas.DataFrame: 返回的DataFrame包含3列, 是""bbiboll"", ""upr"", ""dwn"", 分别代表多空布林线, 压力线和支撑线  Example::   # 获取 CFFEX.IF1903 合约的多空布林线   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import BBIBOLL   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   bbiboll=BBIBOLL(klines,10,3)   print(list(bbiboll[""bbiboll""]))   print(list(bbiboll[""upr""]))   print(list(bbiboll[""dwn""]))   # 预计的输出是这样的:   [..., 3679.841666666668, 3700.9645833333348, 3698.025000000002, ...]   [..., 3991.722633271389, 3991.796233444868, 3944.7721466057383, ...]   [..., 3367.960700061947, 3410.1329332218015, 3451.2778533942655, ...]  """"""  new_df = pd.DataFrame()  new_df[""bbiboll""] = (tqsdk.tafunc.ma(df[""close""], 3) + tqsdk.tafunc.ma(df[""close""], 6) + tqsdk.tafunc.ma(df[""close""],                       12) + tqsdk.tafunc.ma(   df[""close""], 24)) / 4  new_df[""upr""] = new_df[""bbiboll""] + m * new_df[""bbiboll""].rolling(n).std()  new_df[""dwn""] = new_df[""bbiboll""] - m * new_df[""bbiboll""].rolling(n).std()  return new_df def ADTM(df, n, m):  """"""  动态买卖气指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n   m (int): 周期m  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""adtm"", ""adtmma"", 分别代表计算出来的ADTM指标及其M日的简单移动平均  Example::   # 获取 CFFEX.IF1903 合约的动态买卖气指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import ADTM   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   adtm = ADTM(klines, 23, 8)   print(list(adtm[""adtm""]))   print(list(adtm[""adtmma""]))   # 预计的输出是这样的:   [..., 0.8404011965511171, 0.837919942816297, 0.8102215868477481, ...]   [..., 0.83855483869397, 0.8354743499113684, 0.8257261282040207, ...]  """"""  new_df = pd.DataFrame()  dtm = np.where(df[""open""] < df[""open""].shift(1), 0,     np.where(df[""high""] - df[""open""] > df[""open""] - df[""open""].shift(1), df[""high""] - df[""open""],        df[""open""] - df[""open""].shift(1)))  dbm = np.where(df[""open""] >= df[""open""].shift(1), 0,     np.where(df[""open""] - df[""low""] > df[""open""] - df[""open""].shift(1), df[""open""] - df[""low""],        df[""open""] - df[""open""].shift(1)))  stm = pd.Series(dtm).rolling(n).sum()  sbm = pd.Series(dbm).rolling(n).sum()  new_df[""adtm""] = np.where(stm > sbm, (stm - sbm) / stm, np.where(stm == sbm, 0, (stm - sbm) / sbm))  new_df[""adtmma""] = tqsdk.tafunc.ma(new_df[""adtm""], m)  return new_df def B3612(df):  """"""  三减六日乖离率  Args:   df (pandas.DataFrame): Dataframe格式的K线序列  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""b36"", ""b612"", 分别代表收盘价的3日移动平均线与6日移动平均线的乖离值及收盘价的6日移动平均线与12日移动平均线的乖离值  Example::   # 获取 CFFEX.IF1903 合约的三减六日乖离率   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import B3612   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   b3612=B3612(klines)   print(list(b3612[""b36""]))   print(list(b3612[""b612""]))   # 预计的输出是这样的:   [..., 57.26666666667188, 44.00000000000546, -5.166666666660603, ...]   [..., 99.28333333333285, 88.98333333333221, 69.64999999999918, ...]  """"""  new_df = pd.DataFrame()  new_df[""b36""] = tqsdk.tafunc.ma(df[""close""], 3) - tqsdk.tafunc.ma(df[""close""], 6)  new_df[""b612""] = tqsdk.tafunc.ma(df[""close""], 6) - tqsdk.tafunc.ma(df[""close""], 12)  return new_df def DBCD(df, n, m, t):  """"""  异同离差乖离率  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n   m (int): 参数m   t (int): 参数t  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""dbcd"", ""mm"", 分别代表离差值及其简单移动平均值  Example::   # 获取 CFFEX.IF1903 合约的异同离差乖离率   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import DBCD   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   dbcd=DBCD(klines, 5, 16, 76)   print(list(dbcd[""dbcd""]))   print(list(dbcd[""mm""]))   # 预计的输出是这样的:   [..., 0.0038539724453411045, 0.0034209659500908517, 0.0027130669520015094, ...]   [..., 0.003998499673401192, 0.003864353204606074, 0.0035925052896395872, ...]  """"""  new_df = pd.DataFrame()  bias = (df[""close""] - tqsdk.tafunc.ma(df[""close""], n)) / tqsdk.tafunc.ma(df[""close""], n)  dif = bias - bias.shift(m)  new_df[""dbcd""] = tqsdk.tafunc.sma(dif, t, 1)  new_df[""mm""] = tqsdk.tafunc.ma(new_df[""dbcd""], 5)  return new_df def DDI(df, n, n1, m, m1):  """"""  方向标准离差指数  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n   n1 (int): 参数n1   m (int): 参数m   m1 (int): 周期m1  Returns:   pandas.DataFrame: 返回的DataFrame包含3列, 是""ddi"", ""addi"", ""ad"", 分别代表DIZ与DIF的差值, DDI的加权平均, ADDI的简单移动平均  Example::   # 获取 CFFEX.IF1903 合约的方向标准离差指数   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import DDI   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   ddi = DDI(klines, 13, 30, 10, 5)   print(list(ddi[""ddi""]))   print(list(ddi[""addi""]))   print(list(ddi[""ad""]))   # 预计的输出是这样的:   [..., 0.6513560804899388, 0.6129178985672046, 0.40480202190395936, ...]   [..., 0.6559570156346113, 0.6416106432788091, 0.5626744361538593, ...]   [..., 0.6960565490556135, 0.6765004585407994, 0.6455063893920429, ...]  """"""  new_df = pd.DataFrame()  tr = np.where(np.absolute(df[""high""] - df[""high""].shift(1)) > np.absolute(df[""low""] - df[""low""].shift(1)),     np.absolute(df[""high""] - df[""high""].shift(1)), np.absolute(df[""low""] - df[""low""].shift(1)))  dmz = np.where((df[""high""] + df[""low""]) <= (df[""high""].shift(1) + df[""low""].shift(1)), 0, tr)  dmf = np.where((df[""high""] + df[""low""]) >= (df[""high""].shift(1) + df[""low""].shift(1)), 0, tr)  diz = pd.Series(dmz).rolling(n).sum() / (pd.Series(dmz).rolling(n).sum() + pd.Series(dmf).rolling(n).sum())  dif = pd.Series(dmf).rolling(n).sum() / (pd.Series(dmf).rolling(n).sum() + pd.Series(dmz).rolling(n).sum())  new_df[""ddi""] = diz - dif  new_df[""addi""] = tqsdk.tafunc.sma(new_df[""ddi""], n1, m)  new_df[""ad""] = tqsdk.tafunc.ma(new_df[""addi""], m1)  return new_df def KD(df, n, m1, m2):  """"""  随机指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n   m1 (int): 参数m1   m2 (int): 参数m2  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""k"", ""d"", 分别代表计算出来的K值与D值  Example::   # 获取 CFFEX.IF1903 合约的随机指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import KD   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   kd = KD(klines, 9, 3, 3)   print(list(kd[""k""]))   print(list(kd[""d""]))   # 预计的输出是这样的:   [..., 84.60665654726242, 80.96145249909222, 57.54863147922147, ...]   [..., 82.98108443995415, 82.30787379300017, 74.05479302174061, ...]  """"""  new_df = pd.DataFrame()  hv = df[""high""].rolling(n).max()  lv = df[""low""].rolling(n).min()  rsv = pd.Series(np.where(hv == lv, 0, (df[""close""] - lv) / (hv - lv) * 100))  new_df[""k""] = tqsdk.tafunc.sma(rsv, m1, 1)  new_df[""d""] = tqsdk.tafunc.sma(new_df[""k""], m2, 1)  return new_df def LWR(df, n, m):  """"""  威廉指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n   m (int): 参数m  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""lwr"", 代表计算出来的威廉指标  Example::   # 获取 CFFEX.IF1903 合约的威廉指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import LWR   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   lwr = LWR(klines, 9, 3)   print(list(lwr[""lwr""]))   # 预计的输出是这样的:   [..., -15.393343452737565, -19.03854750090778, -42.45136852077853, ...]  """"""  hv = df[""high""].rolling(n).max()  lv = df[""low""].rolling(n).min()  rsv = pd.Series(np.where(hv == lv, 0, (df[""close""] - hv) / (hv - lv) * 100))  new_df = pd.DataFrame(data=list(tqsdk.tafunc.sma(rsv, m, 1)), columns=[""lwr""])  return new_df def MASS(df, n1, n2):  """"""  梅斯线  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n1 (int): 周期n1   n2 (int): 周期n2  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""mass"", 代表计算出来的梅斯线指标  Example::   # 获取 CFFEX.IF1903 合约的梅斯线   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import MASS   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   mass = MASS(klines, 9, 25)   print(list(mass[""mass""]))   # 预计的输出是这样的:   [..., 27.478822053291733, 27.485710830466964, 27.561223922342652, ...]  """"""  ema1 = tqsdk.tafunc.ema(df[""high""] - df[""low""], n1)  ema2 = tqsdk.tafunc.ema(ema1, n1)  new_df = pd.DataFrame(data=list((ema1 / ema2).rolling(n2).sum()), columns=[""mass""])  return new_df def MFI(df, n):  """"""  资金流量指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""mfi"", 代表计算出来的MFI指标  Example::   # 获取 CFFEX.IF1903 合约的资金流量指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import MFI   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   mfi = MFI(klines, 14)   print(list(mfi[""mfi""]))   # 预计的输出是这样的:   [..., 73.47968487105688, 70.2250476611595, 62.950450871062266, ...]  """"""  typ = (df[""high""] + df[""low""] + df[""close""]) / 3  mr = pd.Series(np.where(typ > typ.shift(1), typ * df[""volume""], 0)).rolling(n).sum() / pd.Series(   np.where(typ < typ.shift(1), typ * df[""volume""], 0)).rolling(n).sum()  new_df = pd.DataFrame(data=list(100 - (100 / (1 + mr))), columns=[""mfi""])  return new_df def MI(df, n):  """"""  动量指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 参数n  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""a"", ""mi"", 分别代表当日收盘价与N日前收盘价的差值以及MI值  Example::   # 获取 CFFEX.IF1903 合约的动量指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import MI   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   mi = MI(klines, 12)   print(list(mi[""a""]))   print(list(mi[""mi""]))   # 预计的输出是这样的:   [..., 399.1999999999998, 370.8000000000002, 223.5999999999999, ...]   [..., 293.2089214076506, 299.67484462367975, 293.3352742383731, ...]  """"""  new_df = pd.DataFrame()  new_df[""a""] = df[""close""] - df[""close""].shift(n)  new_df[""mi""] = tqsdk.tafunc.sma(new_df[""a""], n, 1)  return new_df def MICD(df, n, n1, n2):  """"""  异同离差动力指数  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 参数n   n1 (int): 周期n1   n2 (int): 周期n2  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""dif"", ""micd"", 代表离差值和MICD指标  Example::   # 获取 CFFEX.IF1903 合约的异同离差动力指数   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import MICD   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   micd = MICD(klines, 3, 10, 20)   print(list(micd[""dif""]))   print(list(micd[""micd""]))   # 预计的输出是这样的:   [..., 6.801483500680234, 6.700989000453493, 6.527326000302342, ...]   [..., 6.2736377238314684, 6.3163728514936714, 6.3374681663745385, ...]  """"""  new_df = pd.DataFrame()  mi = df[""close""] - df[""close""].shift(1)  ami = tqsdk.tafunc.sma(mi, n, 1)  new_df[""dif""] = tqsdk.tafunc.ma(ami.shift(1), n1) - tqsdk.tafunc.ma(ami.shift(1), n2)  new_df[""micd""] = tqsdk.tafunc.sma(new_df[""dif""], 10, 1)  return new_df def MTM(df, n, n1):  """"""  MTM动力指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n   n1 (int): 周期n1  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""mtm"", ""mtmma"", 分别代表MTM值和MTM的简单移动平均值  Example::   # 获取 CFFEX.IF1903 合约的动力指标   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import MTM   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   mtm = MTM(klines, 6, 6)   print(list(mtm[""mtm""]))   print(list(mtm[""mtmma""]))   # 预计的输出是这样的:   [..., 144.79999999999973, 123.60000000000036, -4.200000000000273, ...]   [..., 198.5666666666667, 177.96666666666678, 139.30000000000004, ...]  """"""  new_df = pd.DataFrame()  new_df[""mtm""] = df[""close""] - df[""close""].shift(n)  new_df[""mtmma""] = tqsdk.tafunc.ma(new_df[""mtm""], n1)  return new_df def PRICEOSC(df, long, short):  """"""  价格震荡指数 Price Oscillator  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   long (int): 长周期   short (int): 短周期  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""priceosc"", 代表计算出来的价格震荡指数  Example::   # 获取 CFFEX.IF1903 合约的价格震荡指数   from tqsdk import TqApi, TqAuth, TqSim   from tqsdk.ta import PRICEOSC   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   priceosc = PRICEOSC(klines, 26, 12)   print(list(priceosc[""priceosc""]))   # 预计的输出是这样的:   [..., 5.730468338384374, 5.826866231225718, 5.776959240989803, ...]  """"""  ma_s = tqsdk.tafunc.ma(df[""close""], short)  ma_l = tqsdk.tafunc.ma(df[""close""], long)  new_df = pd.DataFrame(data=list((ma_s - ma_l) / ma_s * 100), columns=[""priceosc""])  return new_df def PSY(df, n, m):  """"""  心理线  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n   m (int): 周期m  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""psy"", ""psyma"", 分别代表心理线和心理线的简单移动平均  Example::   # 获取 CFFEX.IF1903 合约的心理线   from tqsdk import TqApi, TqSim   from tqsdk.ta import PSY   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   psy = PSY(klines, 12, 6)   print(list(psy[""psy""]))   print(list(psy[""psyma""]))   # 预计的输出是这样的:   [..., 58.333333333333336, 58.333333333333336, 50.0, ...]   [..., 54.16666666666671, 54.16666666666671, 54.16666666666671, ...]  """"""  new_df = pd.DataFrame()  new_df[""psy""] = tqsdk.tafunc.count(df[""close""] > df[""close""].shift(1), n) / n * 100  new_df[""psyma""] = tqsdk.tafunc.ma(new_df[""psy""], m)  return new_df def QHLSR(df):  """"""  阻力指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""qhl5"", ""qhl10"", 分别代表计算出来的QHL5值和QHL10值  Example::   # 获取 CFFEX.IF1903 合约的阻力指标   from tqsdk import TqApi, TqSim   from tqsdk.ta import QHLSR   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   ndf = QHLSR(klines)   print(list(ndf[""qhl5""]))   print(list(ndf[""qhl10""]))   # 预计的输出是这样的:   [..., 0.9512796890171819, 1.0, 0.8061319699743583, 0.36506038490240567, ...]   [..., 0.8192641975527878, 0.7851545532504415, 0.5895613967067044, ...]  """"""  new_df = pd.DataFrame()  qhl = (df[""close""] - df[""close""].shift(1)) - (df[""volume""] - df[""volume""].shift(1)) * (    df[""high""].shift(1) - df[""low""].shift(1)) / df[""volume""].shift(1)  a = pd.Series(np.where(qhl > 0, qhl, 0)).rolling(5).sum()  e = pd.Series(np.where(qhl > 0, qhl, 0)).rolling(10).sum()  b = np.absolute(pd.Series(np.where(qhl < 0, qhl, 0)).rolling(5).sum())  f = np.absolute(pd.Series(np.where(qhl < 0, qhl, 0)).rolling(10).sum())  d = a / (a + b)  g = e / (e + f)  new_df[""qhl5""] = np.where(pd.Series(np.where(qhl > 0, 1, 0)).rolling(5).sum() == 5, 1,        np.where(pd.Series(np.where(qhl < 0, 1, 0)).rolling(5).sum() == 5, 0, d))  new_df[""qhl10""] = g  return new_df def RC(df, n):  """"""  变化率指数  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 参数n  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""arc"", 代表计算出来的变化率指数  Example::   # 获取 CFFEX.IF1903 合约的变化率指数   from tqsdk import TqApi, TqSim   from tqsdk.ta import RC   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   rc = RC(klines, 50)   print(list(rc[""arc""]))   # 预计的输出是这样的:   [..., 1.011782057069131, 1.0157160672001329, 1.019680175228899, ...]  """"""  rc = df[""close""] / df[""close""].shift(n)  new_df = pd.DataFrame(data=list(tqsdk.tafunc.sma(rc.shift(1), n, 1)), columns=[""arc""])  return new_df def RCCD(df, n, n1, n2):  """"""  异同离差变化率指数  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 参数n   n1 (int): 周期n1   n2 (int): 周期n2  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""dif"", ""rccd"", 分别代表离差值和异同离差变化率指数  Example::   # 获取 CFFEX.IF1903 合约的异同离差变化率指数   from tqsdk import TqApi, TqSim   from tqsdk.ta import RCCD   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   rccd = RCCD(klines, 10, 21, 28)   print(list(rccd[""dif""]))   print(list(rccd[""rccd""]))   # 预计的输出是这样的:   [..., 0.007700543190044096, 0.007914865667604465, 0.008297381119103608, ...]   [..., 0.007454465277084111, 0.007500505316136147, 0.0075801928964328935, ...]  """"""  new_df = pd.DataFrame()  rc = df[""close""] / df[""close""].shift(n)  arc = tqsdk.tafunc.sma(rc.shift(1), n, 1)  new_df[""dif""] = tqsdk.tafunc.ma(arc.shift(1), n1) - tqsdk.tafunc.ma(arc.shift(1), n2)  new_df[""rccd""] = tqsdk.tafunc.sma(new_df[""dif""], n, 1)  return new_df def ROC(df, n, m):  """"""  变动速率  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 参数n   m (int): 周期m  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""roc"", ""rocma"", 分别代表ROC值和ROC的简单移动平均值  Example::   # 获取 CFFEX.IF1903 合约的变动速率   from tqsdk import TqApi, TqAuth   from tqsdk.ta import ROC   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   roc = ROC(klines, 24, 20)   print(list(roc[""roc""]))   print(list(roc[""rocma""]))   # 预计的输出是这样的:   [..., 21.389800555415288, 19.285937989351712, 15.183443085606768, ...]   [..., 14.597071588550435, 15.223202630466648, 15.537530180238516, ...]  """"""  new_df = pd.DataFrame()  new_df[""roc""] = (df[""close""] - df['close'].shift(n)) / df[""close""].shift(n) * 100  new_df[""rocma""] = tqsdk.tafunc.ma(new_df[""roc""], m)  return new_df def SLOWKD(df, n, m1, m2, m3):  """"""  慢速KD  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 周期n   m1 (int): 参数m1   m2 (int): 参数m2   m3 (int): 参数m3  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""k"", ""d"", 分别代表K值和D值  Example::   # 获取 CFFEX.IF1903 合约的慢速KD   from tqsdk import TqApi, TqAuth   from tqsdk.ta import SLOWKD   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   slowkd = SLOWKD(klines, 9, 3, 3, 3)   print(list(slowkd[""k""]))   print(list(slowkd[""d""]))   # 预计的输出是这样的:   [..., 82.98108443995415, 82.30787379300017, 74.05479302174061, ...]   [..., 83.416060393041, 83.04666485969405, 80.0493742470429, ...]  """"""  new_df = pd.DataFrame()  rsv = (df[""close""] - df[""low""].rolling(n).min()) / \   (df[""high""].rolling(n).max() - df[""low""].rolling(n).min()) * 100  fastk = tqsdk.tafunc.sma(rsv, m1, 1)  new_df[""k""] = tqsdk.tafunc.sma(fastk, m2, 1)  new_df[""d""] = tqsdk.tafunc.sma(new_df[""k""], m3, 1)  return new_df def SRDM(df, n):  """"""  动向速度比率  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 参数n  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""srdm"", ""asrdm"", 分别代表计算出来的SRDM值和SRDM值的加权移动平均值  Example::   # 获取 CFFEX.IF1903 合约的动向速度比率   from tqsdk import TqApi, TqAuth   from tqsdk.ta import SRDM   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   srdm = SRDM(klines, 30)   print(list(srdm[""srdm""]))   print(list(srdm[""asrdm""]))   # 预计的输出是这样的:   [..., 0.7865067466266866, 0.7570567713288928, 0.5528619528619526, ...]   [..., 0.45441550541510667, 0.4645035476122329, 0.4674488277872236, ...]  """"""  new_df = pd.DataFrame()  dmz = np.where((df[""high""] + df[""low""]) <= (df[""high""].shift(1) + df[""low""].shift(1)), 0,     np.where(np.absolute(df[""high""] - df[""high""].shift(1)) > np.absolute(df[""low""] - df[""low""].shift(1)),        np.absolute(df[""high""] - df[""high""].shift(1)), np.absolute(df[""low""] - df[""low""].shift(1))))  dmf = np.where((df[""high""] + df[""low""]) >= (df[""high""].shift(1) + df[""low""].shift(1)), 0,     np.where(np.absolute(df[""high""] - df[""high""].shift(1)) > np.absolute(df[""low""] - df[""low""].shift(1)),        np.absolute(df[""high""] - df[""high""].shift(1)), np.absolute(df[""low""] - df[""low""].shift(1))))  admz = tqsdk.tafunc.ma(pd.Series(dmz), 10)  admf = tqsdk.tafunc.ma(pd.Series(dmf), 10)  new_df[""srdm""] = np.where(admz > admf, (admz - admf) / admz, np.where(admz == admf, 0, (admz - admf) / admf))  new_df[""asrdm""] = tqsdk.tafunc.sma(new_df[""srdm""], n, 1)  return new_df def SRMI(df, n):  """"""  MI修正指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 参数n  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""a"", ""mi"", 分别代表A值和MI值  Example::   # 获取 CFFEX.IF1903 合约的MI修正指标   from tqsdk import TqApi, TqAuth   from tqsdk.ta import SRMI   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   srmi = SRMI(klines, 9)   print(list(srmi[""a""]))   print(list(srmi[""mi""]))   # 预计的输出是这样的:   [..., 0.10362397961836425, 0.07062591892459567, -0.03341929372138309, ...]   [..., 0.07583104758041452, 0.0752526999519902, 0.06317803398828206, ...]  """"""  new_df = pd.DataFrame()  new_df[""a""] = np.where(df[""close""] < df[""close""].shift(n),       (df[""close""] - df[""close""].shift(n)) / df[""close""].shift(n),       np.where(df[""close""] == df[""close""].shift(n), 0,          (df[""close""] - df[""close""].shift(n)) / df[""close""]))  new_df[""mi""] = tqsdk.tafunc.sma(new_df[""a""], n, 1)  return new_df def ZDZB(df, n1, n2, n3):  """"""  筑底指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n1 (int): 周期n1   n2 (int): 周期n2   n3 (int): 周期n3  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""b"", ""d"", 分别代表A值的n2周期简单移动平均和A值的n3周期简单移动平均  Example::   # 获取 CFFEX.IF1903 合约的筑底指标   from tqsdk import TqApi, TqAuth   from tqsdk.ta import ZDZB   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   zdzb = ZDZB(klines, 50, 5, 20)   print(list(zdzb[""b""]))   print(list(zdzb[""d""]))   # 预计的输出是这样的:   [..., 1.119565217391305, 1.1376811594202905, 1.155797101449276, ...]   [..., 1.0722350515828771, 1.091644989471076, 1.1077480490523965, ...]  """"""  new_df = pd.DataFrame()  a = pd.Series(np.where(df[""close""] >= df[""close""].shift(1), 1, 0)).rolling(n1).sum() / pd.Series(   np.where(df[""close""] < df[""close""].shift(1), 1, 0)).rolling(n1).sum()  new_df[""b""] = tqsdk.tafunc.ma(a, n2)  new_df[""d""] = tqsdk.tafunc.ma(a, n3)  return new_df def DPO(df):  """"""  区间震荡线  Args:   df (pandas.DataFrame): Dataframe格式的K线序列  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""dpo"", 代表计算出来的DPO指标  Example::   # 获取 CFFEX.IF1903 合约的区间震荡线   from tqsdk import TqApi, TqAuth   from tqsdk.ta import DPO   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   dpo = DPO(klines)   print(list(dpo[""dpo""]))   # 预计的输出是这样的:   [..., 595.4100000000021, 541.8300000000017, 389.7200000000016, ...]  """"""  dpo = df[""close""] - (tqsdk.tafunc.ma(df[""close""], 20)).shift(11)  new_df = pd.DataFrame(data=list(dpo), columns=[""dpo""])  return new_df def LON(df):  """"""  长线指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""lon"", ""ma1"", 分别代表长线指标和长线指标的10周期简单移动平均值  Example::   # 获取 CFFEX.IF1903 合约的长线指标   from tqsdk import TqApi, TqAuth   from tqsdk.ta import LON   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   lon = LON(klines)   print(list(lon[""lon""]))   print(list(lon[""ma1""]))   # 预计的输出是这样的:   [..., 6.419941948913239, 6.725451135494827, 6.483546043406369, ...]   [..., 4.366625464410439, 4.791685949556344, 5.149808865745246, ...]  """"""  new_df = pd.DataFrame()  tb = np.where(df[""high""] > df[""close""].shift(1),     df[""high""] - df[""close""].shift(1) + df[""close""] - df[""low""],     df[""close""] - df[""low""])  ts = np.where(df[""close""].shift(1) > df[""low""],     df[""close""].shift(1) - df[""low""] + df[""high""] - df[""close""],     df[""high""] - df[""close""])  vol1 = (tb - ts) * df[""volume""] / (tb + ts) / 10000  vol10 = vol1.ewm(alpha=0.1, adjust=False).mean() # DMA 动态均值  vol11 = vol1.ewm(alpha=0.05, adjust=False).mean() # DMA  res1 = vol10 - vol11  new_df[""lon""] = res1.cumsum()  new_df[""ma1""] = tqsdk.tafunc.ma(new_df[""lon""], 10)  return new_df def SHORT(df):  """"""  短线指标  Args:   df (pandas.DataFrame): Dataframe格式的K线序列  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""short"", ""ma1"", 分别代表短线指标和短线指标的10周期简单移动平均值  Example::   # 获取 CFFEX.IF1903 合约的短线指标   from tqsdk import TqApi, TqAuth   from tqsdk.ta import SHORT   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   short = SHORT(klines)   print(list(short[""short""]))   print(list(short[""ma1""]))   # 预计的输出是这样的:   [..., 0.6650139934614072, 0.3055091865815881, -0.24190509208845834, ...]   [..., 0.41123378999608917, 0.42506048514590444, 0.35812291618890224, ...]  """"""  new_df = pd.DataFrame()  tb = np.where(df[""high""] > df[""close""].shift(1),     df[""high""] - df[""close""].shift(1) + df[""close""] - df[""low""],     df[""close""] - df[""low""])  ts = np.where(df[""close""].shift(1) > df[""low""],     df[""close""].shift(1) - df[""low""] + df[""high""] - df[""close""],     df[""high""] - df[""close""])  vol1 = (tb - ts) * df[""volume""] / (tb + ts) / 10000  vol10 = vol1.ewm(alpha=0.1, adjust=False).mean() # DMA 动态均值  vol11 = vol1.ewm(alpha=0.05, adjust=False).mean() # DMA  new_df[""short""] = vol10 - vol11  new_df[""ma1""] = tqsdk.tafunc.ma(new_df[""short""], 10)  return new_df def MV(df, n, m):  """"""  均量线  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 参数n   m (int): 参数m  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""mv1"", ""mv2"", 分别代表均量线1和均量线2  Example::   # 获取 CFFEX.IF1903 合约的均量线   from tqsdk import TqApi, TqAuth   from tqsdk.ta import MV   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   mv = MV(klines, 10, 20)   print(list(mv[""mv1""]))   print(list(mv[""mv2""]))   # 预计的输出是这样的:   [..., 69851.39419881169, 72453.75477893051, 75423.57930103746, ...]   [..., 49044.75870654942, 51386.27077122195, 53924.557232660845, ...]  """"""  new_df = pd.DataFrame()  new_df[""mv1""] = tqsdk.tafunc.sma(df[""volume""], n, 1)  new_df[""mv2""] = tqsdk.tafunc.sma(df[""volume""], m, 1)  return new_df def WAD(df, n, m):  """"""  威廉多空力度线  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 参数n   m (int): 参数m  Returns:   pandas.DataFrame: 返回的DataFrame包含3列, 是""a"", ""b"", ""e"", 分别代表A/D值,A/D值n周期的以1为权重的移动平均, A/D值m周期的以1为权重的移动平均  Example::   # 获取 CFFEX.IF1903 合约的威廉多空力度线   from tqsdk import TqApi, TqAuth   from tqsdk.ta import WAD   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   wad = WAD(klines, 10, 30)   print(list(wad[""a""]))   print(list(wad[""b""]))   print(list(wad[""e""]))   # 预计的输出是这样的:   [..., 90.0, 134.79999999999973, 270.4000000000001, ...]   [..., 344.4265821851701, 323.46392396665306, 318.1575315699878, ...]   [..., 498.75825781872277, 486.626315891432, 479.41877202838424, ...]  """"""  new_df = pd.DataFrame()  new_df[""a""] = np.absolute(np.where(df[""close""] > df[""close""].shift(1),          df[""close""] - np.where(df[""close""].shift(1) < df[""low""], df[""close""].shift(1),                df[""low""]),          np.where(df[""close""] < df[""close""].shift(1), df[""close""] - np.where(           df[""close""].shift(1) > df[""high""], df[""close""].shift(1), df[""high""]),             0)).cumsum())  new_df[""b""] = tqsdk.tafunc.sma(new_df[""a""], n, 1)  new_df[""e""] = tqsdk.tafunc.sma(new_df[""a""], m, 1)  return new_df def AD(df):  """"""  累积/派发指标 Accumulation/Distribution  Args:   df (pandas.DataFrame): Dataframe格式的K线序列  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""ad"", 代表计算出来的累积/派发指标  Example::   # 获取 CFFEX.IF1903 合约的累积/派发指标   from tqsdk import TqApi, TqAuth   from tqsdk.ta import AD   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   ad = AD(klines)   print(list(ad[""ad""]))   # 预计的输出是这样的:   [..., 146240.57181105542, 132822.950945916, 49768.15024044845, ...]  """"""  ad = (((df[""close""] - df[""low""]) - (df[""high""] - df[""close""])) / (df[""high""] - df[""low""]) * df[   ""volume""]).cumsum()  new_df = pd.DataFrame(data=list(ad), columns=[""ad""])  return new_df def CCL(df):  """"""  持仓异动  Args:   df (pandas.DataFrame): Dataframe格式的K线序列  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""ccl"", 代表计算出来的持仓异动指标  Example::   # 获取 CFFEX.IF1903 合约的持仓异动指标   from tqsdk import TqApi, TqAuth   from tqsdk.ta import CCL   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   ccl = CCL(klines)   print(list(ccl[""ccl""]))   # 预计的输出是这样的:   [..., '多头增仓', '多头减仓', '空头增仓', ...]  """"""  ccl = np.where(df[""close""] > df[""close""].shift(1),     np.where(df[""close_oi""] > df[""close_oi""].shift(1), ""多头增仓"", ""空头减仓""),     np.where(df[""close_oi""] > df[""close_oi""].shift(1), ""空头增仓"", ""多头减仓""))  # color = np.where(df[""close""] > df[""close""].shift(1), ""红"", ""绿"") # 1表示红色, 0表示绿色  # position = np.where(df[""close_oi""] > df[""close_oi""].shift(1), ""上"", ""下"") # 1表示零轴之上, 0表示零轴之下  new_df = pd.DataFrame(data=list(ccl), columns=[""ccl""])  return new_df def CJL(df):  """"""  成交量  Args:   df (pandas.DataFrame): Dataframe格式的K线序列  Returns:   pandas.DataFrame: 返回的DataFrame包含2列, 是""vol"", ""opid"", 分别代表成交量和持仓量  Example::   # 获取 CFFEX.IF1903 合约的成交量   from tqsdk import TqApi, TqAuth   from tqsdk.ta import CJL   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   ndf = CJL(klines)   print(list(ndf[""vol""]))   print(list(ndf[""opid""]))   # 预计的输出是这样的:   [..., 93142, 95875, 102152, ...]   [..., 69213, 66414, 68379, ...]  """"""  new_df = pd.DataFrame()  new_df[""vol""] = df[""volume""] # 成交量  new_df[""opid""] = df[""close_oi""] # 持仓量  return new_df def OPI(df):  """"""  持仓量  Args:   df (pandas.DataFrame): Dataframe格式的K线序列  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""opi"", 代表持仓量  Example::   # 获取 CFFEX.IF1903 合约的持仓量   from tqsdk import TqApi, TqAuth   from tqsdk.ta import OPI   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   opi = OPI(klines)   print(list(opi[""opi""]))   # 预计的输出是这样的:   [..., 69213, 66414, 68379, ...]  """"""  opi = df[""close_oi""]  new_df = pd.DataFrame(data=list(opi), columns=[""opi""])  return new_df def PVT(df):  """"""  价量趋势指数  Args:   df (pandas.DataFrame): Dataframe格式的K线序列  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""pvt"", 代表计算出来的价量趋势指数  Example::   # 获取 CFFEX.IF1903 合约的价量趋势指数   from tqsdk import TqApi, TqAuth   from tqsdk.ta import PVT   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   pvt = PVT(klines)   print(list(pvt[""pvt""]))   # 预计的输出是这样的:   [..., 13834.536889431965, 12892.3866788564, 9255.595248484618, ...]  """"""  pvt = ((df[""close""] - df[""close""].shift(1)) / df[""close""].shift(1) * df[""volume""]).cumsum()  new_df = pd.DataFrame(data=list(pvt), columns=[""pvt""])  return new_df def VOSC(df, short, long):  """"""  移动平均成交量指标 Volume Oscillator  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   short (int): 短周期   long (int): 长周期  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""vosc"", 代表计算出来的移动平均成交量指标  Example::   # 获取 CFFEX.IF1903 合约的移动平均成交量指标   from tqsdk import TqApi, TqAuth   from tqsdk.ta import VOSC   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   vosc = VOSC(klines, 12, 26)   print(list(vosc[""vosc""]))   # 预计的输出是这样的:   [..., 38.72537848731668, 36.61748077024136, 35.4059127302802, ...]  """"""  vosc = (tqsdk.tafunc.ma(df[""volume""], short) - tqsdk.tafunc.ma(df[""volume""], long)) / tqsdk.tafunc.ma(df[""volume""], short) * 100  new_df = pd.DataFrame(data=list(vosc), columns=[""vosc""])  return new_df def VROC(df, n):  """"""  量变动速率  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 参数n  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""vroc"", 代表计算出来的量变动速率  Example::   # 获取 CFFEX.IF1903 合约的量变动速率   from tqsdk import TqApi, TqAuth   from tqsdk.ta import VROC   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   vroc = VROC(klines, 12)   print(list(vroc[""vroc""]))   # 预计的输出是这样的:   [..., 41.69905854184833, 74.03274443327598, 3.549394666873177, ...]  """"""  vroc = (df[""volume""] - df[""volume""].shift(n)) / df[""volume""].shift(n) * 100  new_df = pd.DataFrame(data=list(vroc), columns=[""vroc""])  return new_df def VRSI(df, n):  """"""  量相对强弱  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 参数n  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""vrsi"", 代表计算出来的量相对强弱指标  Example::   # 获取 CFFEX.IF1903 合约的量相对强弱   from tqsdk import TqApi, TqAuth   from tqsdk.ta import VRSI   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   vrsi = VRSI(klines, 6)   print(list(vrsi[""vrsi""]))   # 预计的输出是这样的:   [..., 59.46573277427041, 63.3447660581749, 45.21081537920358, ...]  """"""  vrsi = tqsdk.tafunc.sma(   pd.Series(np.where(df[""volume""] - df[""volume""].shift(1) > 0, df[""volume""] - df[""volume""].shift(1), 0)), n,   1) / tqsdk.tafunc.sma(np.absolute(df[""volume""] - df[""volume""].shift(1)), n, 1) * 100  new_df = pd.DataFrame(data=list(vrsi), columns=[""vrsi""])  return new_df def WVAD(df):  """"""  威廉变异离散量  Args:   df (pandas.DataFrame): Dataframe格式的K线序列  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""wvad"", 代表计算出来的威廉变异离散量  Example::   # 获取 CFFEX.IF1903 合约的威廉变异离散量   from tqsdk import TqApi, TqAuth   from tqsdk.ta import WVAD   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   wvad = WVAD(klines)   print(list(wvad[""wvad""]))   # 预计的输出是这样的:   [..., -32690.203562340674, -42157.968253968385, 32048.182305630264, ...]  """"""  wvad = (df[""close""] - df[""open""]) / (df[""high""] - df[""low""]) * df[""volume""]  new_df = pd.DataFrame(data=list(wvad), columns=[""wvad""])  return new_df def MA(df, n):  """"""  简单移动平均线  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 简单移动平均线的周期  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""ma"", 代表计算出来的简单移动平均线  Example::   # 获取 CFFEX.IF1903 合约的简单移动平均线   from tqsdk import TqApi, TqAuth   from tqsdk.ta import MA   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   ma = MA(klines, 30)   print(list(ma[""ma""]))   # 预计的输出是这样的:   [..., 3436.300000000001, 3452.8733333333344, 3470.5066666666676, ...]  """"""  new_df = pd.DataFrame(data=list(tqsdk.tafunc.ma(df[""close""], n)), columns=[""ma""])  return new_df def SMA(df, n, m):  """"""  扩展指数加权移动平均  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 扩展指数加权移动平均的周期   m (int): 扩展指数加权移动平均的权重  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""sma"", 代表计算出来的扩展指数加权移动平均线  Example::   # 获取 CFFEX.IF1903 合约的扩展指数加权移动平均线   from tqsdk import TqApi, TqAuth   from tqsdk.ta import SMA   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   sma = SMA(klines, 5, 2)   print(list(sma[""sma""]))   # 预计的输出是这样的:   [..., 3803.9478653510914, 3751.648719210655, 3739.389231526393, ...]  """"""  new_df = pd.DataFrame(data=list(tqsdk.tafunc.sma(df[""close""], n, m)), columns=[""sma""])  return new_df def EMA(df, n):  """"""  指数加权移动平均线  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 指数加权移动平均线的周期  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""ema"", 代表计算出来的指数加权移动平均线  Example::   # 获取 CFFEX.IF1903 合约的指数加权移动平均线   from tqsdk import TqApi, TqAuth   from tqsdk.ta import EMA   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   ema = EMA(klines, 10)   print(list(ema[""ema""]))   # 预计的输出是这样的:   [..., 3723.1470497119317, 3714.065767946126, 3715.3265374104667, ...]  """"""  new_df = pd.DataFrame(data=list(tqsdk.tafunc.ema(df[""close""], n)), columns=[""ema""])  return new_df def EMA2(df, n):  """"""  线性加权移动平均 WMA  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 线性加权移动平均的周期  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""ema2"", 代表计算出来的线性加权移动平均线  Example::   # 获取 CFFEX.IF1903 合约的线性加权移动平均线   from tqsdk import TqApi, TqAuth   from tqsdk.ta import EMA2   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   ema2 = EMA2(klines, 10)   print(list(ema2[""ema2""]))   # 预计的输出是这样的:   [..., 3775.832727272727, 3763.334545454546, 3757.101818181818, ...]  """"""  new_df = pd.DataFrame(data=list(tqsdk.tafunc.ema2(df[""close""], n)), columns=[""ema2""])  return new_df def TRMA(df, n):  """"""  三角移动平均线  Args:   df (pandas.DataFrame): Dataframe格式的K线序列   n (int): 三角移动平均线的周期  Returns:   pandas.DataFrame: 返回的DataFrame包含1列, 是""trma"", 代表计算出来的三角移动平均线  Example::   # 获取 CFFEX.IF1903 合约的三角移动平均线   from tqsdk import TqApi, TqAuth   from tqsdk.ta import TRMA   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1903"", 24 * 60 * 60)   trma = TRMA(klines, 10)   print(list(trma[""trma""]))   # 预计的输出是这样的:   [..., 341.366666666669, 3759.160000000002, 3767.7533333333354, ...]  """"""  new_df = pd.DataFrame(data=list(tqsdk.tafunc.trma(df[""close""], n)), columns=[""trma""])  return new_df def BS_VALUE(df, quote, r=0.025, v=None):  """"""  期权 BS 模型理论价格  Args:   df (pandas.DataFrame): 需要计算理论价的期权对应标的合约的 K 线序列，Dataframe 格式   quote (tqsdk.objs.Quote): 需要计算理论价的期权对象，其标的合约应该是 df 序列对应的合约，否则返回序列值全为 nan   r (float): [可选]无风险利率   v (None | float | pandas.Series): [可选]波动率    * None [默认]: 使用 df 中的 close 序列计算的波动率来计算期权理论价格    * float: 对于 df 中每一行都使用相同的 v 计算期权理论价格    * pandas.Series: 其行数应该和 df 行数相同，对于 df 中每一行都使用 v 中对应行的值计算期权理论价格  Returns:   pandas.DataFrame: 返回的 DataFrame 包含 1 列, 是 ""bs_price"", 代表计算出来的期权理论价格, 与参数 df 行数相同  Example1::   from tqsdk import TqApi, TqAuth   from tqsdk.ta import BS_VALUE   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   quote = api.get_quote(""SHFE.cu2006C43000"")   klines = api.get_kline_serial(""SHFE.cu2006"", 24 * 60 * 60, 30)   bs_serise = BS_VALUE(klines, quote, 0.025)   print(list(bs_serise[""bs_price""]))   api.close()   # 预计的输出是这样的:   [..., 3036.698780158862, 2393.333388624822, 2872.607833620801]  Example2::   from tqsdk import TqApi, TqAuth   from tqsdk.ta import BS_VALUE   from tqsdk.tafunc import get_his_volatility   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   ks = api.get_kline_serial(""SHFE.cu2006"", 24 * 60 * 60, 30)   v = get_his_volatility(ks, api.get_quote(""SHFE.cu2006""))   print(""历史波动率:"", v)   quote = api.get_quote(""SHFE.cu2006C43000"")   bs_serise = BS_VALUE(ks, quote, 0.025, v)   print(list(bs_serise[""bs_price""]))   api.close()   # 预计的输出是这样的:   [..., 3036.698780158862, 2393.333388624822, 2872.607833620801]  """"""  if not (quote.ins_class.endswith(""OPTION"") and quote.underlying_symbol == df[""symbol""][0]):   return pd.DataFrame(np.full_like(df[""close""], float('nan')), columns=[""bs_price""])  if v is None:   v = tqsdk.tafunc._get_volatility(df[""close""], df[""duration""], quote.trading_time)   if math.isnan(v):    return pd.DataFrame(np.full_like(df[""close""], float('nan')), columns=[""bs_price""])  t = tqsdk.tafunc._get_t_series(df[""datetime""], df[""duration""], quote.expire_datetime)  return pd.DataFrame(data=list(tqsdk.tafunc.get_bs_price(df[""close""], quote.strike_price, r, v, t, quote.option_class)),       columns=[""bs_price""]) def OPTION_GREEKS(df, quote, r=0.025, v=None):  """"""  期权希腊指标  Args:   df (pandas.DataFrame): 期权合约及对应标的合约组成的多 K 线序列, Dataframe 格式    对于参数 df，需要用 api.get_kline_serial() 获取多 K 线序列，第一个参数为 list 类型，顺序为期权合约在前，对应标的合约在后，否则返回序列值全为 nan。    例如：api.get_kline_serial([""SHFE.cu2006C44000"", ""SHFE.cu2006""], 60, 100)   quote (tqsdk.objs.Quote): 期权对象，应该是 df 中多 K 线序列中的期权合约对象，否则返回序列值全为 nan。    例如：api.get_quote(""SHFE.cu2006C44000"")   r (float): [可选]无风险利率   v (None | float | pandas.Series): [可选]波动率    * None [默认]: 使用 df 序列计算出的隐含波动率计算希腊指标值    * float: 对于 df 中每一行都使用相同的 v 计算希腊指标值    * pandas.Series: 其行数应该和 df 行数相同，对于 df 中每一行都使用 v 中对应行的值计算希腊指标值  Returns:   pandas.DataFrame: 返回的 DataFrame 包含 5 列, 分别是 ""delta"", ""theta"", ""gamma"", ""vega"", ""rho"", 与参数 df 行数相同  Example::   from tqsdk import TqApi, TqAuth   from tqsdk.ta import OPTION_GREEKS   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   quote = api.get_quote(""SHFE.cu2006C44000"")   klines = api.get_kline_serial([""SHFE.cu2006C44000"", ""SHFE.cu2006""], 24 * 60 * 60, 30)   greeks = OPTION_GREEKS(klines, quote, 0.025)   print(list(greeks[""delta""]))   print(list(greeks[""theta""]))   print(list(greeks[""gamma""]))   print(list(greeks[""vega""]))   print(list(greeks[""rho""]))   api.close()  """"""  new_df = pd.DataFrame()  if not (quote.ins_class.endswith(""OPTION"") and quote.instrument_id == df[""symbol""][0] and quote.underlying_symbol == df[""symbol1""][0]):   new_df[""delta""] = pd.Series(np.full_like(df[""close1""], float('nan')))   new_df[""theta""] = pd.Series(np.full_like(df[""close1""], float('nan')))   new_df[""gamma""] = pd.Series(np.full_like(df[""close1""], float('nan')))   new_df[""vega""] = pd.Series(np.full_like(df[""close1""], float('nan')))   new_df[""rho""] = pd.Series(np.full_like(df[""close1""], float('nan')))  else:   t = tqsdk.tafunc._get_t_series(df[""datetime""], df[""duration""], quote.expire_datetime) # 到期时间   if v is None:    v = tqsdk.tafunc.get_impv(df[""close1""], df[""close""], quote.strike_price, r, 0.3, t, quote.option_class)   d1 = tqsdk.tafunc._get_d1(df[""close1""], quote.strike_price, r, v, t)   new_df[""delta""] = tqsdk.tafunc.get_delta(df[""close1""], quote.strike_price, r, v, t, quote.option_class, d1)   new_df[""theta""] = tqsdk.tafunc.get_theta(df[""close1""], quote.strike_price, r, v, t, quote.option_class, d1)   new_df[""gamma""] = tqsdk.tafunc.get_gamma(df[""close1""], quote.strike_price, r, v, t, d1)   new_df[""vega""] = tqsdk.tafunc.get_vega(df[""close1""], quote.strike_price, r, v, t, d1)   new_df[""rho""] = tqsdk.tafunc.get_rho(df[""close1""], quote.strike_price, r, v, t, quote.option_class, d1)  return new_df def OPTION_VALUE(df, quote):  """"""  期权内在价值，时间价值  Args:   df (pandas.DataFrame): 期权合约及对应标的合约组成的多 K 线序列, Dataframe 格式    对于参数 df，需要用 api.get_kline_serial() 获取多 K 线序列，第一个参数为 list 类型，顺序为期权合约在前，对应标的合约在后，否则返回序列值全为 nan。    例如：api.get_kline_serial([""SHFE.cu2006C44000"", ""SHFE.cu2006""], 60, 100)   quote (tqsdk.objs.Quote): 期权对象，应该是 df 中多 K 线序列中的期权合约对象，否则返回序列值全为 nan。    例如：api.get_quote(""SHFE.cu2006C44000"")  Returns:   pandas.DataFrame: 返回的 DataFrame 包含 2 列, 是 ""intrins"" 和 ""time"", 代表内在价值和时间价值, 与参数 df 行数相同  Example::   from tqsdk import TqApi, TqAuth   from tqsdk.ta import OPTION_VALUE   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   quote = api.get_quote(""SHFE.cu2006C43000"")   klines = api.get_kline_serial([""SHFE.cu2006C43000"", ""SHFE.cu2006""], 24 * 60 * 60, 30)   values = OPTION_VALUE(klines, quote)   print(list(values[""intrins""]))   print(list(values[""time""]))   api.close()  """"""  new_df = pd.DataFrame()  if not (quote.ins_class.endswith(""OPTION"") and quote.instrument_id == df[""symbol""][0]    and quote.underlying_symbol == df[""symbol1""][0]):   new_df[""intrins""] = pd.Series(np.full_like(df[""close1""], float('nan')))   new_df[""time""] = pd.Series(np.full_like(df[""close1""], float('nan')))  else:   o = 1 if quote.option_class == ""CALL"" else -1   intrins = o * (df[""close1""] - quote.strike_price)   new_df[""intrins""] = pd.Series(np.where(intrins > 0.0, intrins, 0.0))   new_df[""time""] = pd.Series(df[""close""] - new_df[""intrins""])  return new_df def OPTION_IMPV(df, quote, r=0.025):  """"""  计算期权隐含波动率  Args:   df (pandas.DataFrame): 期权合约及对应标的合约组成的多 K 线序列, Dataframe 格式    对于参数 df，需要用 api.get_kline_serial() 获取多 K 线序列，第一个参数为 list 类型，顺序为期权合约在前，对应标的合约在后，否则返回序列值全为 nan。    例如：api.get_kline_serial([""SHFE.cu2006C44000"", ""SHFE.cu2006""], 60, 100)   quote (tqsdk.objs.Quote): 期权对象，应该是 df 中多 K 线序列中的期权合约对象，否则返回序列值全为 nan。    例如：api.get_quote(""SHFE.cu2006C44000"")   r (float): [可选]无风险利率  Returns:   pandas.DataFrame: 返回的 DataFrame 包含 1 列, 是 ""impv"", 与参数 df 行数相同  Example::   from tqsdk import TqApi, TqAuth   from tqsdk.ta import OPTION_IMPV   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   quote = api.get_quote(""SHFE.cu2006C50000"")   klines = api.get_kline_serial([""SHFE.cu2006C50000"", ""SHFE.cu2006""], 24 * 60 * 60, 20)   impv = OPTION_IMPV(klines, quote, 0.025)   print(list(impv[""impv""] * 100))   api.close()  """"""  if not (quote.ins_class.endswith(""OPTION"") and quote.instrument_id == df[""symbol""][0] and quote.underlying_symbol == df[""symbol1""][0]):   return pd.DataFrame(np.full_like(df[""close1""], float('nan')), columns=[""impv""])  his_v = tqsdk.tafunc._get_volatility(df[""close1""], df[""duration""], quote.trading_time)  his_v = 0.3 if math.isnan(his_v) else his_v  t = tqsdk.tafunc._get_t_series(df[""datetime""], df[""duration""], quote.expire_datetime) # 到期时间  return pd.DataFrame(   data=list(tqsdk.tafunc.get_impv(df[""close1""], df[""close""], quote.strike_price, r, his_v, t, quote.option_class)),   columns=[""impv""]) def VOLATILITY_CURVE(df: pd.DataFrame, quotes: dict, underlying: str, r=0.025):  """"""  计算期权隐含波动率曲面  Args:   df (pandas.DataFrame): 期权合约及基础标合约组成的多 K 线序列, Dataframe 格式   quote (dict): 批量获取合约的行情信息, 存储结构必须为 dict, key 为合约, value 为行情数据     例如: {'SHFE.cu2101':{ ... }, ‘SHFE.cu2101C34000’:{ ... }}   underlying (str): 基础标的的合约名称, 如 SHFE.cu2101   r (float): [可选]无风险利率  Returns:   pandas.DataFrame: 返回的 DataFrame  Example::   from tqsdk import TqApi, TqAuth   from tqsdk.ta import VOLATILITY_CURVE   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   underlying = ""DCE.m2101""   options = api.query_options(underlying_symbol=underlying, option_class=""PUT"", expired=False)   # 批量获取合约的行情信息, 存储结构必须为 dict, key 为合约, value 为行情数据   quote = {}   for symbol in options:    quote[symbol] = api.get_quote(symbol)   options.append(underlying)   klines = api.get_kline_serial(options, 24 * 60 * 60, 20)   vc = VOLATILITY_CURVE(klines, quote, underlying, r = 0.025)   print(vc)   api.close()   # 预计的输出是这样的:     datetime 2450.0 2500.0 ... 3600.0 3650.0   0 1.603382e+18 0.336557 0.314832 ... 0.231657 0.237882   1 1.603642e+18 0.353507 0.331051 ... 0.231657 0.237882  """"""  symbol_titles = [s for s in df.columns.values if s.startswith(""symbol"")]  base_symbol_title = [s for s in symbol_titles if df[s].iloc[0] == underlying]  if not base_symbol_title:   raise Exception(f""kline 数据中未包含基础标的合约的K线数据, 请更正"")  base_close_title = f'close{base_symbol_title[0][6:]}'  res_dict = {} # 波动率曲线数据结构 {'datetime':[], $strike_price:[]}  pd_columns = [] # pd.DataFrame 列  for symbol_title in symbol_titles:   if symbol_title == base_symbol_title[0]:    continue   close_title = f'close{symbol_title[6:]}'   quote = quotes[df[symbol_title].iloc[0]]   t = tqsdk.tafunc._get_t_series(df[""datetime""], df[""duration""], quote.expire_datetime)   res_dict[quote.strike_price] = tqsdk.tafunc.get_impv(df[base_close_title],                df[close_title], quote.strike_price, r, 0.5, t,                quote.option_class).interpolate(method='linear')   res_dict['datetime'] = df[""datetime""]   pd_columns.append(quote.strike_price)  pd_columns.sort()  pd_columns.insert(0, ""datetime"")  return pd.DataFrame(data=res_dict, columns=pd_columns) "
101,n\tqsdk\tafun,"n\tqsdk\tafun. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' from pandas import Series """""" tqsdk.tafunc 模块包含了一批用于技术指标计算的函数 (函数基本保持 参数为pandas.Series类型则返回值为pandas.Series类型) """""" import datetime import math from typing import Union import numpy as np import pandas as pd from scipy import stats from tqsdk.datetime import _get_period_timestamp, _str_to_timestamp_nano, _datetime_to_timestamp_nano def ref(series, n):  """"""  简单移动: 求series序列位移n个周期的结果   注意: 当n为0, 函数返回原序列; 当n为有效值但当前的series序列元素个数不足 n + 1 个, 函数返回 NaN 序列  Args:   series (pandas.Series): 数据序列   n (int): 位移周期  Returns:   pandas.Series: 位移后的序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   pre_close = tafunc.ref(klines.close, 1) # 将收盘价序列右移一位, 得到昨收盘序列   change = klines.close - pre_close  # 收盘价序列 - 昨收盘序列, 得到涨跌序列   print(list(change))  """"""  m = series.shift(n)  return m def std(series, n):  """"""  标准差: 求series序列每n个周期的标准差   注意: n为0的情况下, 或当n为有效值但当前的series序列元素个数不足n个, 函数返回 NaN 序列  Args:   series (pandas.Series): 数据序列   n (int): 标准差的周期  Returns:   pandas.Series: 标准差序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   std = tafunc.std(klines.close, 5) # 收盘价序列每5项计算一个标准差   print(list(std))  """"""  m = series.rolling(n).std()  return m def ma(series, n):  """"""  简单移动平均线: 求series序列n周期的简单移动平均   计算公式:   ma(x, 5) = (x(1) + x(2) + x(3) + x(4) + x(5)) / 5   注意:   1. 简单移动平均线将设定周期内的值取平均值, 其中各元素的权重都相等   2. n为0的情况下, 或当n为有效值但当前的series序列元素个数不足n个, 函数返回 NaN 序列  Args:   series (pandas.Series): 数据序列   n (int): 周期  Returns:   pandas.Series: 简单移动平均值序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   ma = tafunc.ma(klines.close, 5)   print(list(ma))  """"""  ma_data = series.rolling(n).mean()  return ma_data def sma(series, n, m):  """"""  扩展指数加权移动平均: 求series序列n周期的扩展指数加权移动平均    计算公式:   sma(x, n, m) = sma(x, n, m).shift(1) * (n - m) / n + x(n) * m / n     注意: n必须大于m  Args:   series (pandas.Series): 数据序列     n (int): 周期     m (int): 权重  Returns:   pandas.Series: 扩展指数加权移动平均序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   sma = tafunc.sma(klines.close, 5, 2) # 收盘价序列每5项计算一个扩展指数加权移动平均值   print(list(sma))  """"""  sma_data = series.ewm(alpha=m / n, adjust=False).mean()  return sma_data def ema(series, n):  """"""  指数加权移动平均线: 求series序列n周期的指数加权移动平均   计算公式:    ema(x, n) = 2 * x / (n + 1) + (n - 1) * ema(x, n).shift(1) / (n + 1)   注意:    1. n 需大于等于1    2. 对距离当前较近的k线赋予了较大的权重  Args:   series (pandas.Series): 数据序列   n (int): 周期  Returns:   pandas.Series: 指数加权移动平均线序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   ema = tafunc.ema(klines.close, 5)   print(list(ema))  """"""  ema_data = series.ewm(span=n, adjust=False).mean()  return ema_data def ema2(series, n):  """"""  线性加权移动平均: 求series值的n周期线性加权移动平均 (也称WMA)   计算公式:    ema2(x, n) = [n * x(0) + (n - 1) * x(1) + (x - 2) * x(2) + ... + 1 * x(n - 1)] / [n + (n - 1) + (n - 2) + ... + 1]   注意: 当n为有效值但当前的series序列元素个数不足n个, 函数返回 NaN 序列  Args:   series (pandas.Series): 数据序列   n (int): 周期  Returns:   pandas.Series: 线性加权移动平均线序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   ema2 = tafunc.ema2(klines.close, 5) # 求收盘价在5个周期的线性加权移动平均值   print(list(ema2))  """"""  weights = list(i for i in range(1, n + 1)) # 对应的权值列表  def average(elements):   return np.average(elements, weights=weights)  ema2 = series.rolling(window=n).apply(average, raw=True)  return ema2 def crossup(a, b):  """"""  向上穿越: 表当a从下方向上穿过b, 成立返回1, 否则返回0  Args:   a (pandas.Series): 数据序列1   b (pandas.Series): 数据序列2  Returns:   pandas.Series: 上穿标志序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   crossup = tafunc.crossup(tafunc.ma(klines.close, 5), tafunc.ma(klines.close, 10))   print(list(crossup))  """"""  crossup_data = pd.Series(np.where((a > b) & (a.shift(1) <= b.shift(1)), 1, 0))  return crossup_data def crossdown(a, b):  """"""  向下穿越: 表示当a从上方向下穿b，成立返回1, 否则返回0  Args:   a (pandas.Series): 数据序列1   b (pandas.Series): 数据序列2  Returns:   pandas.Series: 下穿标志序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc     api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   crossdown = tafunc.crossdown(tafunc.ma(klines.close, 5), tafunc.ma(klines.close, 10))   print(list(crossdown))  """"""  crossdown_data = pd.Series(np.where((a < b) & (a.shift(1) >= b.shift(1)), 1, 0))  return crossdown_data def count(cond, n):  """"""  统计n周期中满足cond条件的个数   注意: 如果n为0, 则从第一个有效值开始统计  Args:   cond (array_like): 条件   n (int): 周期  Returns:   pandas.Series: 统计值序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   # 统计从申请到的行情数据以来到当前这段时间内, 5周期均线上穿10周期均线的次数:   count = tafunc.count(tafunc.crossup(tafunc.ma(klines.close, 5), tafunc.ma(klines.close, 10)), 0)   print(list(count))  """"""  if n == 0: # 从第一个有效值开始统计   count_data = pd.Series(np.where(cond, 1, 0).cumsum())  else: # 统计每个n周期   count_data = pd.Series(pd.Series(np.where(cond, 1, 0)).rolling(n).sum())  return count_data def trma(series, n):  """"""  三角移动平均: 求series的n周期三角移动平均值   计算方法:    三角移动平均线公式, 是采用算数移动平均, 并且对第一个移动平均线再一次应用算数移动平均   注意: n为0的情况下, 或当n为有效值但当前的series序列元素个数不足n个, 函数返回 NaN 序列  Args:   series (pandas.Series): 数据序列   n (int): 周期  Returns:   pandas.Series: 三角移动平均值序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   trma = tafunc.trma(klines.close, 10)   print(list(trma))  """"""  if n % 2 == 0:   n1 = int(n / 2)   n2 = int(n / 2 + 1)  else:   n1 = n2 = int((n + 1) / 2)  ma_half = ma(series, n1)  trma_data = ma(ma_half, n2)  return trma_data def harmean(series, n):  """"""  调和平均值: 求series在n个周期内的调和平均值   计算方法:    harmean(x, 5) = 1 / [(1 / x(1) + 1 / x(2) + 1 / x(3) + 1 / x(4) + 1 / x(5)) / 5]   注意:   1. 调和平均值与倒数的简单平均值互为倒数   2. 当n为0, 或当n为有效值但当前的series序列元素个数不足n个, 函数返回 NaN 序列  Args:   series (pandas.Series): 数据序列   n (int): 周期  Returns:   pandas.Series: 调和平均值序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   harmean = tafunc.harmean(klines.close, 5) # 求5周期收盘价的调和平均值   print(list(harmean))  """"""  harmean_data = n / ((1 / series).rolling(n).sum())  return harmean_data def numpow(series, n, m):  """"""  自然数幂方和   计算方法:    numpow(x, n, m) = n ^ m * x + (n - 1) ^ m * x.shift(1) + (n - 2) ^ m * x.shift(2) + ... + 2 ^ m * x.shift(n - 2) + 1 ^ m * x.shift(n - 1)   注意: 当n为有效值但当前的series序列元素个数不足n个, 函数返回 NaN 序列  Args:   series (pandas.Series): 数据序列   n (int): 自然数   m (int): 实数  Returns:   pandas.Series: 幂方和序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   numpow = tafunc.numpow(klines.close, 5, 2)   print(list(numpow))  """"""  numpow_data = sum((n - i) ** m * series.shift(i) for i in range(n))  return numpow_data def abs(series):  """"""  获取series的绝对值   注意: 正数的绝对值是它本身, 负数的绝对值是它的相反数, 0的绝对值还是0  Args:   series (pandas.Series): 数据序列  Returns:   pandas.Series: 绝对值序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   abs = tafunc.abs(klines.close)   print(list(abs))  """"""  abs_data = pd.Series(np.absolute(series))  return abs_data def min(series1, series2):  """"""  获取series1和series2中的最小值  Args:   series1 (pandas.Series): 数据序列1   series2 (pandas.Series): 数据序列2  Returns:   pandas.Series: 最小值序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   min = tafunc.min(klines.close, klines.open)   print(list(min))  """"""  min_data = np.minimum(series1, series2)  return min_data def max(series1, series2):  """"""  获取series1和series2中的最大值  Args:   series1 (pandas.Series): 数据序列1   series2 (pandas.Series): 数据序列2  Returns:   pandas.Series: 最大值序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   max = tafunc.max(klines.close, klines.open)   print(list(max))  """"""  max_data = np.maximum(series1, series2)  return max_data def median(series, n):  """"""  中位数: 求series在n个周期内居于中间的数值    注意:    1. 当n为有效值但当前的series序列元素个数不足n个, 函数返回 NaN 序列    2. 对n个周期内所有series排序后, 若n为奇数, 则选择第(n + 1) / 2个为中位数, 若n为偶数, 则中位数是(n / 2)以及(n / 2 + 1)的平均数  Args:   series (pandas.Series): 数据序列   n (int): 周期  Returns:   pandas.Series: 中位数序列  Example::   例1:    # 假设最近3日的收盘价为2727, 2754, 2748, 那么当前 median(df[""close""], 3) 的返回值是2748    median3 = tafunc.median(df[""close""], 3)   例2:    # 假设最近4日的开盘价为2752, 2743, 2730, 2728, 那么当前 median(df[""open""], 4) 的返回值是2736.5    median4 = tafunc.median(df[""open""], 4)  """"""  median_data = series.rolling(n).median()  return median_data def exist(cond, n):  """"""  判断n个周期内, 是否有满足cond的条件, 若满足则值为1, 不满足为0  Args:   cond (array_like): 条件   n (int): 周期  Returns:   pandas.Series: 判断结果序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   # 判断4个周期中是否存在收盘价大于前一个周期的最高价, 存在返回1, 不存在则返回0   exist = tafunc.exist(klines.close > klines.high.shift(1), 4)   print(list(exist))  """"""  exist_data = pd.Series(np.where(pd.Series(np.where(cond, 1, 0)).rolling(n).sum() > 0, 1, 0))  return exist_data def every(cond, n):  """"""  判断n个周期内, 是否一直满足cond条件, 若满足则值为1, 不满足为0  Args:   cond (array_like): 条件   n (int): 周期  Returns:   pandas.Series: 判断结果序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   # 判断在4周期内, 3周期的简单移动平均是否一直大于5周期的简单移动平均   every = tafunc.every(tafunc.ma(klines.close, 3) > tafunc.ma(klines.close, 5), 4)   print(list(every))  """"""  every_data = pd.Series(np.where(pd.Series(np.where(cond, 1, 0)).rolling(n).sum() == n, 1, 0))  return every_data def hhv(series, n):  """"""  求series在n个周期内的最高值   注意: n为0的情况下, 或当n为有效值但当前的series序列元素个数不足n个, 函数返回 NaN 序列  Args:   series (pandas.Series): 数据序列   n (int): 周期  Returns:   pandas.Series: 最高值序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   hhv = tafunc.hhv(klines.high, 4) # 求4个周期最高价的最大值, 即4周期高点(包含当前k线)   print(list(hhv))  """"""  hhv_data = series.rolling(n).max()  return hhv_data def llv(series, n):  """"""  求在n个周期内的最小值   注意: n为0的情况下, 或当n为有效值但当前的series序列元素个数不足n个, 函数返回 NaN 序列  Args:   series (pandas.Series): 数据序列   n (int): 周期  Returns:   pandas.Series: 最小值序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   llv = tafunc.llv(klines.low, 5) # 求5根k线最低点(包含当前k线)   print(list(llv))  """"""  llv_data = series.rolling(n).min()  return llv_data def avedev(series, n):  """"""  平均绝对偏差: 求series在n周期内的平均绝对偏差   算法:    计算avedev(df[""close""],3)在最近一根K线上的值:    (abs(df[""close""] - (df[""close""] + df[""close""].shift(1) + df[""close""].shift(2)) / 3) + abs(    df[""close""].shift(1) - (df[""close""] + df[""close""].shift(1) + df[""close""].shift(2)) / 3) + abs(    df[""close""].shift(2) - (df[""close""] + df[""close""].shift(1) + df[""close""].shift(2)) / 3)) / 3   注意: n为0的情况下, 或当n为有效值但当前的series序列元素个数不足n个, 函数返回 NaN 序列  Args:   series (pandas.Series): 数据序列   n (int): 周期  Returns:   pandas.Series: 平均绝对偏差序列  Example::   from tqsdk import TqApi, TqAuth, TqSim, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""CFFEX.IF1908"", 24 * 60 * 60)   # 计算收盘价在5周期内的平均绝对偏差, 表示5个周期内每个周期的收盘价与5周期收盘价的平均值的差的绝对值的平均值, 判断收盘价与其均值的偏离程度:   avedev = tafunc.avedev(klines.close, 5)   print(list(avedev))  """"""  def mad(x):   return np.fabs(x - x.mean()).mean()  avedev_data = series.rolling(window=n).apply(mad, raw=True)  return avedev_data def _to_ns_timestamp(input_time):  """"""  辅助函数: 将传入的时间转换为int类型的纳秒级时间戳  Args:  input_time (str/ int/ float/ datetime.datetime): 需要转换的时间:   * str: str 类型的时间，如Quote行情时间的datetime字段 (eg. 2019-10-14 14:26:01.000000)   * int: int 类型纳秒级或秒级时间戳   * float: float 类型纳秒级或秒级时间戳，如K线或tick的datetime字段 (eg. 1.57103449e+18)   * datetime.datetime: datetime 模块中 datetime 类型  Returns:   int : int 类型纳秒级时间戳  """"""  if type(input_time) in {int, float, np.float64, np.float32, np.int64, np.int32}: # 时间戳   if input_time > 2 ** 32: # 纳秒( 将 > 2*32数值归为纳秒级)    return int(input_time)   else: # 秒    return int(input_time * 1e9)  elif isinstance(input_time, str): # str 类型时间   return _str_to_timestamp_nano(input_time)  elif isinstance(input_time, datetime.datetime): # datetime 类型时间   return _datetime_to_timestamp_nano(input_time)  else:   raise TypeError(""暂不支持此类型的转换"") def time_to_ns_timestamp(input_time):  """"""  将传入的时间转换为int类型的纳秒级时间戳  Args:   input_time (str/ int/ float/ datetime.datetime): 需要转换的时间:    * str: str 类型的时间，如Quote行情时间的datetime字段 (eg. 2019-10-14 14:26:01.000000)    * int: int 类型的纳秒级或秒级时间戳    * float: float 类型的纳秒级或秒级时间戳，如K线或tick的datetime字段 (eg. 1.57103449e+18)    * datetime.datetime: datetime 模块中的 datetime 类型时间  Returns:   int : int 类型的纳秒级时间戳  Example::   from tqsdk.tafunc import time_to_ns_timestamp   print(time_to_ns_timestamp(""2019-10-14 14:26:01.000000"")) # 将%Y-%m-%d %H:%M:%S.%f 格式的str类型转为纳秒时间戳   print(time_to_ns_timestamp(1571103122)) # 将秒级转为纳秒时间戳   print(time_to_ns_timestamp(datetime.datetime(2019, 10, 14, 14, 26, 1))) # 将datetime.datetime时间转为纳秒时间戳  """"""  return _to_ns_timestamp(input_time) def time_to_s_timestamp(input_time):  """"""  将传入的时间转换为int类型的秒级时间戳  Args:   input_time (str/ int/ float/ datetime.datetime): 需要转换的时间:    * str: str 类型的时间，如Quote行情时间的datetime字段 (eg. 2019-10-14 14:26:01.000000)    * int: int 类型的纳秒级或秒级时间戳    * float: float 类型的纳秒级或秒级时间戳，如K线或tick的datetime字段 (eg. 1.57103449e+18)    * datetime.datetime: datetime 模块中的 datetime 类型时间  Returns:   int : int类型的秒级时间戳  Example::   from tqsdk.tafunc import time_to_s_timestamp   print(time_to_s_timestamp(1.57103449e+18)) # 将纳秒级时间戳转为秒级时间戳   print(time_to_s_timestamp(""2019-10-14 14:26:01.000000"")) # 将%Y-%m-%d %H:%M:%S.%f 格式的str类型时间转为秒级时间戳   print(time_to_s_timestamp(datetime.datetime(2019, 10, 14, 14, 26, 1))) # 将datetime.datetime时间转为秒时间戳  """"""  return int(_to_ns_timestamp(input_time) / 1e9) def time_to_str(input_time):  """"""  将传入的时间转换为 %Y-%m-%d %H:%M:%S.%f 格式的 str 类型  Args:   input_time (int/ float/ datetime.datetime): 需要转换的时间:    * int: int 类型的纳秒级或秒级时间戳    * float: float 类型的纳秒级或秒级时间戳，如K线或tick的datetime字段 (eg. 1.57103449e+18)    * datetime.datetime: datetime 模块中的 datetime 类型时间  Returns:   str : %Y-%m-%d %H:%M:%S.%f 格式的 str 类型时间  Example::   from tqsdk.tafunc import time_to_str   print(time_to_str(1.57103449e+18)) # 将纳秒级时间戳转为%Y-%m-%d %H:%M:%S.%f 格式的str类型时间   print(time_to_str(1571103122)) # 将秒级时间戳转为%Y-%m-%d %H:%M:%S.%f 格式的str类型时间   print(time_to_str(datetime.datetime(2019, 10, 14, 14, 26, 1))) # 将datetime.datetime时间转为%Y-%m-%d %H:%M:%S.%f 格式的str类型时间  """"""  # 转为秒级时间戳  ts = _to_ns_timestamp(input_time) / 1e9  # 转为 %Y-%m-%d %H:%M:%S.%f 格式的 str 类型时间  dt = datetime.datetime.fromtimestamp(ts)  dt = dt.strftime('%Y-%m-%d %H:%M:%S.%f')  return dt def time_to_datetime(input_time):  """"""  将传入的时间转换为 datetime.datetime 类型  Args:   input_time (int/ float/ str): 需要转换的时间:    * int: int 类型的纳秒级或秒级时间戳    * float: float 类型的纳秒级或秒级时间戳，如K线或tick的datetime字段 (eg. 1.57103449e+18)    * str: str 类型的时间，如Quote行情时间的 datetime 字段 (eg. 2019-10-14 14:26:01.000000)  Returns:   datetime.datetime : datetime 模块中的 datetime 类型时间  Example::   from tqsdk.tafunc import time_to_datetime   print(time_to_datetime(1.57103449e+18)) # 将纳秒级时间戳转为datetime.datetime时间   print(time_to_datetime(1571103122)) # 将秒级时间戳转为datetime.datetime时间   print(time_to_datetime(""2019-10-14 14:26:01.000000"")) # 将%Y-%m-%d %H:%M:%S.%f 格式的str类型时间转为datetime.datetime时间  """"""  # 转为秒级时间戳  ts = _to_ns_timestamp(input_time) / 1e9  # 转为datetime.datetime类型  dt = datetime.datetime.fromtimestamp(ts)  return dt def barlast(cond):  """"""  返回一个序列，其中每个值表示从上一次条件成立到当前的周期数  (注： 如果从cond序列第一个值到某个位置之间没有True，则此位置的返回值为 -1； 条件成立的位置上的返回值为0)  Args:   cond (pandas.Series): 条件序列(序列中的值需为 True 或 False)  Returns:   pandas.Series : 周期数序列（其长度和 cond 相同；最后一个值即为最后一次条件成立到最新一个数据的周期数）  Example::   from tqsdk import TqApi, TqAuth   from tqsdk.tafunc import barlast   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   klines = api.get_kline_serial(""SHFE.cu1912"", 60)   # print(list(klines.close))   # print(list(klines.open))   # print(list(klines.close > klines.open))   n = barlast(klines.close > klines.open) # 获取周期数序列   print(list(n))   print(n.iloc[-1]) # 获取最后一根k线到上一次满足 ""收盘价大于开盘价"" 条件的k线的周期数   api.close()  """"""  cond = cond.to_numpy()  v = np.array(~cond, dtype=np.int)  c = np.cumsum(v)  x = c[cond]  d = np.diff(np.concatenate(([0], x)))  if len(d) == 0: # 如果cond长度为0或无True   return pd.Series([-1] * len(cond))  v[cond] = -d  r = np.cumsum(v)  r[:x[0]] = -1  return pd.Series(r) def _get_t_series(series: pd.Series, dur: int, expire_datetime: int):  t = pd.Series(pd.to_timedelta(expire_datetime - (series / 1e9 + dur), unit='s'))  return (t.dt.days * 86400 + t.dt.seconds) / (360 * 86400) def _get_d1(series: pd.Series, k: float, r: float, v: Union[float, pd.Series], t: Union[float, pd.Series]):  return pd.Series(   np.where((v <= 0) | (t <= 0), np.nan, (np.log(series / k) + (r + 0.5 * np.power(v, 2)) * t) / (v * np.sqrt(t)))) def _get_cdf(series: pd.Series):  s = series.loc[series.notna()]  return pd.concat([series.loc[series.isna()], pd.Series(stats.norm.cdf(s), index=s.index)], verify_integrity=True) def _get_pdf(series: pd.Series):  s = series.loc[series.notna()]  return pd.concat([series.loc[series.isna()], pd.Series(stats.norm.pdf(s), index=s.index)], verify_integrity=True) def _get_options_class(series: pd.Series, option_class: Union[str, pd.Series]):  """"""  根据价格序列 series，和指定的 option_class  Args:   option_class (str / Series[str]): CALL / PUT / Series(['CALL', 'CALL', 'CALL', 'PUT'])  Returns:   Series[int] : 长度和 series 一致，Series([1, 1, 1, 1]) / Series([-1, -1, -1, -1]) / Series([1, 1, 1, -1]), 对于无效的参数值为 Series([nan, nan, nan, nan])  """"""  if type(option_class) is str and option_class in [""CALL"", ""PUT""]:   return Series([(1 if option_class == ""CALL"" else -1) for _ in range(series.size)])  elif type(option_class) is Series and series.size == option_class.size:   return option_class.map({'CALL': 1, 'PUT': -1})  else:   return Series([float('nan') for _ in range(series.size)]) def get_t(df, expire_datetime):  """"""  计算 K 线序列对应的年化到期时间，主要用于计算期权相关希腊指标时，需要得到计算出序列对应的年化到期时间  Args:   df (pandas.DataFrame): Dataframe 格式的 K 线序列   expire_datetime (int): 到期日, 秒级时间戳  Returns:   pandas.Series : 返回的 df 对应的年化时间序列  Example::   from tqsdk import TqApi, TqAuth, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   quote = api.get_quote('SHFE.cu2006C45000')   klines = api.get_kline_serial(['SHFE.cu2006C45000', 'SHFE.cu2006'], 24 * 60 * 60, 50)   t = tafunc.get_t(klines, quote.expire_datetime)   print(t)   api.close()  """"""  return pd.Series(_get_t_series(df[""datetime""], df[""duration""], expire_datetime)) def get_his_volatility(df, quote):  """"""  计算某个合约的历史波动率  Args:   df (pandas.DataFrame): Dataframe 格式的 K 线序列   quote (tqsdk.objs.Quote): df 序列对应合约对象  Returns:   float : 返回的 df 对应的历史波动率  Example::   from tqsdk import TqApi, TqAuth, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   quote = api.get_quote('SHFE.cu2006')   klines = api.get_kline_serial('SHFE.cu2006', 24 * 60 * 60, 50)   v = tafunc.get_his_volatility(klines, quote)   print(v)   api.close()  """"""  if quote and quote.instrument_id == df[""symbol""][0]:   trading_time = quote.trading_time  else:   trading_time = None  return _get_volatility(df[""close""], df[""duration""], trading_time) def _get_volatility(series: pd.Series, dur: Union[pd.Series, int] = 86400, trading_time: list = None) -> float:  series_u = np.log(series.shift(1)[1:] / series[1:])  series_u = series_u[~np.isnan(series_u)]  if series_u.size < 2: # 自由度小于2无法计算，返回一个默认值   return float(""nan"")  seconds_per_day = 24 * 60 * 60  dur = dur[0] if isinstance(dur, pd.Series) else dur  if dur < 24 * 60 * 60 and trading_time:   periods = _get_period_timestamp(0, trading_time.get(""day"", []) + trading_time.get(""night"", []))   seconds_per_day = sum([p[1] - p[0] for p in periods]) / 1e9  return math.sqrt((250 * seconds_per_day / dur) * np.cov(series_u)) def get_bs_price(series, k, r, v, t, option_class):  """"""  计算期权 BS 模型理论价格  Args:   series (pandas.Series): 标的价格序列   k (float): 期权行权价   r (float): 无风险利率   v (float / pandas.Series): 波动率    * float: 对于 series 中每个元素都使用相同的 v 计算理论价    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 v 中对应的值计算理论价   t (float / pandas.Series): 年化到期时间，例如：还有 100 天到期，则年化到期时间为 100/360    * float: 对于 series 中每个元素都使用相同的 t 计算理论价    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 t 中对应的值计算理论价   option_class (str / pandas.Series): 期权方向，必须是两者其一，否则返回的序列值全部为 nan    * str: ""CALL"" 或者 ""PUT""    * pandas.Series: 其元素个数应该和 series 元素个数相同，每个元素的值为 ""CALL"" 或者 ""PUT""  Returns:   pandas.Series: 返回该序列理论价  Example::   import pandas as pd   from tqsdk import TqApi, TqAuth, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   quote = api.get_quote(""SHFE.cu2006"")   ks = api.get_kline_serial(""SHFE.cu2006"", 24 * 60 * 60, 10)   v = tafunc.get_his_volatility(ks, quote) # 历史波动率   option = api.get_quote(""SHFE.cu2006C45000"")   klines = api.get_kline_serial([""SHFE.cu2006C45000"", ""SHFE.cu2006""], 24 * 60 * 60, 10)   t = tafunc.get_t(klines, option.expire_datetime)   bs_price = tafunc.get_bs_price(klines[""close1""], 45000, 0.025, v, t, option.option_class) # 理论价   print(list(bs_price.round(2)))   api.close()  """"""  o = _get_options_class(series, option_class=option_class)  d1 = _get_d1(series, k, r, v, t)  d2 = pd.Series(np.where(np.isnan(d1), np.nan, d1 - v * np.sqrt(t)))  return pd.Series(   np.where(np.isnan(d1), np.nan, o * (series * _get_cdf(o * d1) - k * np.exp(-r * t) * _get_cdf(o * d2)))) def get_delta(series, k, r, v, t, option_class, d1=None):  """"""  计算期权希腊指标 delta 值  Args:   series (pandas.Series): 标的价格序列   k (float): 期权行权价   r (float): 无风险利率   v (float / pandas.Series): 波动率    * float: 对于 series 中每个元素都使用相同的 v 计算理论价    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 v 中对应的值计算理论价   t (float / pandas.Series): 年化到期时间，例如：还有 100 天到期，则年化到期时间为 100/360    * float: 对于 series 中每个元素都使用相同的 t 计算理论价    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 t 中对应的值计算理论价   option_class (str / pandas.Series): 期权方向，必须是两者其一，否则返回的序列值全部为 nan    * str: ""CALL"" 或者 ""PUT""    * pandas.Series: 其元素个数应该和 series 元素个数相同，每个元素的值为 ""CALL"" 或者 ""PUT""   d1 (None | pandas.Series): [可选] 序列对应的 BS 公式中 b1 值  Returns:   pandas.Series: 该序列的 delta 值  Example::   import pandas as pd   from tqsdk import TqApi, TqAuth, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   quote = api.get_quote(""SHFE.cu2006"")   ks = api.get_kline_serial(""SHFE.cu2006"", 24 * 60 * 60, 10)   v = tafunc.get_his_volatility(ks, quote) # 历史波动率   option = api.get_quote(""SHFE.cu2006C45000"")   klines = api.get_kline_serial([""SHFE.cu2006C45000"", ""SHFE.cu2006""], 24 * 60 * 60, 10)   t = tafunc.get_t(klines, option.expire_datetime)   impv = tafunc.get_impv(klines[""close1""], klines[""close""], 45000, 0.025, v, t, ""CALL"")   delta = tafunc.get_delta(klines[""close1""], 45000, 0.025, v, t, ""CALL"")   print(""delta"", list(delta))   api.close()  """"""  o = _get_options_class(series, option_class=option_class)  if d1 is None:   d1 = _get_d1(series, k, r, v, t)  return pd.Series(np.where(np.isnan(d1), np.nan, pd.Series(o * _get_cdf(o * d1)))) def get_gamma(series, k, r, v, t, d1=None):  """"""  计算期权希腊指标 gamma 值  Args:   series (pandas.Series): 标的价格序列   k (float): 期权行权价   r (float): 无风险利率   v (float / pandas.Series): 波动率    * float: 对于 series 中每个元素都使用相同的 v 计算理论价    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 v 中对应的值计算理论价   t (float / pandas.Series): 年化到期时间，例如：还有 100 天到期，则年化到期时间为 100/360    * float: 对于 series 中每个元素都使用相同的 t 计算理论价    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 t 中对应的值计算理论价   d1 (None | pandas.Series): [可选] 序列对应的 BS 公式中 b1 值  Returns:   pandas.Series: 该序列的 gamma 值  Example::   import pandas as pd   from tqsdk import TqApi, TqAuth, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   quote = api.get_quote(""SHFE.cu2006"")   ks = api.get_kline_serial(""SHFE.cu2006"", 24 * 60 * 60, 10)   v = tafunc.get_his_volatility(ks, quote) # 历史波动率   option = api.get_quote(""SHFE.cu2006C45000"")   klines = api.get_kline_serial([""SHFE.cu2006C45000"", ""SHFE.cu2006""], 24 * 60 * 60, 10)   t = tafunc.get_t(klines, option.expire_datetime)   impv = tafunc.get_impv(klines[""close1""], klines[""close""], 45000, 0.025, v, t, ""CALL"")   gamma = tafunc.get_gamma(klines[""close1""], 45000, 0.025, v, t)   print(""gamma"", list(gamma))   api.close()  """"""  if d1 is None:   d1 = _get_d1(series, k, r, v, t)  return pd.Series(np.where(np.isnan(d1), np.nan, _get_pdf(d1) / (series * v * np.sqrt(t)))) def get_theta(series, k, r, v, t, option_class, d1=None):  """"""  计算期权希腊指标 theta 值  Args:   series (pandas.Series): 标的价格序列   k (float): 期权行权价   r (float): 无风险利率   v (float / pandas.Series): 波动率    * float: 对于 series 中每个元素都使用相同的 v 计算理论价    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 v 中对应的值计算理论价   t (float / pandas.Series): 年化到期时间，例如：还有 100 天到期，则年化到期时间为 100/360    * float: 对于 series 中每个元素都使用相同的 t 计算理论价    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 t 中对应的值计算理论价   option_class (str / pandas.Series): 期权方向，必须是两者其一，否则返回的序列值全部为 nan    * str: ""CALL"" 或者 ""PUT""    * pandas.Series: 其元素个数应该和 series 元素个数相同，每个元素的值为 ""CALL"" 或者 ""PUT""   d1 (None | pandas.Series): [可选] 序列对应的 BS 公式中 b1 值  Returns:   pandas.Series: 该序列的 theta 值  Example::   import pandas as pd   from tqsdk import TqApi, TqAuth, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   quote = api.get_quote(""SHFE.cu2006"")   ks = api.get_kline_serial(""SHFE.cu2006"", 24 * 60 * 60, 10)   v = tafunc.get_his_volatility(ks, quote) # 历史波动率   option = api.get_quote(""SHFE.cu2006C45000"")   klines = api.get_kline_serial([""SHFE.cu2006C45000"", ""SHFE.cu2006""], 24 * 60 * 60, 10)   t = tafunc.get_t(klines, option.expire_datetime)   impv = tafunc.get_impv(klines[""close1""], klines[""close""], 45000, 0.025, v, t, ""CALL"")   theta = tafunc.get_theta(klines[""close1""], 45000, 0.025, v, t, ""CALL"")   print(""theta"", list(theta))   api.close()  """"""  o = _get_options_class(series, option_class=option_class)  if d1 is None:   d1 = _get_d1(series, k, r, v, t)  d2 = pd.Series(np.where(np.isnan(d1), np.nan, d1 - v * np.sqrt(t)))  return pd.Series(np.where(np.isnan(d1), np.nan, pd.Series(   -v * series * _get_pdf(d1) / (2 * np.sqrt(t)) - o * r * k * np.exp(-r * t) * _get_cdf(o * d2)))) def get_vega(series, k, r, v, t, d1=None):  """"""  计算期权希腊指标 vega 值  Args:   series (pandas.Series): 标的价格序列   k (float): 期权行权价   r (float): 无风险利率   v (float / pandas.Series): 波动率    * float: 对于 series 中每个元素都使用相同的 v 计算理论价    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 v 中对应的值计算理论价   t (float / pandas.Series): 年化到期时间，例如：还有 100 天到期，则年化到期时间为 100/360    * float: 对于 series 中每个元素都使用相同的 t 计算理论价    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 t 中对应的值计算理论价   d1 (None | pandas.Series): [可选] 序列对应的 BS 公式中 b1 值  Returns:   pandas.Series: 该序列的 vega 值  Example::   import pandas as pd   from tqsdk import TqApi, TqAuth, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   quote = api.get_quote(""SHFE.cu2006"")   ks = api.get_kline_serial(""SHFE.cu2006"", 24 * 60 * 60, 10)   v = tafunc.get_his_volatility(ks, quote) # 历史波动率   option = api.get_quote(""SHFE.cu2006C45000"")   klines = api.get_kline_serial([""SHFE.cu2006C45000"", ""SHFE.cu2006""], 24 * 60 * 60, 10)   t = tafunc.get_t(klines, option.expire_datetime)   impv = tafunc.get_impv(klines[""close1""], klines[""close""], 45000, 0.025, v, t, ""CALL"")   vega = tafunc.get_vega(klines[""close1""], 45000, 0.025, v, t)   print(""vega"", list(vega))   api.close()  """"""  if d1 is None:   d1 = _get_d1(series, k, r, v, t)  return pd.Series(np.where(np.isnan(d1), np.nan, series * np.sqrt(t) * _get_pdf(d1))) def get_rho(series, k, r, v, t, option_class, d1=None):  """"""  计算期权希腊指标 rho 值  Args:   series (pandas.Series): 标的价格序列   k (float): 期权行权价   r (float): 无风险利率   v (float / pandas.Series): 波动率    * float: 对于 series 中每个元素都使用相同的 v 计算理论价    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 v 中对应的值计算理论价   t (float / pandas.Series): 年化到期时间，例如：还有 100 天到期，则年化到期时间为 100/360    * float: 对于 series 中每个元素都使用相同的 t 计算理论价    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 t 中对应的值计算理论价   option_class (str / pandas.Series): 期权方向，必须是两者其一，否则返回的序列值全部为 nan    * str: ""CALL"" 或者 ""PUT""    * pandas.Series: 其元素个数应该和 series 元素个数相同，每个元素的值为 ""CALL"" 或者 ""PUT""   d1 (None | pandas.Series): [可选] 序列对应的 BS 公式中 b1 值  Returns:   pandas.Series: 该序列的 rho 值  Example::   import pandas as pd   from tqsdk import TqApi, TqAuth, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   quote = api.get_quote(""SHFE.cu2006"")   ks = api.get_kline_serial(""SHFE.cu2006"", 24 * 60 * 60, 10)   v = tafunc.get_his_volatility(ks, quote) # 历史波动率   option = api.get_quote(""SHFE.cu2006C45000"")   klines = api.get_kline_serial([""SHFE.cu2006C45000"", ""SHFE.cu2006""], 24 * 60 * 60, 10)   t = tafunc.get_t(klines, option.expire_datetime)   impv = tafunc.get_impv(klines[""close1""], klines[""close""], 45000, 0.025, v, t, ""CALL"")   rho = tafunc.get_rho(klines[""close1""], 45000, 0.025, v, t, ""CALL"")   print(""rho"", list(rho))   api.close()  """"""  o = _get_options_class(series, option_class=option_class)  if d1 is None:   d1 = _get_d1(series, k, r, v, t)  d2 = pd.Series(np.where(np.isnan(d1), np.nan, d1 - v * np.sqrt(t)))  return pd.Series(np.where(np.isnan(d1), np.nan, o * k * t * np.exp(-r * t) * _get_cdf(o * d2))) def get_impv(series, series_option, k, r, init_v, t, option_class):  """"""  计算期权隐含波动率  Args:   series (pandas.Series): 标的价格序列   series_option (pandas.Series): 期权价格序列，与 series 长度应该相同   k (float): 期权行权价   r (float): 无风险利率   init_v (float / pandas.Series): 初始波动率，迭代初始值    * float: 对于 series 中每个元素都使用相同的 init_v 计算隐含波动率    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 init_v 中对应的值计算隐含波动率   t (float / pandas.Series): 年化到期时间，例如：还有 100 天到期，则年化到期时间为 100/360    * float: 对于 series 中每个元素都使用相同的 t 计算理论价    * pandas.Series: 其元素个数应该和 series 元素个数相同，对于 series 中每个元素都使用 t 中对应的值计算理论价   option_class (str / pandas.Series): 期权方向，必须是两者其一，否则返回的序列值全部为 nan    * str: ""CALL"" 或者 ""PUT""    * pandas.Series: 其元素个数应该和 series 元素个数相同，每个元素的值为 ""CALL"" 或者 ""PUT""  Returns:   pandas.Series: 该序列的隐含波动率  Example::   import pandas as pd   from tqsdk import TqApi, TqAuth, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   quote = api.get_quote(""SHFE.cu2006"")   ks = api.get_kline_serial(""SHFE.cu2006"", 24 * 60 * 60, 10)   v = tafunc.get_his_volatility(ks, quote) # 历史波动率   option = api.get_quote(""SHFE.cu2006C45000"")   klines = api.get_kline_serial([""SHFE.cu2006C45000"", ""SHFE.cu2006""], 24 * 60 * 60, 10)   t = tafunc.get_t(klines, option.expire_datetime)   impv = tafunc.get_impv(klines[""close1""], klines[""close""], 45000, 0.025, v, t, ""CALL"")   print(""impv"", list((impv * 100).round(2)))   api.close()  """"""  o = _get_options_class(series, option_class=option_class)  lower_limit = o * (series - k * np.exp(-r * t))  x = pd.Series(np.where((series_option < lower_limit) | (t <= 0), np.nan, init_v))  y = pd.Series(np.where(np.isnan(x), np.nan, get_bs_price(series, k, r, x, t, option_class)))  vega = get_vega(series, k, r, x, t)  diff_x = pd.Series(np.where(np.isnan(vega) | (vega < 1e-8), np.nan, (series_option - y) / vega))  while not pd.DataFrame.all((np.abs(series_option - y) < 1e-8) | np.isnan(diff_x)):   x = pd.Series(np.where(np.isnan(x) | np.isnan(diff_x), x,        np.where(x + diff_x < 0, x / 2,           np.where(diff_x > x / 2, x * 1.5, x + diff_x))))   y = pd.Series(np.where(np.isnan(x), np.nan, get_bs_price(series, k, r, x, t, option_class)))   vega = get_vega(series, k, r, x, t)   diff_x = pd.Series(np.where(np.isnan(vega) | (vega < 1e-8), np.nan, (series_option - y) / vega))  return x def get_ticks_info(df):  """"""  计算 ticks 开平方向  Args:   df (pandas.DataFrame): Dataframe 格式的 ticks 序列  Returns:   pandas.Series: 返回序列的开平方向序列  Example::   from tqsdk import TqApi, TqAuth, tafunc   api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))   ticks = api.get_tick_serial('SHFE.cu2006', 100)   ticksinfo = tafunc.get_ticks_info(ticks)   for i, v in ticksinfo.items():    print(f""{tafunc.time_to_str(ticks['datetime'][i])[5:21]} {ticks['last_price'][i]} {v}"")   api.close()   # 预计的输出是这样的:   04-27 10:54:11.5 42640.0 多换   04-27 10:54:12.0 42640.0 多换   04-27 10:54:16.5 42640.0 多换   ......   04-27 10:55:10.0 42660.0 双平   04-27 10:55:10.5 42660.0 双平   04-27 10:55:14.0 42670.0 双平  """"""  if ""open_interest"" not in df.keys(): # df 不是 ticks 是 klines   raise Exception(f""get_ticks_info 参数必须是 ticks，由 api.get_tick_serial 返回的对象。"")  df_pre = df.copy().shift(1)  df_pre[""price_diff""] = df[""last_price""] - df_pre[""last_price""]  df_pre[""oi_diff""] = df[""open_interest""] - df_pre[""open_interest""]  df_pre[""vol_diff""] = df[""volume""] - df_pre[""volume""]  df_pre[""pc""] = np.where(df[""last_price""] <= df_pre[""bid_price1""], -1,        np.where(df[""last_price""] >= df_pre[""ask_price1""], 1, np.sign(df_pre[""price_diff""])))  pc_g = df_pre[""pc""] > 0  df_pre[""info""] = pd.Series(np.where(df_pre[""oi_diff""] > 0, np.where(pc_g, ""多开"", ""空开""),           np.where(df_pre[""oi_diff""] < 0, np.where(pc_g, ""空平"", ""多平""),             np.where(df_pre[""oi_diff""] == 0, np.where(pc_g, ""多换"", ""空换""), """"))))  df_pre.loc[df_pre[""pc""] == 0, ""info""] = ""换手""  df_pre.loc[(df_pre[""oi_diff""] < 0) & (df_pre[""oi_diff""] + df_pre[""vol_diff""] == 0), ""info""] = ""双平""  df_pre.loc[(df_pre[""oi_diff""] > 0) & (df_pre[""oi_diff""] == df_pre[""vol_diff""]), ""info""] = ""双开""  df_pre.loc[df_pre[""vol_diff""] == 0, ""info""] = """"  return df_pre[""info""] def get_dividend_df(stock_dividend_ratio, cash_dividend_ratio):  """"""  计算复权系数矩阵  Args:   stock_dividend_ratio (list): 除权表（可以由 quote.stock_dividend_ratio 取得）   cash_dividend_ratio (list): 除息表（可以由 quote.cash_dividend_ratio 取得）  Returns:   pandas.Dataframe: 复权系数矩阵， Dataframe 对象有 [""datetime"", ""stock_dividend"", ""cash_dividend""] 三列。  """"""  # 除权矩阵  stock_dividend_df = pd.DataFrame({   ""datetime"": [_datetime_to_timestamp_nano(datetime.datetime.strptime(s.split("","")[0], ""%Y%m%d"")) for s in      stock_dividend_ratio],   ""stock_dividend"": np.array([float(s.split("","")[1]) for s in stock_dividend_ratio])  })  # 除息矩阵  cash_dividend_df = pd.DataFrame({   ""datetime"": [_datetime_to_timestamp_nano(datetime.datetime.strptime(s.split("","")[0], ""%Y%m%d"")) for s in      cash_dividend_ratio],   ""cash_dividend"": [float(s.split("","")[1]) for s in cash_dividend_ratio]  })  # 除权除息矩阵  dividend_df = pd.merge(stock_dividend_df, cash_dividend_df, on=['datetime'], how=""outer"", sort=True)  dividend_df.fillna(0.0, inplace=True)  return dividend_df def get_dividend_factor(dividend_df, last_item, item):  """"""  返回 item 项对应的复权因子。  Args:   dividend_df (pandas.Dataframe): 除权除息矩阵表   last_item (dict): 前一个 tickItem / klineItem   item (dict): 当前 tickItem / klineItem  Returns:   float: 复权因子  """"""  last_dt = last_item['datetime']  dt = item['datetime']  if last_dt and dt:   gt = dividend_df['datetime'].gt(last_dt)   if gt.any():    dividend_first = dividend_df[gt].iloc[0]    if dt >= dividend_first['datetime']:     c = last_item['close'] if last_item['close'] else last_item['last_price']     return (1 - dividend_first['cash_dividend'] / c) / (1 + dividend_first['stock_dividend'])  return 1 def _tq_pstdev(data: Series, mu: float):  """"""  计算标准差  标准库提供的方法 statistics.pstdev 在 py3.6,py3.7 版本下参数 mean 不能设定为指定值，所以这里另外计算。  """"""  n = data.shape[0]  assert n >= 1  return math.sqrt(sum((data - mu)**2) / n) def get_sharp(series, trading_days_of_year=250, r=0.025):  """"""  年化夏普率  Args:   series (pandas.Series): 每日收益率序列   trading_days_of_year (int): 年化交易日数量   r (float): 无风险利率  Returns:   float: 年化夏普率  """"""  rf = _get_daily_risk_free(trading_days_of_year, r)  mean = series.mean()  stddev = _tq_pstdev(series, mu=mean)  return trading_days_of_year ** (1 / 2) * (mean - rf) / stddev if stddev else float(""inf"") def get_sortino(series, trading_days_of_year=250, r=0.025):  """"""  年化索提诺比率  Args:   series (pandas.Series): 每日收益率序列   trading_days_of_year (int): 年化交易日数量   r (float): 无风险利率  Returns:   float: 年化索提诺比率  """"""  rf = _get_daily_risk_free(trading_days_of_year, r)  mean = series.mean()  left_daily_yield = series.loc[series < rf]  stddev = _tq_pstdev(left_daily_yield, mu=rf) if left_daily_yield.shape[0] > 0 else 0  return (trading_days_of_year * left_daily_yield.shape[0] / series.shape[0]) ** (1 / 2) * (mean - rf) / stddev if stddev else float(""inf"") def get_calmar(series, max_drawdown, trading_days_of_year=250, r=0.025):  """"""  年化卡玛比率  Args:   series (pandas.Series): 每日收益率序列   max_drawdown (float): 最大回撤   trading_days_of_year (int): 年化交易日数量   r (float): 无风险利率  Returns:   float: 年化夏普率  """"""  rf = _get_daily_risk_free(trading_days_of_year, r)  if max_drawdown and max_drawdown == max_drawdown:   mean = series.mean()   return trading_days_of_year ** (1 / 2) * (mean - rf) / max_drawdown  return float(""inf"") def _get_daily_risk_free(trading_days_of_year, r):  """"""日化无风险利率""""""  return pow(r + 1, 1 / trading_days_of_year) - 1 def _cum_counts(s: Series):  """"""  统计连续为1的个数, 用于计算最大连续盈利/亏损天数  input: [0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0]  output: [0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 2, 0, 1, 0, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 0, 0]  """"""  return s * (s.groupby((s != s.shift()).cumsum()).cumcount() + 1) "
102,n\tqsdk\tqwebhelpe,"n\tqsdk\tqwebhelpe. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' import asyncio import os import socket import sys from datetime import datetime from urllib.parse import urlparse import numpy as np import simplejson from aiohttp import web from tqsdk.tradeable.sim.basesim import BaseSim from tqsdk.auth import TqAuth from tqsdk.backtest import TqBacktest, TqReplay from tqsdk.channel import TqChan from tqsdk.datetime import _get_trading_day_start_time, _datetime_to_timestamp_nano from tqsdk.diff import _simple_merge_diff from tqsdk.tradeable import TqAccount, TqKq, TqSim class TqWebHelper(object):  def __init__(self, api):   """"""初始化，检查参数""""""   self._api = api   ip, port = TqWebHelper.parse_url(self._api._web_gui)   self._http_server_host = ip if ip else ""0.0.0.0""   self._http_server_port = int(port) if port else 0   args = TqWebHelper.parser_env_arguments()   if args[""_action""] == ""run"":    # 运行模式下，账户参数冲突需要抛错，提示用户    if args[""_broker_id""] == ""TQ_KQ"":     if type(self._api._account) is TqAccount:      raise Exception(""策略代码与插件设置中的账户参数冲突。可尝试删去代码中的账户参数 TqAccount，以插件设置的账户参数运行。"")     self._api._account = TqKq()    elif args[""_broker_id""] and args[""_account_id""] and args[""_password""]:     if isinstance(self._api._account, TqKq):      raise Exception(""策略代码与插件设置中的账户参数冲突。可尝试删去代码中的账户参数 TqKq，以插件设置的账户参数运行。"")     if isinstance(self._api._account, TqAccount) and \       (self._api._account._account_id != args[""_account_id""] or self._api._account._broker_id !=       args[""_broker_id""]):      raise Exception(""策略代码与插件设置中的账户参数冲突。可尝试删去代码中的账户参数 TqAccount，以插件设置的账户参数运行。"")     self._api._account = TqAccount(args[""_broker_id""], args[""_account_id""], args[""_password""])    else:     self._api._account = TqSim(args[""_init_balance""])    self._api._backtest = None    self._api._print(f""正在使用账户 {args['_broker_id']}, {args['_account_id']} 运行策略。"")   elif args[""_action""] is not None:    self._api._account = TqSim(args[""_init_balance""])    if args[""_action""] == ""backtest"":     self._api._backtest = TqBacktest(start_dt=datetime.strptime(args[""_start_dt""], '%Y%m%d'),             end_dt=datetime.strptime(args[""_end_dt""], '%Y%m%d'))     self._api._print(f""当前回测区间 {args['_start_dt']} - {args['_end_dt']}。"")    elif args[""_action""] == ""replay"":     self._api._backtest = TqReplay(datetime.strptime(args[""_replay_dt""], '%Y%m%d'))     self._api._print(f""当前复盘日期 {args['_replay_dt']}。"")   if args[""_auth""]:    comma_index = args[""_auth""].find(',')    user_name, pwd = args[""_auth""][:comma_index], args[""_auth""][comma_index + 1:]    if self._api._auth is not None and (user_name != self._api._auth._user_name or pwd != self._api._auth._password):     raise Exception(""策略代码与插件设置中的 auth 参数冲突。可尝试删去代码中的 auth 参数，以插件设置的参数运行。"")    self._api._auth = TqAuth(user_name, pwd)   if args[""_http_server_address""]:    self._api._web_gui = True # 命令行 _http_server_address, 一定打开 _web_gui    ip, port = TqWebHelper.parse_url(args[""_http_server_address""])    self._http_server_host = ip if ip else ""0.0.0.0""    self._http_server_port = int(port) if port else 0  async def _run(self, api_send_chan, api_recv_chan, web_send_chan, web_recv_chan):   if not self._api._web_gui:    # 没有开启 web_gui 功能    _data_handler_without_web_task = self._api.create_task(     self._data_handler_without_web(api_recv_chan, web_recv_chan))    try:     async for pack in api_send_chan:      # api 发送的包，过滤出 set_chart_data, 其余的原样转发      if pack['aid'] not in ['set_chart_data', 'set_report_data']:       await web_send_chan.send(pack)    finally:     _data_handler_without_web_task.cancel()     await asyncio.gather(_data_handler_without_web_task, return_exceptions=True)   else:    self._web_dir = os.path.join(os.path.dirname(__file__), 'web')    file_path = os.path.abspath(sys.argv[0])    file_name = os.path.basename(file_path)    # 初始化数据截面    accounts_info = {     acc._account_key: {""td_url_status"": True if isinstance(acc, BaseSim) else '-'}     for acc in self._api._account._account_list    }    for acc in self._api._account._account_list:     accounts_info[acc._account_key].update(acc._account_info)    self._data = {     ""action"": {      ""mode"": ""replay"" if isinstance(self._api._backtest, TqReplay) else ""backtest"" if isinstance(self._api._backtest, TqBacktest) else ""run"",      ""md_url_status"": '-',      ""user_name"": self._api._auth._user_name,      ""file_path"": file_path[0].upper() + file_path[1:],      ""file_name"": file_name,      ""accounts"": accounts_info     },     ""trade"": {},     ""subscribed"": [],     ""draw_chart_datas"": {},     ""snapshots"": {}    }    self._order_symbols = set()    self._diffs = []    self._conn_diff_chans = set()    _data_task = self._api.create_task(self._data_handler(api_recv_chan, web_recv_chan))    _httpserver_task = self._api.create_task(self.link_httpserver())    try:     # api 发送的包，过滤出需要的包记录在 self._data     async for pack in api_send_chan:      if pack['aid'] == 'set_chart_data':       # 发送的是绘图数据       diff_data = {} # 存储 pack 中的 diff 数据的对象       for series_id, series in pack['datas'].items():        diff_data[series_id] = series       if diff_data != {}:        web_diff = {'draw_chart_datas': {}}        web_diff['draw_chart_datas'][pack['symbol']] = {}        web_diff['draw_chart_datas'][pack['symbol']][pack['dur_nano']] = diff_data        _simple_merge_diff(self._data, web_diff)        for chan in self._conn_diff_chans:         self.send_to_conn_chan(chan, [web_diff])      elif pack['aid'] == 'set_report_data':       # 发送的是绘图报告数据       web_diff = {'draw_report_datas': {}}       for data in pack['report_datas']:        _simple_merge_diff(web_diff['draw_report_datas'], data)       _simple_merge_diff(self._data, web_diff)       for chan in self._conn_diff_chans:        self.send_to_conn_chan(chan, [web_diff])      else:       if pack[""aid""] == ""insert_order"":        self._order_symbols.add(pack[""exchange_id""] + ""."" + pack[""instrument_id""])       if pack['aid'] == 'subscribe_quote' or pack[""aid""] == ""set_chart"" or pack[""aid""] == 'insert_order':        web_diff = {'subscribed': []}        for item in self._api._requests[""klines""].keys():         web_diff['subscribed'].append({""symbol"": item[0], ""dur_nano"": item[1] * 1000000000})        for item in self._api._requests[""ticks""].keys():         web_diff['subscribed'].append({""symbol"": item[0], ""dur_nano"": 0})        for symbol in self._api._requests[""quotes""]:         web_diff['subscribed'].append({""symbol"": symbol})        for symbol in self._order_symbols:         web_diff['subscribed'].append({""symbol"": symbol})        if web_diff['subscribed'] != self._data['subscribed']:         self._data['subscribed'] = web_diff['subscribed']        for chan in self._conn_diff_chans:         self.send_to_conn_chan(chan, [web_diff])       # 发送的转发给上游       await web_send_chan.send(pack)    finally:     _data_task.cancel()     _httpserver_task.cancel()     await asyncio.gather(_data_task, _httpserver_task, return_exceptions=True)  async def _data_handler_without_web(self, api_recv_chan, web_recv_chan):   # 没有 web_gui, 接受全部数据转发给下游 api_recv_chan   async for pack in web_recv_chan:    await api_recv_chan.send(pack)  async def _data_handler(self, api_recv_chan, web_recv_chan):   async for pack in web_recv_chan:    if pack['aid'] == 'rtn_data':     web_diffs = []     account_changed = False     for d in pack['data']:      # 把 d 处理成需要的数据      # 处理 trade      trade = d.get(""trade"")      if trade is not None:       _simple_merge_diff(self._data[""trade""], trade)       web_diffs.append({""trade"": trade})       # 账户是否有变化       # todo: 这里本来使用类似 is_changing 的做法，判断 diffs 中是否有 static_balance 字段；由于 _simple_merge_diff 去掉了默认参数 reduce_diff       # 现在修改为手动比较 diffs 中的 static_balance 和 self._data 中的 static_balance 是否一样       account_key = self._api._account._get_account_key(account=None)       current_static_balance = self._data[""trade""].get(account_key, {}).get(""accounts"", {}).get(""CNY"", {}).get('static_balance')       diff_static_balance = d.get(""trade"", {}).get(account_key, {}).get(""accounts"", {}).get(""CNY"", {}).get('static_balance', None)       static_balance_changed = diff_static_balance is not None and current_static_balance != diff_static_balance       trades_changed = d.get(""trade"", {}).get(account_key, {}).get(""trades"", {})       orders_changed = d.get(""trade"", {}).get(account_key, {}).get(""orders"", {})       if static_balance_changed is True or trades_changed != {} or orders_changed != {}:        account_changed = True      # 处理 backtest replay      if d.get(""_tqsdk_backtest"") or d.get(""_tqsdk_replay""):       _simple_merge_diff(self._data, d)       web_diffs.append(d)      # 处理通知，行情和交易连接的状态      notify_diffs = self._notify_handler(d.get(""notify"", {}))      for diff in notify_diffs:       _simple_merge_diff(self._data, diff)      web_diffs.extend(notify_diffs)     if account_changed:      dt, snapshot = self.get_snapshot()      _snapshots = {""snapshots"": {}}      _snapshots[""snapshots""][dt] = snapshot      web_diffs.append(_snapshots)      _simple_merge_diff(self._data, _snapshots)     for chan in self._conn_diff_chans:      self.send_to_conn_chan(chan, web_diffs)    # 接收的数据转发给下游 api    await api_recv_chan.send(pack)  def _notify_handler(self, notifies):   """"""将连接状态的通知转成 diff 协议""""""   diffs = []   for _, notify in notifies.items():    if notify[""code""] == 2019112901 or notify[""code""] == 2019112902:     url_status = True # 连接建立的通知 第一次建立 或者 重连建立    elif notify[""code""] == 2019112911:     url_status = False # 连接断开的通知    else:     continue    if notify[""url""] == self._api._md_url:     diffs.append({      ""action"": {""md_url_status"": url_status}     })    elif notify[""conn_id""] in self._api._account._map_conn_id:     acc = self._api._account._map_conn_id[notify[""conn_id""]]     diffs.append({      ""action"": {       ""accounts"": {acc._account_key: {""td_url_status"": url_status}}      }     })   return diffs  def send_to_conn_chan(self, chan, diffs):   last_diff = chan.recv_latest({})   for d in diffs:    _simple_merge_diff(last_diff, d)   if last_diff != {}:    chan.send_nowait(last_diff)  def dt_func (self):   # 回测和复盘模式，用 _api._account 一定是 TqSim, 使用 TqSim _get_current_timestamp() 提供的时间   # todo: 使用 TqSim.EPOCH   if self._data[""action""][""mode""] == ""backtest"":    return self._data['_tqsdk_backtest']['current_dt']   elif self._data[""action""][""mode""] == ""replay"":    tqsim_current_timestamp = self._api._account._account_list[0]._get_current_timestamp()    if tqsim_current_timestamp == 631123200000000000:     # 未收到任何行情, TqSim 时间没有更新     return _get_trading_day_start_time(self._data['_tqsdk_replay']['replay_dt'])    else:     return tqsim_current_timestamp   else:    return _datetime_to_timestamp_nano(datetime.now())  def get_snapshot(self):   account = self._data.get(""trade"", {}).get(self._api._account._get_account_key(account=None), {}).get(""accounts"", {}).get(""CNY"", {})   positions = self._data.get(""trade"", {}).get(self._api._account._get_account_key(account=None), {}).get(""positions"", {})   dt = self.dt_func()   return dt, {    'accounts': {'CNY': {k: v for k, v in account.items() if not k.startswith(""_"")}},    'positions': {k: {pk: pv for pk, pv in v.items() if not pk.startswith(""_"")} for k, v in       positions.items() if       not k.startswith(""_"")}   }  def get_send_msg(self, data=None):   return simplejson.dumps({    'aid': 'rtn_data',    'data': [self._data if data is None else data]   }, ignore_nan=True, default=TqWebHelper._convert)  async def connection_handler(self, request):   ws = web.WebSocketResponse()   await ws.prepare(request)   send_msg = self.get_send_msg(self._data)   await ws.send_str(send_msg)   conn_chan = TqChan(self._api, last_only=True)   self._conn_diff_chans.add(conn_chan)   try:    async for msg in ws:     pack = simplejson.loads(msg.data)     if pack[""aid""] == 'peek_message':      last_diff = await conn_chan.recv()      send_msg = self.get_send_msg(last_diff)      await ws.send_str(send_msg)   except Exception as e:    await conn_chan.close()    self._conn_diff_chans.remove(conn_chan)  async def link_httpserver(self):   try:    url_response = {     ""ins_url"": self._api._ins_url,     ""md_url"": self._api._md_url,    }    # TODO：在复盘模式下发送 replay_dt 给 web 端，服务器改完后可以去掉    if isinstance(self._api._backtest, TqReplay):     url_response[""replay_dt""] = _datetime_to_timestamp_nano(datetime.combine(self._api._backtest._replay_dt, datetime.min.time()))    app = web.Application()    app.router.add_get(path='/url', handler=lambda request: TqWebHelper.httpserver_url_handler(url_response))    app.router.add_get(path='/', handler=self.httpserver_index_handler)    app.router.add_get(path='/index.html', handler=self.httpserver_index_handler)    app.router.add_static('/web', self._web_dir, show_index=True)    app.add_routes([web.get('/ws', self.connection_handler)])    runner = web.AppRunner(app)    await runner.setup()    server_socket = socket.socket()    if sys.platform.startswith(""linux"") or sys.platform.startswith(""darwin""):     server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    server_socket.bind((self._http_server_host, self._http_server_port))    address = server_socket.getsockname()    site = web.SockSite(runner, server_socket)    await site.start()    ip = ""127.0.0.1"" if address[0] == ""0.0.0.0"" else address[0]    self._api._print(""您可以访问 http://{ip}:{port} 查看策略绘制出的 K 线图形。"".format(ip=ip, port=address[1]))    await asyncio.sleep(100000000000)   finally:    await runner.shutdown()    await runner.cleanup()  def httpserver_index_handler(self, request):   return web.FileResponse(self._web_dir + '/index.html')  @staticmethod  def _convert(o):   """"""对于 numpy 类型的数据，返回可以序列化的值""""""   if isinstance(o, np.generic):    return o.item()   raise TypeError  @staticmethod  def parse_url(url):   if isinstance(url, str):    parse_result = urlparse(url, scheme='')    addr = parse_result.netloc if parse_result.scheme == ""http"" else url    return addr.split(':')   else:    return '0.0.0.0', '0'  @staticmethod  def httpserver_url_handler(response):   return web.json_response(response)  @staticmethod  def parser_env_arguments():   action = {    ""_action"": os.getenv(""TQ_ACTION""),    ""_http_server_address"": os.getenv(""TQ_HTTP_SERVER_ADDRESS""),    ""_auth"": os.getenv(""TQ_AUTH"")   }   try:    action[""_init_balance""] = 10000000.0 if os.getenv(""TQ_INIT_BALANCE"") is None else float(     os.getenv(""TQ_INIT_BALANCE""))   except ValueError:    action[""_init_balance""] = 10000000.0   if action[""_action""] == ""run"":    action[""_broker_id""] = os.getenv(""TQ_BROKER_ID"")    action[""_account_id""] = os.getenv(""TQ_ACCOUNT_ID"")    action[""_password""] = os.getenv(""TQ_PASSWORD"")    if not action[""_broker_id""]:     action[""_action""] = None   elif action[""_action""] == ""backtest"":    action[""_start_dt""] = os.getenv(""TQ_START_DT"")    action[""_end_dt""] = os.getenv(""TQ_END_DT"")    if not action[""_start_dt""] or not action[""_end_dt""]:     action[""_action""] = None   elif action[""_action""] == ""replay"":    action[""_replay_dt""] = os.getenv(""TQ_REPLAY_DT"")    if not action[""_replay_dt""]:     action[""_action""] = None   return action "
103,n\tqsdk\trade extensio,"n\tqsdk\trade extensio. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' from tqsdk.datetime import _get_trading_day_end_time, _get_trading_day_from_timestamp, _get_expire_rest_days from tqsdk.datetime_state import TqDatetimeState from tqsdk.diff import _simple_merge_diff, _merge_diff from tqsdk.entity import Entity from tqsdk.utils import _query_for_quote class CustomDict(Entity):  """""" Position / Order / Trade 对象 """"""  def __init__(self, api, new_objs_list):   self._api = api   self._new_objs_list = new_objs_list  def __setitem__(self, key, value):   self._new_objs_list.append(value)   return super(CustomDict, self).__setitem__(key, value) class TradeExtension():  """"""  为持仓、委托单、成交对象添加 合约信息  * 为期权合约相应的持仓、委托单、成交，添加以下字段   + option_class 代表期权方向 CALL or PUT，非期权合约该处显示为NONE   + underlying_symbol   + strike_price   + expire_rest_days 距离到期日剩余天数  """"""  def __init__(self, api):   self._api = api   self._data = Entity() # 交易业务信息截面，需要定于数据原型，使用 Entity 类型 和 _merge_diff   self._data._instance_entity([])   self._new_objs_list = []   self._prototype = {    ""trade"": {     ""*"": {      ""@"": CustomDict(self._api, self._new_objs_list)     }    }   }   self._data_quotes = {} # 行情信息截面，只需要 quotes 数据。这里不需要定义数据原型，使用普通 dict 和 _simple_merge_diff   self._diffs = []   self._all_trade_symbols = set() # 所有持仓、委托、成交中的合约   self._query_symbols = set() # 已经发送合约信息请求 + 已经知道合约信息的合约   self._need_wait_symbol_info = set() # 需要发送合约信息请求 + 不知道合约信息的合约  async def _run(self, api_send_chan, api_recv_chan, md_send_chan, md_recv_chan):   self._logger = self._api._logger.getChild(""TradeExtension"")   self._api_send_chan = api_send_chan   self._api_recv_chan = api_recv_chan   self._md_send_chan = md_send_chan   self._md_recv_chan = md_recv_chan   self._datetime_state = TqDatetimeState()   self._trading_day_end = None   md_task = self._api.create_task(self._md_handler())   self._pending_peek = False # True 表示收到下游的 peek_message ，并且没有发给过下游回复；False 表示发给过下游回复，没有 pending_peek_message   self._pending_peek_md = False # True 表示发给过上游 peek_message；False 表示对上游没有 pending_peek_message   try:    async for pack in api_send_chan:     if ""_md_recv"" in pack:      self._pending_peek_md = False      await self._md_recv(pack)      await self._send_diff()      if self._pending_peek and self._pending_peek_md is False:       self._pending_peek_md = True       await self._md_send_chan.send({""aid"": ""peek_message""})     elif pack[""aid""] == ""peek_message"":      self._pending_peek = True      await self._send_diff()      if self._pending_peek and self._pending_peek_md is False:       self._pending_peek_md = True       await self._md_send_chan.send(pack)     else:      await self._md_send_chan.send(pack)   finally:    md_task.cancel()  async def _md_handler(self):   """"""0 接收上游数据包 """"""   async for pack in self._md_recv_chan:    pack[""_md_recv""] = True    await self._api_send_chan.send(pack)  async def _md_recv(self, pack):   """""" 处理下行数据包   0 将行情数据和交易数据合并至 self._data   1 生成增量业务截面, 该截面包含期权补充的字段   """"""   for d in pack.get(""data"", {}):    self._datetime_state.update_state(d)    _simple_merge_diff(self._data_quotes, d.get('quotes', {}))    _merge_diff(self._data, {""trade"": d.get('trade', {})}, prototype=self._prototype, persist=False, reduce_diff=False)    self._diffs.append(d) # 添加至 self._diff 等待被发送   for obj in self._new_objs_list:    # 新添加的 Position / Order / Trade 节点    if hasattr(obj, '_path') and obj['_path'][2] in ['positions', 'trades', 'orders']:     symbol = f""{obj.get('exchange_id', '')}.{obj.get('instrument_id', '')}""     if symbol not in self._all_trade_symbols:      self._all_trade_symbols.add(symbol)      self._need_wait_symbol_info.add(symbol) # 需要发送合约信息请求   for s in self._need_wait_symbol_info.copy():    if self._data_quotes.get(s, {}).get(""price_tick"", 0) > 0:     self._need_wait_symbol_info.remove(s) # 需要发送合约信息请求 + 不知道合约信息的合约   # 不知道合约信息 并且未发送请求查询合约信息   unknown_symbols = self._need_wait_symbol_info - self._query_symbols   if len(unknown_symbols) > 0:    self._query_symbols = self._query_symbols.union(unknown_symbols) # 所有发送过ins_query的合约    query_pack = _query_for_quote(list(unknown_symbols))    await self._md_send_chan.send(query_pack)  def _generate_pend_diff(self):   """"""""   补充期权额外字段   此函数在 send_diff() 才会调用， self._datetime_state.data_ready 一定为 True，   调用 self._datetime_state.get_current_dt() 一定有正确的当前时间   """"""   pend_diff = {}   account_keys = list(self._data.get('trade', {}).keys())   objs_keys = ['positions', 'trades', 'orders']   # 如果有新添加的合约, 只填充一次即可   if self._new_objs_list:    pend_diff.setdefault('trade', {k: {o_k: {} for o_k in objs_keys} for k in account_keys})    for obj in self._new_objs_list:     # 新添加的 Position / Order / Trade 节点     if hasattr(obj, '_path') and obj['_path'][2] in objs_keys:      account_key = obj['_path'][1]      obj_key = obj['_path'][2]      item_id = obj['_path'][3]      quote = self._data_quotes.get(f""{obj.get('exchange_id', '')}.{obj.get('instrument_id', '')}"", {})      if quote.get('ins_class', '').endswith('OPTION'):       pend_diff_item = pend_diff['trade'][account_key][obj_key].setdefault(item_id, {})       pend_diff_item['option_class'] = quote.get('option_class')       pend_diff_item['strike_price'] = quote.get('strike_price')       pend_diff_item['underlying_symbol'] = quote.get('underlying_symbol')       if quote.get('expire_datetime'):        pend_diff_item['expire_rest_days'] = _get_expire_rest_days(quote.get('expire_datetime'),                      self._datetime_state.get_current_dt() / 1e9)    self._new_objs_list.clear()   # 如果有切换交易日，所有合约都需要修改 expire_rest_days   current_dt = self._datetime_state.get_current_dt()   if self._trading_day_end is None or current_dt > self._trading_day_end:    pend_diff.setdefault('trade', {k: {o_k: {} for o_k in objs_keys} for k in account_keys})    for account_key, account_node in self._data.get('trade', {}).items():     for k in objs_keys:      for item_id, item in account_node.get(k, {}).items():       quote = self._data_quotes.get(f""{item['exchange_id']}.{item['instrument_id']}"", {})       if quote.get('ins_class', '').endswith('OPTION') and quote.get('expire_datetime'):        pend_diff_item = pend_diff['trade'][account_key][k].setdefault(item_id, {})        # 剩余到期日字段，每天都会更新，每次都重新计算        pend_diff_item['expire_rest_days'] = _get_expire_rest_days(quote.get('expire_datetime'),                      current_dt / 1e9)    self._trading_day_end = _get_trading_day_end_time(_get_trading_day_from_timestamp(current_dt))   return pend_diff  async def _send_diff(self):   if self._datetime_state.data_ready and self._pending_peek and self._diffs and len(self._need_wait_symbol_info) == 0:    # 生成增量业务截面, 该截面包含期权补充的字段，只在真正需要给下游发送数据时，才将需要发送的数据放在 _diffs 中    pend_diff = self._generate_pend_diff()    self._diffs.append(pend_diff)    rtn_data = {     ""aid"": ""rtn_data"",     ""data"": self._diffs,    }    self._diffs = []    self._pending_peek = False    await self._api_recv_chan.send(rtn_data) "
104,n\tqsdk\trading statu,"n\tqsdk\trading statu. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' from shinny_structlog import ShinnyLoggerAdapter from tqsdk.baseModule import TqModule from tqsdk.channel import TqChan from tqsdk.connect import TqConnect, TsReconnectHandler class TqTradingStatus(TqModule):  """"""  交易状态模块，建立 websocket 连接  """"""  async def _run(self, api, api_send_chan, api_recv_chan, md_send_chan, md_recv_chan):   self._api = api   self._logger = self._api._logger.getChild(""TradingStatus"")   self._init_ts_ws = False   self._api_send_chan = api_send_chan   self._api_recv_chan = api_recv_chan   self._md_send_chan = md_send_chan   self._md_recv_chan = md_recv_chan   self._ts_send_chan = TqChan(self._api, chan_name=""send to ts_reconn"")   self._ts_recv_chan = TqChan(self._api, chan_name=""recv from ts_reconn"")   await super(TqTradingStatus, self)._run(api, api_send_chan, api_recv_chan, md_send_chan, md_recv_chan, self._ts_send_chan, self._ts_recv_chan)  async def _handle_recv_data(self, pack, chan):   """"""   处理所有上游收到的数据包   """"""   if pack['aid'] == 'rtn_data':    if chan == self._md_recv_chan: # 从行情收到的数据包     self._diffs.extend(pack.get('data', []))    elif chan == self._ts_recv_chan: # 从交易状态服务收到的数据包     diffs = pack.get('data', [])     for d in diffs:      for symbol, ts in d.get('trading_status', {}).items():       if ts['trade_status'] not in [""AUCTIONORDERING"", ""CONTINOUS""]:        ts['trade_status'] = ""NOTRADING""     self._diffs.extend(diffs)   else:    await self._api_recv_chan.send(pack)  async def _handle_req_data(self, pack):   """"""处理所有下游发送的非 peek_message 数据包""""""   if pack['aid'] == 'subscribe_trading_status':    if self._init_ts_ws is False:     self._init_ts_ws = True     self._create_ts_run()    await self._ts_send_chan.send(pack)   else:    await self._md_send_chan.send(pack)  def _create_ts_run(self):   ts_url = ""wss://trading-status.shinnytech.com/status""   conn_logger = self._api._logger.getChild(""TqConnect"")   ws_ts_send_chan = TqChan(self._api, chan_name=""send to ts"")   ws_ts_recv_chan = TqChan(self._api, chan_name=""recv from ts"")   ws_ts_send_chan._logger_bind(chan_from=""ts_reconn"", url=ts_url)   ws_ts_recv_chan._logger_bind(chan_to=""ts_reconn"", url=ts_url)   conn = TqConnect(logger=ShinnyLoggerAdapter(conn_logger, url=ts_url), conn_id=""ts"")   self._api.create_task(conn._run(self._api, ts_url, ws_ts_send_chan, ws_ts_recv_chan), _caller_api=True)   ts_reconnect = TsReconnectHandler(logger=ShinnyLoggerAdapter(self._logger.getChild(""TsReconnect""), url=ts_url))   self._ts_send_chan._logger_bind(chan_from=""ts"", url=ts_url)   self._ts_recv_chan._logger_bind(chan_to=""ts"", url=ts_url)   self._api.create_task(ts_reconnect._run(self._api, self._ts_send_chan, self._ts_recv_chan, ws_ts_send_chan, ws_ts_recv_chan), _caller_api=True) "
105,n\tqsdk\util,"n\tqsdk\util. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' import os import random import secrets from bisect import bisect_right from sgqlc.operation import Operation from pandas.core.internals import BlockManager from tqsdk.ins_schema import ins_schema, _add_all_frags RD = random.Random(secrets.randbits(128)) # 初始化随机数引擎，使用随机数作为seed，防止用户同时拉起多个策略，产生同样的 seed def _reinit_rd():  global RD  RD = random.Random(secrets.randbits(128)) try:  # fork 构造多进程策略时，需要在子进程中重新初始化 RD，否则会不同进程会生成相同的 uuid，产生重复报单或者相同 chart_id  os.register_at_fork(after_in_child=_reinit_rd) # 仅支持 Unix，且 pyversion >= 3.7 except AttributeError:  pass def _generate_uuid(prefix=''):  return f""{prefix + '_' if prefix else ''}{RD.getrandbits(128):032x}"" def _query_for_quote(symbol):  """"""  返回请求某个合约的合约信息的 query_pack  调用次函数应该全部都是sdk的代码主动请求合约信息  用户请求合约信息一定是 PYSDK_api 开头的请求，因为用户请求的合约信息在回测时带有 timestamp 参数，是不应该调用此函数的  """"""  symbol_list = symbol if isinstance(symbol, list) else [symbol]  op = Operation(ins_schema.rootQuery)  query = op.multi_symbol_info(instrument_id=symbol_list)  _add_all_frags(query)  return {   ""aid"": ""ins_query"",   ""query_id"": _generate_uuid(prefix='PYSDK_quote_'),   ""query"": op.__to_graphql__()  } def _query_for_init():  """"""  返回某些类型合约的 query  todo: 为了兼容旧版提供给用户的 api._data[""quote""].items() 类似用法，应该限制交易所 [""SHFE"", ""DCE"", ""CZCE"", ""INE"", ""CFFEX"", ""KQ""]  """"""  op = Operation(ins_schema.rootQuery)  query = op.multi_symbol_info(class_=[""FUTURE"", ""INDEX"", ""OPTION"", ""COMBINE"", ""CONT""],         exchange_id=[""SHFE"", ""DCE"", ""CZCE"", ""INE"", ""CFFEX"", ""KQ""])  _add_all_frags(query)  return op.__to_graphql__() night_trading_table = {  ""DCE.a"": [""21:00:00"", ""23:00:00""],  ""DCE.b"": [""21:00:00"", ""23:00:00""],  ""DCE.c"": [""21:00:00"", ""23:00:00""],  ""DCE.cs"": [""21:00:00"", ""23:00:00""],  ""DCE.m"": [""21:00:00"", ""23:00:00""],  ""DCE.y"": [""21:00:00"", ""23:00:00""],  ""DCE.p"": [""21:00:00"", ""23:00:00""],  ""DCE.l"": [""21:00:00"", ""23:00:00""],  ""DCE.v"": [""21:00:00"", ""23:00:00""],  ""DCE.pp"": [""21:00:00"", ""23:00:00""],  ""DCE.j"": [""21:00:00"", ""23:00:00""],  ""DCE.jm"": [""21:00:00"", ""23:00:00""],  ""DCE.i"": [""21:00:00"", ""23:00:00""],  ""DCE.eg"": [""21:00:00"", ""23:00:00""],  ""DCE.eb"": [""21:00:00"", ""23:00:00""],  ""DCE.rr"": [""21:00:00"", ""23:00:00""],  ""DCE.pg"": [""21:00:00"", ""23:00:00""],  ""CZCE.CF"": [""21:00:00"", ""23:00:00""],  ""CZCE.CY"": [""21:00:00"", ""23:00:00""],  ""CZCE.SA"": [""21:00:00"", ""23:00:00""],  ""CZCE.SR"": [""21:00:00"", ""23:00:00""],  ""CZCE.TA"": [""21:00:00"", ""23:00:00""],  ""CZCE.OI"": [""21:00:00"", ""23:00:00""],  ""CZCE.MA"": [""21:00:00"", ""23:00:00""],  ""CZCE.FG"": [""21:00:00"", ""23:00:00""],  ""CZCE.RM"": [""21:00:00"", ""23:00:00""],  ""CZCE.ZC"": [""21:00:00"", ""23:00:00""],  ""CZCE.TC"": [""21:00:00"", ""23:00:00""],  ""SHFE.rb"": [""21:00:00"", ""23:00:00""],  ""SHFE.hc"": [""21:00:00"", ""23:00:00""],  ""SHFE.fu"": [""21:00:00"", ""23:00:00""],  ""SHFE.bu"": [""21:00:00"", ""23:00:00""],  ""SHFE.ru"": [""21:00:00"", ""23:00:00""],  ""SHFE.sp"": [""21:00:00"", ""23:00:00""],  ""INE.nr"": [""21:00:00"", ""23:00:00""],  ""SHFE.cu"": [""21:00:00"", ""25:00:00""],  ""SHFE.al"": [""21:00:00"", ""25:00:00""],  ""SHFE.zn"": [""21:00:00"", ""25:00:00""],  ""SHFE.pb"": [""21:00:00"", ""25:00:00""],  ""SHFE.ni"": [""21:00:00"", ""25:00:00""],  ""SHFE.sn"": [""21:00:00"", ""25:00:00""],  ""SHFE.ss"": [""21:00:00"", ""25:00:00""],  ""SHFE.au"": [""21:00:00"", ""26:30:00""],  ""SHFE.ag"": [""21:00:00"", ""26:30:00""],  ""INE.sc"": [""21:00:00"", ""26:30:00""], } def _quotes_add_night(quotes):  """"""为 quotes 中应该有夜盘但是市价合约文件中没有夜盘的品种，添加夜盘时间""""""  for symbol in quotes:   product_id = quotes[symbol].get(""product_id"")   if quotes[symbol].get(""trading_time"") and product_id:    key = f""{quotes[symbol].get('exchange_id')}.{product_id}""    if key in night_trading_table and (not quotes[symbol][""trading_time""].get(""night"")):     quotes[symbol][""trading_time""][""night""] = [night_trading_table[key]] def _bisect_value(a, x, priority=""right""):  """"""  返回 bisect_right() 取得下标对应的值，当插入点距离前后元素距离相等，priority 表示优先返回右边的值还是左边的值  a: 必须是已经排序好（升序排列）的 list  bisect_right : Return the index where to insert item x in list a, assuming a is sorted.  """"""  assert priority in ['left', 'right']  insert_index = bisect_right(a, x)  if 0 < insert_index < len(a):   left_dis = x - a[insert_index - 1]   right_dis = a[insert_index] - x   if left_dis == right_dis:    mid_index = insert_index - 1 if priority == ""left"" else insert_index   elif left_dis < right_dis:    mid_index = insert_index - 1   else:    mid_index = insert_index  else:   assert insert_index == 0 or insert_index == len(a)   mid_index = 0 if insert_index == 0 else (len(a) - 1)  return a[mid_index] class BlockManagerUnconsolidated(BlockManager):  """"""mock BlockManager for unconsolidated, 不会因为自动合并同类型的 blocks 而导致 k 线数据不更新""""""  def __init__(self, *args, **kwargs):   BlockManager.__init__(self, *args, **kwargs)   self._is_consolidated = False   self._known_consolidated = False  def _consolidate_inplace(self): pass "
106,n\tqsdk\utils symbol,"n\tqsdk\utils symbol. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' from datetime import datetime from tqsdk.objs import Quote def _symbols_to_quotes(symbols, keys=set(Quote(None).keys())):  """"""将 symbols 转为 quotes，只输出 keys 包括的字段""""""  result = symbols.get(""result"", {})  quotes = {}  for k in result:   for symbol in result[k]:    quote = quotes.setdefault(symbol[""instrument_id""], {})    quote.update(_convert_symbol_to_quote(symbol, keys))    if symbol.get(""underlying""):     for edge in symbol[""underlying""][""edges""]:      underlying_symbol = edge[""node""]      if ""underlying_symbol"" in keys:       quote[""underlying_symbol""] = underlying_symbol[""instrument_id""]      underlying_quote = quotes.setdefault(underlying_symbol[""instrument_id""], {})      underlying_quote.update(_convert_symbol_to_quote(underlying_symbol, keys))      # 为期权合约补充 delivery_year delivery_month 商品期权根据标的赋值；金融期权与 exercise_year exercise_month 相同      # 为期权补充 delivery_year delivery_month 完全是为了兼容旧版合约服务      for key in [""delivery_year"", ""delivery_month""]:       if key in keys and symbol[""class""] == ""OPTION"":        if symbol[""exchange_id""] in [""DCE"", ""CZCE"", ""SHFE""]:         quote[key] = underlying_quote[key]        if symbol[""exchange_id""] == ""CFFEX"" and ""last_exercise_datetime"" in symbol:         if key == ""delivery_year"":          quote[key] = datetime.fromtimestamp(symbol[""last_exercise_datetime""] / 1e9).year         else:          quote[key] = datetime.fromtimestamp(symbol[""last_exercise_datetime""] / 1e9).month  for k in quotes:   if quotes[k].get(""ins_class"", """") == ""COMBINE"":    # 为组合合约补充 volume_multiple    leg1_quote = quotes.get(quotes[k].get(""leg1_symbol"", """"), {})    if leg1_quote:     if leg1_quote.get(""volume_multiple""):      quotes[k][""volume_multiple""] = leg1_quote[""volume_multiple""]  return quotes def _convert_symbol_to_quote(symbol, keys):  quote = {}  for key in keys:   if key == ""leg1_symbol"" and ""leg1"" in symbol:    quote[""leg1_symbol""] = symbol[""leg1""][""instrument_id""]   elif key == ""leg2_symbol"" and ""leg2"" in symbol:    quote[""leg2_symbol""] = symbol[""leg2""][""instrument_id""]   elif key == ""ins_class"" and ""class"" in symbol:    quote[""ins_class""] = symbol[""class""]   elif key == ""option_class"" and ""call_or_put"" in symbol:    quote[""option_class""] = symbol[""call_or_put""]   elif key == ""volume_multiple"" and ""index_multiple"" in symbol:    quote[""volume_multiple""] = symbol[""index_multiple""]   elif key == ""expire_datetime"" and symbol.get(""expire_datetime""):    quote[""expire_datetime""] = symbol[""expire_datetime""] / 1e9   elif key == ""last_exercise_datetime"" and symbol.get(""last_exercise_datetime""):    quote[""last_exercise_datetime""] = symbol[""last_exercise_datetime""] / 1e9   elif key == ""exercise_year"" and symbol.get(""last_exercise_datetime""):    quote[""exercise_year""] = datetime.fromtimestamp(symbol[""last_exercise_datetime""] / 1e9).year   elif key == ""exercise_month"" and symbol.get(""last_exercise_datetime""):    quote[""exercise_month""] = datetime.fromtimestamp(symbol[""last_exercise_datetime""] / 1e9).month   elif key == ""pre_settlement"" and ""settlement_price"" in symbol:    quote[""pre_settlement""] = symbol[""settlement_price""]   elif key in symbol:    quote[key] = symbol[key]  return quote"
107,n\tqsdk\  init ,"n\tqsdk\  init . #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' name = ""tqsdk"" from tqsdk.api import TqApi from tqsdk.tradeable import TqAccount, TqKq, TqKqStock, TqSim, TqSimStock from tqsdk.auth import TqAuth from tqsdk.channel import TqChan from tqsdk.backtest import TqBacktest, TqReplay from tqsdk.exceptions import BacktestFinished, TqBacktestPermissionError, TqTimeoutError, TqRiskRuleError from tqsdk.lib import TargetPosScheduler, TargetPosTask, InsertOrderUntilAllTradedTask, InsertOrderTask, TqNotify from tqsdk.multiaccount import TqMultiAccount from .__version__ import __version__ "
108,n\tqsdk\  version ,n\tqsdk\  version . __version__ = '3.2.12' 
109,n\tqsdk\algorithm\time table generate,"n\tqsdk\algorithm\time table generate. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' from datetime import datetime, time, timedelta from typing import Optional, Union import numpy as np import pandas as pd from pandas import DataFrame from tqsdk.api import TqApi from tqsdk import utils from tqsdk.datetime import _get_trading_timestamp, _get_trade_timestamp, _get_trading_day_from_timestamp, \  _datetime_to_timestamp_nano from tqsdk.rangeset import _rangeset_slice, _rangeset_head from tqsdk.tradeable import TqAccount, TqKq, TqSim def twap_table(api: TqApi, symbol: str, target_pos: int, duration: int, min_volume_each_step: int, max_volume_each_step: int,   account: Optional[Union[TqAccount, TqKq, TqSim]] = None):  """"""  返回基于 twap 策略的计划任务时间表。下单需要配合 TargetPosScheduler 使用。  Args:   api (TqApi): TqApi实例，该task依托于指定api下单/撤单   symbol (str): 拟下单的合约 symbol, 格式为 交易所代码.合约代码, 例如 ""SHFE.cu1801""   target_pos (int): 目标持仓手数   duration (int): 算法执行的时长，以秒为单位，时长可以跨非交易时间段，但是不可以跨交易日   * 设置为 60*10, 可以是 10:10～10:15 + 10:30~10:35   min_volume_each_step (int): 调整持仓手数最小值，每步调整的持仓手数默认在最小和最大值中产生   max_volume_each_step (int): 调整持仓手数最大值，每步调整的持仓手数默认在最小和最大值中产生   account (TqAccount/TqKq/TqSim): [可选]指定发送下单指令的账户实例, 多账户模式下，该参数必须指定  Returns:   pandas.DataFrame: 本函数返回一个 pandas.DataFrame 实例. 表示一份计划任务时间表。每一行表示一项目标持仓任务，包含以下列:    + interval: 当前这项任务的持续时间长度，单位为秒    + target_pos: 当前这项任务的目标持仓    + price: 当前这项任务的下单价格模式，支持 PASSIVE（排队价），ACTIVE（对价），None（不下单，表示暂停一段时间）  Example1::   from tqsdk import TqApi, TargetPosScheduler   from tqsdk.algorithm import twap_table   api = TqApi(auth=""信易账户,用户密码"")   quote = api.get_quote(""CZCE.MA109"")   # 设置twap任务参数   time_table = twap_table(api, ""CZCE.MA109"", -100, 600, 1, 5) # 目标持仓 -100 手，600s 内完成   print(time_table.to_string())   target_pos_sch = TargetPosScheduler(api, ""CZCE.MA109"", time_table)   # 启动循环   while not target_pos_sch.is_finished():    api.wait_update()   api.close()  Example2::   from tqsdk import TqApi, TargetPosScheduler   from tqsdk.algorithm import twap_table   api = TqApi(auth=""信易账户,用户密码"")   quote = api.get_quote(""CZCE.MA109"")   # 设置 twap 任务参数，   time_table = twap_table(api, ""CZCE.MA109"", -100, 600, 1, 5) # 目标持仓 -100 手，600s 内完成   # 定制化调整 time_table，例如希望第一项任务延迟 10s 再开始下单   # 可以在 time_table 的头部加一行   time_table = pandas.concat([    DataFrame([[10, 10, None]], columns=['interval', 'target_pos', 'price']),    time_table   ], ignore_index=True)   target_pos_sch = TargetPosScheduler(api, ""CZCE.MA109"", time_table)   while not target_pos_sch.is_finished():    api.wait_update()   # 获取 target_pos_sch 实例所有的成交列表   print(target_pos_sch.trades_df)   # 利用成交列表，您可以计算出策略的各种表现指标，例如：   average_trade_price = sum(scheduler.trades_df['price'] * scheduler.trades_df['volume']) / sum(scheduler.trades_df['volume'])   print(""成交均价:"", average_trade_price)   api.close()  """"""  account = api._account._check_valid(account)  if account is None:   raise Exception(f""多账户模式下, 需要指定账户实例 account"")  min_volume_each_step = int(min_volume_each_step)  max_volume_each_step = int(max_volume_each_step)  if max_volume_each_step <= 0 or min_volume_each_step <= 0:   raise Exception(""请调整参数, min_volume_each_step、max_volume_each_step 必须是大于 0 的整数。"")  if min_volume_each_step > max_volume_each_step:   raise Exception(""请调整参数, min_volume_each_step 必须小于 max_volume_each_step。"")  pos = api.get_position(symbol, account)  target_pos = int(target_pos)  delta_pos = target_pos - pos.pos  volume = abs(delta_pos) # 总的下单手数  # 得到有效的手数序列和时间间隔序列  if volume < max_volume_each_step:   interval_list, volume_list = [duration], [volume]  else:   volume_list = _gen_random_list(sum_val=volume, min_val=min_volume_each_step, max_val=max_volume_each_step)   interval = int(duration / len(volume_list))   if interval < 3:    raise Exception(""请调整参数, 每次下单时间间隔不能小于3s, 将单次下单手数阈值调大或者增长下单时间。"")   min_interval = int(max(3, interval - 2))   max_interval = int(interval * 2 - max(3, interval - 2)) + 1   interval_list = _gen_random_list(sum_val=duration, min_val=min_interval, max_val=max_interval,           length=len(volume_list))  time_table = DataFrame(columns=['interval', 'volume', 'price'])  for index, volume in enumerate(volume_list):   assert interval_list[index] >= 3   active_interval = 2   append_time_table = pd.DataFrame([    {""interval"": interval_list[index] - active_interval, ""volume"": volume, ""price"": ""PASSIVE""},    {""interval"": active_interval, ""volume"": 0, ""price"": ""ACTIVE""}   ])   time_table = pd.concat([time_table, append_time_table], ignore_index=True)  time_table['volume'] = time_table['volume'].mul(-1 if delta_pos < 0 else 1)  time_table['target_pos'] = time_table['volume'].cumsum()  time_table['target_pos'] = time_table['target_pos'].add(pos.pos)  time_table.drop(columns=['volume'], inplace=True)  time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})  return time_table def vwap_table(api: TqApi, symbol: str, target_pos: int, duration: float,    account: Optional[Union[TqAccount, TqKq, TqSim]] = None):  """"""  返回基于 vwap 策略的计划任务时间表。下单需要配合 TargetPosScheduler 使用。  调用 vwap_table 函数，根据以下逻辑生成 time_table：  1. 根据 target_pos - 当前合约的净持仓，得到总的需要调整手数  2. 请求 symbol 合约的 ``1min`` K 线  3. 采样取用最近 10 日内，以合约当前行情时间的下一分钟为起点，每日 duration / 60 根 K 线, \  例如当前合约时间为 14:35:35，那么采样是会使用 14:36:00 开始的分钟线 K 线  4. 按日期分组，分别计算交易日内，每根 K 线成交量占总成交量的比例  5. 计算最近 10 日内相同分钟内的成交量占比的算术平均数，将第 1 步得到的总调整手数按照得到的比例分配  6. 每一分钟，前 58s 以追加价格下单，后 2s 以对价价格下单  Args:   api (TqApi): TqApi实例，该task依托于指定api下单/撤单   symbol (str): 拟下单的合约 symbol, 格式为 交易所代码.合约代码, 例如 ""SHFE.cu2201""   target_pos (int): 目标持仓手数   duration (int): 算法执行的时长，以秒为单位，必须是 60 的整数倍，时长可以跨非交易时间段，但是不可以跨交易日   * 设置为 60*10, 可以是 10:10～10:15 + 10:30~10:35   account (TqAccount/TqKq/TqSim): [可选]指定发送下单指令的账户实例, 多账户模式下，该参数必须指定  Returns:   pandas.DataFrame: 本函数返回一个 pandas.DataFrame 实例. 表示一份计划任务时间表。每一行表示一项目标持仓任务，包含以下列:    + interval: 当前这项任务的持续时间长度，单位为秒    + target_pos: 当前这项任务的目标持仓    + price: 当前这项任务的下单价格模式，支持 PASSIVE（排队价），ACTIVE（对价），None（不下单，表示暂停一段时间）  Example1::   from tqsdk import TqApi, TargetPosScheduler   from tqsdk.algorithm import vwap_table   api = TqApi(auth=""信易账户,用户密码"")   quote = api.get_quote(""CZCE.MA109"")   # 设置 vwap 任务参数   time_table = vwap_table(api, ""CZCE.MA109"", -100, 600) # 目标持仓 -100 手，600s 内完成   print(time_table.to_string())   target_pos_sch = TargetPosScheduler(api, ""CZCE.MA109"", time_table)   # 启动循环   while not target_pos_sch.is_finished():    api.wait_update()   api.close()  """"""  account = api._account._check_valid(account)  if account is None:   raise Exception(f""多账户模式下, 需要指定账户实例 account"")  TIME_CELL = 60 # 等时长下单的时间单元, 单位: 秒  HISTORY_DAY_LENGTH = 10 # 使用多少天的历史数据用来计算每个时间单元的下单手数  if duration % TIME_CELL or duration < 60:   raise Exception(f""duration {duration} 参数应该为 {TIME_CELL} 的整数倍"")  pos = account.get_position(symbol)  target_pos = int(target_pos)  delta_pos = target_pos - pos.pos  target_volume = abs(delta_pos) # 总的下单手数  if target_volume == 0:   return DataFrame(columns=['interval', 'target_pos', 'price'])  # 获取 Kline  klines = api.get_kline_serial(symbol, TIME_CELL, data_length=int(10 * 60 * 60 / TIME_CELL * HISTORY_DAY_LENGTH))  klines[""time""] = klines.datetime.apply(lambda x: datetime.fromtimestamp(x // 1000000000).time()) # k线时间  klines[""date""] = klines.datetime.apply(lambda x: datetime.fromtimestamp(_get_trading_day_from_timestamp(x) // 1000000000).date()) # k线交易日  quote = api.get_quote(symbol)  # 当前交易日完整的交易时间段  trading_timestamp = _get_trading_timestamp(quote, quote.datetime)  trading_timestamp_nano_range = trading_timestamp['night'] + trading_timestamp['day'] # 当前交易日完整的交易时间段  # 当前时间 行情时间  current_timestamp_nano = _get_trade_timestamp(quote.datetime, float('nan'))  if not trading_timestamp_nano_range[0][0] <= current_timestamp_nano < trading_timestamp_nano_range[-1][1]:   raise Exception(""当前时间不在指定的交易时间段内"")  current_datetime = datetime.fromtimestamp(current_timestamp_nano//1000000000)  # 下一分钟的开始时间  next_datetime = current_datetime.replace(second=0) + timedelta(minutes=1)  start_datetime_nano = _datetime_to_timestamp_nano(next_datetime)  r = _rangeset_head(_rangeset_slice(trading_timestamp_nano_range, start_datetime_nano), int(duration * 1e9))  if not (r and trading_timestamp_nano_range[0][0] <= r[-1][-1] < trading_timestamp_nano_range[-1][1]):   raise Exception(""指定时间段超出当前交易日"")  start_datetime = datetime.fromtimestamp(start_datetime_nano // 1000000000)  end_datetime = datetime.fromtimestamp((r[-1][-1] - 1) // 1000000000)  time_slot_start = time(start_datetime.hour, start_datetime.minute) # 计划交易时段起始时间点  time_slot_end = time(end_datetime.hour, end_datetime.minute) # 计划交易时段终点时间点  if time_slot_end > time_slot_start: # 判断是否类似 23:00:00 开始， 01:00:00 结束这样跨天的情况   klines = klines[(klines[""time""] >= time_slot_start) & (klines[""time""] <= time_slot_end)]  else:   klines = klines[(klines[""time""] >= time_slot_start) | (klines[""time""] <= time_slot_end)]  # 获取在预设交易时间段内的所有K线, 即时间位于 time_slot_start 到 time_slot_end 之间的数据  need_date = klines['date'].drop_duplicates()[-HISTORY_DAY_LENGTH:]  klines = klines[klines['date'].isin(need_date)]  grouped_datetime = klines.groupby(['date', 'time'])['volume'].sum()  # 计算每个交易日内的预设交易时间段内的成交量总和(level=0: 表示按第一级索引""data""来分组)后,将每根k线的成交量除以所在交易日内的总成交量,计算其所占比例  volume_percent = grouped_datetime / grouped_datetime.groupby(level=0).sum()  predicted_percent = volume_percent.groupby(level=1).mean() # 将历史上相同时间单元的成交量占比使用算数平均计算出预测值  # 计算每个时间单元的成交量预测值  time_table = DataFrame(columns=['interval', 'volume', 'price'])  volume_left = target_volume # 剩余手数  percent_left = 1 # 剩余百分比  for index, value in predicted_percent.items():   volume = round(volume_left * (value / percent_left))   volume_left -= volume   percent_left -= value   append_time_table = pd.DataFrame([    {""interval"": TIME_CELL - 2, ""volume"": volume, ""price"": ""PASSIVE""},    {""interval"": 2, ""volume"": 0, ""price"": ""ACTIVE""}   ])   time_table = pd.concat([time_table, append_time_table], ignore_index=True)  time_table['volume'] = time_table['volume'].mul(np.sign(delta_pos))  time_table['target_pos'] = time_table['volume'].cumsum()  time_table['target_pos'] = time_table['target_pos'].add(pos.pos)  time_table.drop(columns=['volume'], inplace=True)  time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})  return time_table def _gen_random_list(sum_val: int, min_val: int, max_val: int, length: int = None):  """"""  生成随机列表，参数应该满足：min_val * length <= sum_val <= max_val * length  :param int sum_val: 列表元素之和  :param int min_val: 列表元素最小值  :param int max_val: 列表元素最大值  :param int length: 列表长度，如果没有指定，则返回的列表长度没有指定  :return: 整型列表，满足 sum(list) = sum_val, len(list) == length, min_val < any_item(list) < max_val  """"""  if length is None:   length = sum_val * 2 // (min_val + max_val) # 先确定 ist 长度，interval 大小，再生成 volume_list 随机列表   # 例如：sum = 16 min_val = 11 max_val = 15，不满足 min_val * length <= sum_val <= max_val * length   assert min_val * length <= sum_val <= max_val * length + min_val  else:   assert min_val * length <= sum_val <= max_val * length  result_list = [min_val for _ in range(length)]  if sum(result_list) == sum_val:   return result_list # 全部最小值刚好满足，可以提前退出  result_rest_value = sum_val - min_val * length # 剩余可以填充的个数  result_rest_position = (max_val - min_val) * length # 剩余需要填充的位置个数  if sum_val > max_val * length:   result_list.append(0)   result_rest_position += min_val  result_rest_list = _gen_shuffle_list(result_rest_value, result_rest_position)  for i in range(len(result_list)):   start = (max_val - min_val) * i   end = (max_val - min_val) * (i + 1) if start < (max_val - min_val) * length else result_rest_position   result_list[i] += sum(result_rest_list[start:end])  assert len(result_list) == length or len(result_list) == length + 1  assert sum(result_list) == sum_val  return result_list def _gen_shuffle_list(x: int, n: int):  """"""从 n 个位置中随机选中 x 个""""""  assert x <= n  result_list = [1 for _ in range(x)] + [0 for _ in range(n - x)]  utils.RD.shuffle(result_list)  return result_list "
110,n\tqsdk\algorithm\twa,"n\tqsdk\algorithm\twa. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'yanqiong' import asyncio from typing import Optional, Union from tqsdk.algorithm.time_table_generater import _gen_random_list from tqsdk.api import TqApi from tqsdk.channel import TqChan from tqsdk.datetime import _get_trading_timestamp, _get_trade_timestamp from tqsdk.lib import InsertOrderUntilAllTradedTask from tqsdk.tradeable import TqAccount, TqKq, TqSim from tqsdk.rangeset import _rangeset_slice, _rangeset_head, _rangeset_length class Twap(object):  """"""  天勤算法 - Twap  Twap 算法实现了在设定的交易时间段内，完成设定的下单手数。  构造 Twap 类的实例，该算法实例就会开始运行，根据以下逻辑下单：  1. 将用户设置的总手数，拆分为一个随机手数列表，列表的值即为每次下单的手数，列表元素之和为总下单手数，同时每次下单手数也符合用户设置的每次下单手数的上下限；  2. 将总的交易时间段拆分为随机时间间隔列表，列表的值即为每次下单的时间间隔，这些时间间隔相加应该等于总的下单时间；  3. 每一次下单，在两个列表中分别取出下单手数、下单预计完成的时间，先用跟盘价下单，在当前时间间隔已经过去 2/3 或者只剩下 2s 时，主动撤掉未成交单，用对手价下单剩余手数；  4. 在当前时间段已结束并且下单手数全部成交完，会开始下一次下单，重复第 3 步。  基于以上逻辑，用户参数应该满足：  平均每次下单时间 = duration / 下单次数 > 3s  其中，下单次数 = 总的下单手数 / 平均每次下单手数 = 总的下单手数 / ((单次委托单最小下单手数 + 单次委托单最大下单手数) / 2)  **注意**：  时间段 duration，以 s 为单位，时长可以跨非交易时间段，但是不可以跨交易日。  比如，SHFE.cu2101 的白盘交易时间段为 [""09:00:00"" ～ ""10:15:00""], [""10:30:00"", ""11:30:00""], [""13:30:00"", ""15:00:00""]，duration 设置为 1200 (20分钟)。  如果当前行情时间是 2020-09-15 09:10:00，那么下单的时间应该在 2020-09-15 09:10:00 ～ 2020-09-15 09:30:00；  如果当前行情时间是 2020-09-15 10:10:00，那么下单的时间应该在 2020-09-15 10:10:00 ～ 2020-09-15 10:15:00，以及 2020-09-15 10:30:00 ～ 2020-09-15 10:45:00。  本模块不支持在回测中使用。  """"""  def __init__(self, api: TqApi, symbol: str, direction: str, offset: str, volume: int, duration: float,     min_volume_each_order: int, max_volume_each_order: int,     account: Optional[Union[TqAccount, TqKq, TqSim]] = None):   """"""   创建 Twap 实例   Args:    api (TqApi): TqApi实例，该task依托于指定api下单/撤单    symbol (str): 拟下单的合约symbol, 格式为 交易所代码.合约代码, 例如 ""SHFE.cu1801""    direction (str): ""BUY"" 或 ""SELL""    offset (str): ""OPEN"", ""CLOSE""，""CLOSETODAY""    volume (int): 需要下单的总手数    duration (int): 算法执行的时长，以秒为单位，时长可以跨非交易时间段，但是不可以跨交易日    * 设置为 60*10, 可以是 10:10～10:15 + 10:30~10:35    min_volume_each_order (int):单笔最小委托单，每笔委托单数默认在最小和最大值中产生    max_volume_each_order (int):单笔最大委托单，每笔委托单数默认在最小和最大值中产生    account (TqAccount/TqKq/TqSim): [可选]指定发送下单指令的账户实例, 多账户模式下，该参数必须指定   Example1::   from tqsdk import TqApi   from tqsdk.algorithm import Twap   api = TqApi(auth=""信易账户,用户密码"")   # 设置twap任务参数   target_twap = Twap(api,""SHFE.rb2012"",""BUY"",""OPEN"",500,300,10,25)   # 启动循环   while True:    api.wait_update()    if target_twap.is_finished():     break   api.close()   Example2::   from tqsdk import TqApi   from tqsdk.algorithm import Twap   api = TqApi(auth=""信易账户,用户密码"")   target_twap = Twap(api,""SHFE.rb2012"",""BUY"",""OPEN"",500,300,10,25)   num_of_trades = 0   while True:    api.wait_update()    if num_of_trades < len(target_twap.trades):    # 最新的成交    for i in range(num_of_trades - len(target_twap.trades), 0):     print(""新的成交"", target_twap.trades[i])    print(target_twap.average_trade_price) # 打印出当前已经成交的平均价格    num_of_trades = len(target_twap.trades)    if target_twap.is_finished():     break   print(""打印出 twap 全部成交以及成交均价"")   print(target_twap.trades)   print(target_twap.average_trade_price)   api.close()   """"""   if symbol.startswith(""CZCE.CJ""):    raise Exception(""红枣期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 4 手，这些函数还未支持该规则!"")   if symbol.startswith(""CZCE.ZC""):    raise Exception(""动力煤期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 4 手，这些函数还未支持该规则!"")   if symbol.startswith(""CZCE.WH""):    raise Exception(""强麦期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 10 手，这些函数还未支持该规则!"")   if symbol.startswith(""CZCE.PM""):    raise Exception(""普麦期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 10 手，这些函数还未支持该规则!"")   if symbol.startswith(""CZCE.RI""):    raise Exception(""早籼稻期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 10 手，这些函数还未支持该规则!"")   if symbol.startswith(""CZCE.JR""):    raise Exception(""粳稻期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 10 手，这些函数还未支持该规则!"")   if symbol.startswith(""CZCE.LR""):    raise Exception(""晚籼稻期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 10 手，这些函数还未支持该规则!"")   self._api = api   self._account = api._account._check_valid(account)   if self._account is None:    raise Exception(f""多账户模式下, 需要指定账户实例 account"")   self._symbol = symbol   self._direction = direction   self._offset = offset   self._volume = int(volume)   self._duration = duration   self._min_volume_each_order = int(min_volume_each_order)   self._max_volume_each_order = int(max_volume_each_order)   if self._max_volume_each_order <= 0 or self._min_volume_each_order <= 0:    raise Exception(""请调整参数, min_volume_each_order、max_volume_each_order 必须是大于 0 的整数。"")   if self._min_volume_each_order > self._max_volume_each_order:    raise Exception(""请调整参数, min_volume_each_order 必须小于 max_volume_each_order。"")   # 得到有效的手数序列和时间间隔序列   volume_list, interval_list = self._get_volume_list()   self._task = self._api.create_task(self._run(volume_list, interval_list))   self._order_task = None   self.trades = [] # 所有的 trade 列表   self._trade_sum_volume = 0 # 所有 trade 的成交的总手数   self._trade_sum_amount = 0 # 所有 trade 的成交的总支出 （手数*价格）   self._trade_objs_chan = TqChan(self._api)   self._trade_recv_task = self._api.create_task(self._trade_recv())  @property  def average_trade_price(self):   # 平均成交价格   if self._trade_sum_volume == 0:    return float('nan')   else:    return self._trade_sum_amount / self._trade_sum_volume  async def _run(self, volume_list, interval_list):   self._quote = await self._api.get_quote(self._symbol)   # 计算得到时间序列，每个时间段快要结束的时间点，此时应该从被动价格切换为主动价格   deadline_timestamp_list, strict_deadline_timestamp_list = self._get_deadline_timestamp(interval_list)   for i in range(len(volume_list)):    exit_immediately = (i + 1 == len(volume_list)) # 如果是最后一个时间段，需要全部成交后立即退出    await self._insert_order(volume_list[i], deadline_timestamp_list[i], strict_deadline_timestamp_list[i],          exit_immediately)  async def _trade_recv(self):   try:    async for trade in self._trade_objs_chan:     self.trades.append(trade)     self._trade_sum_volume += trade['volume']     self._trade_sum_amount += trade['volume'] * trade['price']   finally:    await self._trade_objs_chan.close()  def _get_deadline_timestamp(self, interval_list):   # interval - min(5, interval / 3) # 定义一个时间片段中，开始到快要结束的时间间隔   # 使用 rangeSet 计算出时间段；都使用本地时间或者都使用 **行情时间**   # 当前交易日完整的交易时间段   trading_timestamp = _get_trading_timestamp(self._quote, self._quote.datetime)   trading_timestamp_nano_range = trading_timestamp['night'] + trading_timestamp['day'] # 当前交易日完整的交易时间段   # 当前时间 行情时间   current_timestamp_nano = _get_trade_timestamp(self._quote.datetime, float('nan'))   if not trading_timestamp_nano_range[0][0] <= current_timestamp_nano < trading_timestamp_nano_range[-1][1]:    raise Exception(""当前时间不在指定的交易时间段内"")   # 此时，current_timestamp_nano 一定在此交易日内   deadline_timestamp_list = []   strict_deadline_timestamp_list = []   for interval in interval_list:    r = _rangeset_head(_rangeset_slice(trading_timestamp_nano_range, current_timestamp_nano), int(interval*1e9))    strict_interval = interval - min(2, interval / 3)    strict_r = _rangeset_head(_rangeset_slice(trading_timestamp_nano_range, current_timestamp_nano), int(strict_interval*1e9))    if _rangeset_length(r) < int(interval*1e9):     raise Exception(""指定时间段超出当前交易日"")    deadline_timestamp_list.append(r[-1][1])    strict_deadline_timestamp_list.append(strict_r[-1][1])    current_timestamp_nano = r[-1][1]   return deadline_timestamp_list, strict_deadline_timestamp_list  async def _insert_order(self, volume, end_time, strict_end_time, exit_immediately):   volume_left = volume   try:    trade_chan = TqChan(self._api)    self._order_task = InsertOrderUntilAllTradedTask(self._api, self._symbol, self._direction, self._offset,                volume=volume, price=""PASSIVE"", trade_chan=trade_chan,                trade_objs_chan=self._trade_objs_chan,                account=self._account)    async with self._api.register_update_notify() as update_chan:     async for _ in update_chan:      if _get_trade_timestamp(self._quote.datetime, float('nan')) > strict_end_time:       break      else:       while not trade_chan.empty():        v = await trade_chan.recv()        volume_left = volume_left - (v if self._direction == ""BUY"" else -v)       if exit_immediately and volume_left == 0:        break   finally:    self._order_task._task.cancel()    await asyncio.gather(self._order_task._task, return_exceptions=True)    while not trade_chan.empty():     v = await trade_chan.recv()     volume_left = volume_left - (v if self._direction == ""BUY"" else -v)    await trade_chan.close()    if volume_left > 0:     await self._insert_order_active(volume_left)  async def _insert_order_active(self, volume):   try:    trade_chan = TqChan(self._api)    self._order_task = InsertOrderUntilAllTradedTask(self._api, self._symbol, self._direction, self._offset,                volume=volume, price=""ACTIVE"", trade_chan=trade_chan,                trade_objs_chan=self._trade_objs_chan,                account=self._account)    async for v in trade_chan:     volume = volume - (v if self._direction == ""BUY"" else -v)     if volume == 0:      break   finally:    await trade_chan.close()    self._order_task._task.cancel()    await asyncio.gather(self._order_task._task, return_exceptions=True)  def _get_volume_list(self):   if self._volume < self._max_volume_each_order:    return [self._volume], [self._duration]   # 先确定 volume_list   volume_list = _gen_random_list(sum_val=self._volume, min_val=self._min_volume_each_order, max_val=self._max_volume_each_order)   interval = int(self._duration / len(volume_list))   if interval < 3:    raise Exception(""请调整参数, 每次下单时间间隔不能小于3s, 将单次下单手数阈值调大或者增长下单时间。"")   min_interval = int(max(3, interval - 2))   max_interval = int(interval * 2 - max(3, interval - 2)) + 1   interval_list = _gen_random_list(sum_val=self._duration, min_val=min_interval, max_val=max_interval, length=len(volume_list))   return volume_list, interval_list  def cancel(self):   """"""   取消当前 Twap 算法实例，会将该实例已经发出但还是未成交的委托单撤单。   Example::   from tqsdk import TqApi   from tqsdk.algorithm import Twap   api = TqApi(auth=""信易账户,用户密码"")   # 设置twap任务参数   quote = api.get_quote(""SHFE.rb2012"")   target_twap = Twap(api,""SHFE.rb2012"",""BUY"",""OPEN"",500,300,10,25)   api.wait_update()   # 运行代码。。。   target_twap.cancel()   while True:    api.wait_update()    if target_twap.is_finished():     break   api.close()   """"""   if self._task.done():    return   self._task.cancel()  def is_finished(self):   """"""   返回当前 Twap 算法实例是否已经结束。即此实例不会再发出下单或者撤单的任何动作。   Returns:    bool: 当前 Twap 算法实例是否已经结束   """"""   return self._task.done() "
111,n\tqsdk\algorithm\  init ,"n\tqsdk\algorithm\  init . #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'yanqiong' from tqsdk.algorithm.twap import Twap from tqsdk.algorithm.time_table_generater import twap_table, vwap_table "
112,n\tqsdk\backtest\backtes,"n\tqsdk\backtest\backtes. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' import asyncio import math from datetime import date, datetime from typing import Union, Any, List, Dict from tqsdk.backtest.utils import TqBacktestContinuous, TqBacktestDividend from tqsdk.channel import TqChan from tqsdk.datetime import _get_trading_day_start_time, _get_trading_day_end_time, _get_trading_day_from_timestamp, \  _timestamp_nano_to_str, _datetime_to_timestamp_nano from tqsdk.diff import _merge_diff, _get_obj from tqsdk.entity import Entity from tqsdk.exceptions import BacktestFinished from tqsdk.objs import Kline, Tick from tqsdk.rangeset import _rangeset_range_union, _rangeset_difference, _rangeset_union from tqsdk.utils import _generate_uuid, _query_for_quote class BtQuote(Entity):  """""" Quote 是一个行情对象 """"""  def __init__(self, api):   self._api = api   self.price_tick: float = float(""nan"") class TqBacktest(object):  """"""  天勤回测类  将该类传入 TqApi 的构造函数, 则策略就会进入回测模式。  回测模式下 k线会在刚创建出来时和结束时分别更新一次, 在这之间 k线是不会更新的。  回测模式下 quote 的更新频率由所订阅的 tick 和 k线周期确定:   * 只要订阅了 tick, 则对应合约的 quote 就会使用 tick 生成, 更新频率也和 tick 一致, 但 **只有下字段** :   datetime/ask&bid_price1/ask&bid_volume1/last_price/highest/lowest/average/volume/amount/open_interest/   price_tick/price_decs/volume_multiple/max&min_limit&market_order_volume/underlying_symbol/strike_price   * 如果没有订阅 tick, 但是订阅了 k线, 则对应合约的 quote 会使用 k线生成, 更新频率和 k线的周期一致， 如果订阅了某个合约的多个周期的 k线,   则任一个周期的 k线有更新时, quote 都会更新. 使用 k线生成的 quote 的盘口由收盘价分别加/减一个最小变动单位, 并且 highest/lowest/average/amount   始终为 nan, volume 始终为0   * 如果即没有订阅 tick, 也没有订阅k线或 订阅的k线周期大于分钟线, 则 TqBacktest 会 **自动订阅分钟线** 来生成 quote   * 如果没有订阅 tick, 但是订阅了 k线, 则对应合约的 quote **只有下字段** :   datetime/ask&bid_price1/ask&bid_volume1/last_price/open_interest/   price_tick/price_decs/volume_multiple/max&min_limit&market_order_volume/underlying_symbol/strike_price  **注意** ：如果未订阅 quote，模拟交易在下单时会自动为此合约订阅 quote ，根据回测时 quote 的更新规则，如果此合约没有订阅K线或K线周期大于分钟线 **则会自动订阅一个分钟线** 。  模拟交易要求报单价格大于等于对手盘价格才会成交, 例如下买单, 要求价格大于等于卖一价才会成交, 如果不能立即成交则会等到下次行情更新再重新判断。  回测模式下 wait_update 每次最多推进一个行情时间。  回测结束后会抛出 BacktestFinished 例外。  对 **组合合约** 进行回测时需注意：只能通过订阅 tick 数据来回测，不能订阅K线，因为K线是由最新价合成的，而交易所发回的组合合约数据中无最新价。  """"""  def __init__(self, start_dt: Union[date, datetime], end_dt: Union[date, datetime]) -> None:   """"""   创建天勤回测类   Args:    start_dt (date/datetime): 回测起始时间, 如果类型为 date 则指的是交易日, 如果为 datetime 则指的是具体时间点    end_dt (date/datetime): 回测结束时间, 如果类型为 date 则指的是交易日, 如果为 datetime 则指的是具体时间点   """"""   if isinstance(start_dt, datetime):    self._start_dt = _datetime_to_timestamp_nano(start_dt)   elif isinstance(start_dt, date):    self._start_dt = _get_trading_day_start_time(     _datetime_to_timestamp_nano(datetime(start_dt.year, start_dt.month, start_dt.day)))   else:    raise Exception(""回测起始时间(start_dt)类型 %s 错误, 请检查 start_dt 数据类型是否填写正确"" % (type(start_dt)))   if isinstance(end_dt, datetime):    self._end_dt = _datetime_to_timestamp_nano(end_dt)   elif isinstance(end_dt, date):    self._end_dt = _get_trading_day_end_time(     _datetime_to_timestamp_nano(datetime(end_dt.year, end_dt.month, end_dt.day)))   else:    raise Exception(""回测结束时间(end_dt)类型 %s 错误, 请检查 end_dt 数据类型是否填写正确"" % (type(end_dt)))   self._current_dt = self._start_dt   # 记录当前的交易日 开始时间/结束时间   self._trading_day = _get_trading_day_from_timestamp(self._current_dt)   self._trading_day_start = _get_trading_day_start_time(self._trading_day)   self._trading_day_end = _get_trading_day_end_time(self._trading_day)  async def _run(self, api, sim_send_chan, sim_recv_chan, md_send_chan, md_recv_chan):   """"""回测task""""""   self._api = api   # 下载历史主连合约信息   start_trading_day = _get_trading_day_from_timestamp(self._start_dt) # 回测开始交易日   end_trading_day = _get_trading_day_from_timestamp(self._end_dt) # 回测结束交易日   self._continuous_table = TqBacktestContinuous(start_dt=start_trading_day,              end_dt=end_trading_day,              headers=self._api._base_headers)   self._stock_dividend = TqBacktestDividend(start_dt=start_trading_day,             end_dt=end_trading_day,             headers=self._api._base_headers)   self._logger = api._logger.getChild(""TqBacktest"") # 调试信息输出   self._sim_send_chan = sim_send_chan   self._sim_recv_chan = sim_recv_chan   self._md_send_chan = md_send_chan   self._md_recv_chan = md_recv_chan   self._pending_peek = False   self._data = Entity() # 数据存储   self._data._instance_entity([])   self._prototype = {    ""quotes"": {     ""#"": BtQuote(self._api), # 行情的数据原型    },    ""klines"": {     ""*"": {      ""*"": {       ""data"": {        ""@"": Kline(self._api), # K线的数据原型       }      }     }    },    ""ticks"": {     ""*"": {      ""data"": {       ""@"": Tick(self._api), # Tick的数据原型      }     }    }   }   self._sended_to_api = {} # 已经发给 api 的 rangeset (symbol, dur)，只记录了 kline   self._serials = {} # 所有用户请求的 chart 序列，如果用户订阅行情，默认请求 1 分钟 Kline   # gc 是会循环 self._serials，来计算用户需要的数据，self._serials 不应该被删除，   self._generators = {} # 所有用户请求的 chart 序列相应的 generator 对象，创建时与 self._serials 一一对应，会在一个序列计算到最后一根 kline 时被删除   self._had_any_generator = False # 回测过程中是否有过 generator 对象   self._sim_recv_chan_send_count = 0 # 统计向下游发送的 diff 的次数，每 1w 次执行一次 gc   self._quotes = {} # 记录 min_duration 记录某一合约的最小duration； sended_init_quote 是否已经过这个合约的初始行情   self._diffs: List[Dict[str, Any]] = []   self._is_first_send = True   md_task = self._api.create_task(self._md_handler())   try:    await self._send_snapshot()    async for pack in self._sim_send_chan:     if pack[""aid""] == ""ins_query"":      await self._md_send_chan.send(pack)      # 回测 query 不为空时需要ensure_query      # 1. 在api初始化时会发送初始化请求（2.5.0版本开始已经不再发送初始化请求），接着会发送peek_message，如果这里没有等到结果，那么在收到 peek_message 的时候，会发现没有数据需要发送，回测结束      # 2. api在发送请求后，会调用 wait_update 更新数据，如果这里没有等到结果，行情可能会被推进      # query 为空时，表示清空数据的请求，这个可以直接发出去，不需要等到收到回复      if pack[""query""] != """":       await self._ensure_query(pack)      await self._send_diff()     elif pack[""aid""] == ""subscribe_quote"":      # todo: 回测时，用户如果先订阅日线，再订阅行情，会直接返回以日线 datetime 标识的行情信息，而不是当前真正的行情时间      self._diffs.append({       ""ins_list"": pack[""ins_list""]      })      for ins in pack[""ins_list""].split("",""):       await self._ensure_quote(ins)      await self._send_diff() # 处理上一次未处理的 peek_message     elif pack[""aid""] == ""set_chart"":      if pack[""ins_list""]:       # 回测模块中已保证每次将一个行情时间的数据全部发送给api，因此更新行情时 保持与初始化时一样的charts信息（即不作修改）       self._diffs.append({        ""charts"": {         pack[""chart_id""]: {          # 两个id设置为0：保证api在回测中判断此值时不是-1，即直接通过对数据接收完全的验证          ""left_id"": 0,          ""right_id"": 0,          ""more_data"": False, # 直接发送False给api，表明数据发送完全，使api中通过数据接收完全的验证          ""state"": pack         }        }       })       await self._ensure_serial(pack[""ins_list""], pack[""duration""], pack[""chart_id""])      else:       self._diffs.append({        ""charts"": {         pack[""chart_id""]: None        }       })      await self._send_diff() # 处理上一次未处理的 peek_message     elif pack[""aid""] == ""peek_message"":      self._pending_peek = True      await self._send_diff()   finally:    # 关闭所有 generator    for s in self._generators.values():     await s.aclose()    md_task.cancel()    await asyncio.gather(md_task, return_exceptions=True)  async def _md_handler(self):   async for pack in self._md_recv_chan:    await self._md_send_chan.send({     ""aid"": ""peek_message""    })    recv_quotes = False    for d in pack.get(""data"", []):     _merge_diff(self._data, d, self._prototype, persist=False, reduce_diff=False)     # 收到的 quotes 转发给下游     quotes = d.get(""quotes"", {})     if quotes:      recv_quotes = True      quotes = self._update_valid_quotes(quotes) # 删去回测 quotes 不应该下发的字段      self._diffs.append({""quotes"": quotes})     # 收到的 symbols 应该转发给下游     if d.get(""symbols""):      self._diffs.append({""symbols"": d[""symbols""]})    # 如果没有收到 quotes（合约信息），或者当前的 self._data.get('quotes', {}) 里没有股票，那么不应该向 _diffs 里添加元素    if recv_quotes:     quotes_stock = self._stock_dividend._get_dividend(self._data.get('quotes', {}), self._trading_day)     if quotes_stock:      self._diffs.append({""quotes"": quotes_stock})  def _update_valid_quotes(self, quotes):   # 从 quotes 返回只剩余合约信息的字段的 quotes，防止发生未来数据发送给下游   # backtest 模块会生成的数据   invalid_keys = {f""{d}{i+1}"" for d in ['ask_price', 'ask_volume', 'bid_price', 'bid_volume'] for i in range(5)}   invalid_keys.union({'datetime', 'last_price', 'highest', 'lowest', 'average', 'volume', 'amount', 'open_interest'})   invalid_keys.union({'cash_dividend_ratio', 'stock_dividend_ratio'}) # 这两个字段完全由 self._stock_dividend 负责处理   # backtest 模块不会生成的数据，下游服务也不应该收到的数据   invalid_keys.union({'open', 'close', 'settlement', 'lowest', 'lower_limit', 'upper_limit', 'pre_open_interest', 'pre_settlement', 'pre_close', 'expired'})   for symbol, quote in quotes.items():    [quote.pop(k, None) for k in invalid_keys]    if symbol.startswith(""KQ.m""):     quote.pop(""underlying_symbol"", None)    if quote.get('expire_datetime'):     # 先删除所有的 quote 的 expired 字段，只在有 expire_datetime 字段时才会添加 expired 字段     quote['expired'] = quote.get('expire_datetime') * 1000000000 <= self._trading_day_start   return quotes  async def _send_snapshot(self):   """"""发送初始合约信息""""""   async with TqChan(self._api, last_only=True) as update_chan: # 等待与行情服务器连接成功    self._data[""_listener""].add(update_chan)    while self._data.get(""mdhis_more_data"", True):     await update_chan.recv()   # 发送初始行情(合约信息截面)时   quotes = {}   for ins, quote in self._data[""quotes""].items():    if not ins.startswith(""_""):     trading_time = quote.get(""trading_time"", {})     quotes[ins] = {      ""open"": None, # 填写None: 删除api中的这个字段      ""close"": None,      ""settlement"": None,      ""lower_limit"": None,      ""upper_limit"": None,      ""pre_open_interest"": None,      ""pre_settlement"": None,      ""pre_close"": None,      ""ins_class"": quote.get(""ins_class"", """"),      ""instrument_id"": quote.get(""instrument_id"", """"),      ""exchange_id"": quote.get(""exchange_id"", """"),      ""margin"": quote.get(""margin""), # 用于内部实现模拟交易, 不作为api对外可用数据（即 Quote 类中无此字段）      ""commission"": quote.get(""commission""), # 用于内部实现模拟交易, 不作为api对外可用数据（即 Quote 类中无此字段）      ""price_tick"": quote[""price_tick""],      ""price_decs"": quote[""price_decs""],      ""volume_multiple"": quote[""volume_multiple""],      ""max_limit_order_volume"": quote[""max_limit_order_volume""],      ""max_market_order_volume"": quote[""max_market_order_volume""],      ""min_limit_order_volume"": quote[""min_limit_order_volume""],      ""min_market_order_volume"": quote[""min_market_order_volume""],      ""underlying_symbol"": quote[""underlying_symbol""],      ""strike_price"": quote[""strike_price""],      ""expired"": quote.get('expire_datetime', float('nan')) <= self._trading_day_start, # expired 默认值就是 False      ""trading_time"": {""day"": trading_time.get(""day"", []), ""night"": trading_time.get(""night"", [])},      ""expire_datetime"": quote.get(""expire_datetime""),      ""delivery_month"": quote.get(""delivery_month""),      ""delivery_year"": quote.get(""delivery_year""),      ""option_class"": quote.get(""option_class"", """"),      ""product_id"": quote.get(""product_id"", """"),     }   # 修改历史主连合约信息   cont_quotes = self._continuous_table._get_history_cont_quotes(self._trading_day)   for k, v in cont_quotes.items():    quotes.setdefault(k, {}) # 实际上，初始行情截面中只有下市合约，没有主连    quotes[k].update(v)   self._diffs.append({    ""quotes"": quotes,    ""ins_list"": """",    ""mdhis_more_data"": False,    ""_tqsdk_backtest"": self._get_backtest_time()   })  async def _send_diff(self):   """"""发送数据到 api, 如果 self._diffs 不为空则发送 self._diffs, 不推进行情时间, 否则将时间推进一格, 并发送对应的行情""""""   if self._pending_peek:    if not self._diffs:     quotes = await self._generator_diffs(False)    else:     quotes = await self._generator_diffs(True)    for ins, diff in quotes.items():     self._quotes[ins][""sended_init_quote""] = True     for d in diff:      self._diffs.append({       ""quotes"": {        ins: d       }      })    if self._diffs:     # 发送数据集中添加 backtest 字段，开始时间、结束时间、当前时间，表示当前行情推进是由 backtest 推进     self._diffs.append({""_tqsdk_backtest"": self._get_backtest_time()})     # 切换交易日，将历史的主连合约信息添加的 diffs     if self._current_dt > self._trading_day_end:      # 使用交易日结束时间，每个交易日切换只需要计算一次交易日结束时间      # 相比发送 diffs 前每次都用 _current_dt 计算当前交易日，计算次数更少      self._trading_day = _get_trading_day_from_timestamp(self._current_dt)      self._trading_day_start = _get_trading_day_start_time(self._trading_day)      self._trading_day_end = _get_trading_day_end_time(self._trading_day)      self._diffs.append({       ""quotes"": self._continuous_table._get_history_cont_quotes(self._trading_day)      })      self._diffs.append({       ""quotes"": self._stock_dividend._get_dividend(self._data.get('quotes'), self._trading_day)      })      self._diffs.append({       ""quotes"": {k: {'expired': v.get('expire_datetime', float('nan')) <= self._trading_day_start}         for k, v in self._data.get('quotes').items()}      })     self._sim_recv_chan_send_count += 1     if self._sim_recv_chan_send_count > 10000:      self._sim_recv_chan_send_count = 0      self._diffs.append(self._gc_data())     rtn_data = {      ""aid"": ""rtn_data"",      ""data"": self._diffs,     }     self._diffs = []     self._pending_peek = False     await self._sim_recv_chan.send(rtn_data)  async def _generator_diffs(self, keep_current):   """"""   keep_current 为 True 表示不会推进行情，为 False 表示需要推进行情   即 self._diffs 为 None 并且 keep_current = True 会推进行情   """"""   quotes = {}   while self._generators:    # self._generators 存储了 generator，self._serials 记录一些辅助的信息    min_request_key = min(self._generators.keys(), key=lambda serial: self._serials[serial][""timestamp""])    timestamp = self._serials[min_request_key][""timestamp""] # 所有已订阅数据中的最小行情时间    quotes_diff = self._serials[min_request_key][""quotes""]    if timestamp < self._current_dt and self._quotes.get(min_request_key[0], {}).get(""sended_init_quote""):     # 先订阅 A 合约，再订阅 A 合约日线，那么 A 合约的行情时间会回退: 2021-01-04 09:31:59.999999 -> 2021-01-01 18:00:00.000000     # 如果当前 timestamp 小于 _current_dt，那么这个 quote_diff 不需要发到下游     # 如果先订阅 A 合约（有夜盘），时间停留在夜盘开始时间， 再订阅 B 合约（没有夜盘），那么 B 合约的行情（前一天收盘时间）应该发下去，     # 否则 get_quote(B) 等到收到行情才返回，会直接把时间推进到第二天白盘。     quotes_diff = None    # 推进时间，一次只会推进最多一个(补数据时有可能是0个)行情时间，并确保<=该行情时间的行情都被发出    # 如果行情时间大于当前回测时间 则 判断是否diff中已有数据；否则表明此行情时间的数据未全部保存在diff中，则继续append    if timestamp > self._current_dt:     if self._diffs or keep_current: # 如果diffs中已有数据：退出循环并发送数据给下游api      break     else:      self._current_dt = timestamp # 否则将回测时间更新至最新行情时间    diff = self._serials[min_request_key][""diff""]    self._diffs.append(diff)    # klines 请求，需要记录已经发送 api 的数据    for symbol in diff.get(""klines"", {}):     for dur in diff[""klines""][symbol]:      for kid in diff[""klines""][symbol][dur][""data""]:       rs = self._sended_to_api.setdefault((symbol, int(dur)), [])       kid = int(kid)       self._sended_to_api[(symbol, int(dur))] = _rangeset_range_union(rs, (kid, kid + 1))    quote_info = self._quotes[min_request_key[0]]    if quotes_diff and (quote_info[""min_duration""] != 0 or min_request_key[1] == 0):     quotes[min_request_key[0]] = quotes_diff    await self._fetch_serial(min_request_key)   if self._had_any_generator and not self._generators and not self._diffs: # 当无可发送数据时则抛出BacktestFinished例外,包括未订阅任何行情 或 所有已订阅行情的最后一笔行情获取完成    self._api._print(""回测结束"")    self._logger.debug(""backtest finished"")    if self._current_dt < self._end_dt:     self._current_dt = 2145888000000000000 # 一个远大于 end_dt 的日期 20380101    await self._sim_recv_chan.send({     ""aid"": ""rtn_data"",     ""data"": [{""_tqsdk_backtest"": self._get_backtest_time()}]    })    await self._api._wait_until_idle()    raise BacktestFinished(self._api) from None   return quotes  def _get_backtest_time(self) -> dict:   if self._is_first_send:    self._is_first_send = False    return {      ""start_dt"": self._start_dt,      ""current_dt"": self._current_dt,      ""end_dt"": self._end_dt     }   else:    return {     ""current_dt"": self._current_dt    }  async def _ensure_serial(self, ins, dur, chart_id=None):   if (ins, dur) not in self._serials:    quote = self._quotes.setdefault(ins, { # 在此处设置 min_duration: 每次生成K线的时候会自动生成quote, 记录某一合约的最小duration     ""min_duration"": dur    })    quote[""min_duration""] = min(quote[""min_duration""], dur)    self._serials[(ins, dur)] = {     ""chart_id_set"": {chart_id} if chart_id else set() # 记录当前 serial 对应的 chart_id    }    self._generators[(ins, dur)] = self._gen_serial(ins, dur)    self._had_any_generator = True    await self._fetch_serial((ins, dur))   elif chart_id:    self._serials[(ins, dur)][""chart_id_set""].add(chart_id)  async def _ensure_query(self, pack):   """"""一定收到了对应 query 返回的包""""""   query_pack = {""query"": pack[""query""]}   if query_pack.items() <= self._data.get(""symbols"", {}).get(pack[""query_id""], {}).items():    return   async with TqChan(self._api, last_only=True) as update_chan:    self._data[""_listener""].add(update_chan)    while not query_pack.items() <= self._data.get(""symbols"", {}).get(pack[""query_id""], {}).items():     await update_chan.recv()  async def _ensure_quote(self, ins):   # 在接新版合约服务器后，合约信息程序运行过程中查询得到的，这里不再能保证合约一定存在，需要添加 quote 默认值   quote = _get_obj(self._data, [""quotes"", ins], BtQuote(self._api))   if math.isnan(quote.get(""price_tick"")):    query_pack = _query_for_quote(ins)    await self._md_send_chan.send(query_pack)    async with TqChan(self._api, last_only=True) as update_chan:     quote[""_listener""].add(update_chan)     while math.isnan(quote.get(""price_tick"")):      await update_chan.recv()   if ins not in self._quotes or self._quotes[ins][""min_duration""] > 60000000000:    await self._ensure_serial(ins, 60000000000)  async def _fetch_serial(self, key):   s = self._serials[key]   try:    s[""timestamp""], s[""diff""], s[""quotes""] = await self._generators[key].__anext__()   except StopAsyncIteration:    del self._generators[key] # 删除一个行情时间超过结束时间的 generator  async def _gen_serial(self, ins, dur):   """"""k线/tick 序列的 async generator, yield 出来的行情数据带有时间戳, 因此 _send_diff 可以据此归并""""""   # 先定位左端点, focus_datetime 是 lower_bound ,这里需要的是 upper_bound   # 因此将 view_width 和 focus_position 设置成一样，这样 focus_datetime 所对应的 k线刚好位于屏幕外   # 使用两个长度为 8964 的 chart，去缓存/回收下游需要的数据   chart_id_a = _generate_uuid(""PYSDK_backtest"")   chart_id_b = _generate_uuid(""PYSDK_backtest"")   chart_info = {    ""aid"": ""set_chart"",    ""chart_id"": chart_id_a,    ""ins_list"": ins,    ""duration"": dur,    ""view_width"": 8964, # 设为8964原因：可满足用户所有的订阅长度，并在backtest中将所有的 相同合约及周期 的K线用同一个serial存储    ""focus_datetime"": int(self._current_dt),    ""focus_position"": 8964,   }   chart_a = _get_obj(self._data, [""charts"", chart_id_a])   chart_b = _get_obj(self._data, [""charts"", chart_id_b])   symbol_list = ins.split(',')   current_id = None # 当前数据指针   if dur == 0:    serials = [_get_obj(self._data, [""ticks"", symbol_list[0]])]   else:    serials = [_get_obj(self._data, [""klines"", s, str(dur)]) for s in symbol_list]   async with TqChan(self._api, last_only=True) as update_chan:    for serial in serials:     serial[""_listener""].add(update_chan)    chart_a[""_listener""].add(update_chan)    chart_b[""_listener""].add(update_chan)    await self._md_send_chan.send(chart_info.copy())    try:     async for _ in update_chan:      chart = _get_obj(self._data, [""charts"", chart_info[""chart_id""]])      if not (chart_info.items() <= _get_obj(chart, [""state""]).items()):       # 当前请求还没收齐回应, 不应继续处理       continue      left_id = chart.get(""left_id"", -1)      right_id = chart.get(""right_id"", -1)      if (left_id == -1 and right_id == -1) or chart.get(""more_data"", True):       continue # 定位信息还没收到, 数据没有完全收到      last_id = serials[0].get(""last_id"", -1)      if last_id == -1:       continue # 数据序列还没收到      if self._data.get(""mdhis_more_data"", True):       self._data[""_listener""].add(update_chan)       continue      else:       self._data[""_listener""].discard(update_chan)      if current_id is None:       current_id = max(left_id, 0)      # 发送下一段 chart 8964 根 kline      chart_info[""chart_id""] = chart_id_b if chart_info[""chart_id""] == chart_id_a else chart_id_a      chart_info[""left_kline_id""] = right_id      chart_info.pop(""focus_datetime"", None)      chart_info.pop(""focus_position"", None)      await self._md_send_chan.send(chart_info.copy())      while True:       if current_id > last_id:        # 当前 id 已超过 last_id        return       # 将订阅的8964长度的窗口中的数据都遍历完后，退出循环，然后再次进入并处理下一窗口数据       if current_id > right_id:        break       item = {k: v for k, v in serials[0][""data""].get(str(current_id), {}).items()}       if dur == 0:        diff = {         ""ticks"": {          ins: {           ""last_id"": current_id,           ""data"": {            str(current_id): item,            str(current_id - 8964): None,           }          }         }        }        if item[""datetime""] > self._end_dt: # 超过结束时间         return        yield item[""datetime""], diff, self._get_quotes_from_tick(item)       else:        timestamp = item[""datetime""] if dur < 86400000000000 else _get_trading_day_start_time(         item[""datetime""])        if timestamp > self._end_dt: # 超过结束时间         return        binding = serials[0].get(""binding"", {})        diff = {         ""klines"": {          symbol_list[0]: {           str(dur): {            ""last_id"": current_id,            ""data"": {             str(current_id): {              ""datetime"": item[""datetime""],              ""open"": item[""open""],              ""high"": item[""open""],              ""low"": item[""open""],              ""close"": item[""open""],              ""volume"": 0,              ""open_oi"": item[""open_oi""],              ""close_oi"": item[""open_oi""],             }            }           }          }         }        }        for chart_id in self._serials[(ins, dur)][""chart_id_set""]:         diff[""charts""] = {          chart_id: {           ""right_id"": current_id # api 中处理多合约 kline 需要 right_id 信息          }         }        for i, symbol in enumerate(symbol_list):         if i == 0:          diff_binding = diff[""klines""][symbol_list[0]][str(dur)].setdefault(""binding"", {})          continue         other_id = binding.get(symbol, {}).get(str(current_id), -1)         if other_id >= 0:          diff_binding[symbol] = {str(current_id): str(other_id)}          other_item = serials[i][""data""].get(str(other_id), {})          diff[""klines""][symbol] = {           str(dur): {            ""last_id"": other_id,            ""data"": {             str(other_id): {              ""datetime"": other_item[""datetime""],              ""open"": other_item[""open""],              ""high"": other_item[""open""],              ""low"": other_item[""open""],              ""close"": other_item[""open""],              ""volume"": 0,              ""open_oi"": other_item[""open_oi""],              ""close_oi"": other_item[""open_oi""],             }            }           }          }        yield timestamp, diff, self._get_quotes_from_kline_open(         self._data[""quotes""][symbol_list[0]],         timestamp,         item) # K线刚生成时的数据都为开盘价        timestamp = item[""datetime""] + dur - 1000 \         if dur < 86400000000000 else _get_trading_day_start_time(item[""datetime""] + dur) - 1000        if timestamp > self._end_dt: # 超过结束时间         return        diff = {         ""klines"": {          symbol_list[0]: {           str(dur): {            ""data"": {             str(current_id): item,            }           }          }         }        }        for i, symbol in enumerate(symbol_list):         if i == 0:          continue         other_id = binding.get(symbol, {}).get(str(current_id), -1)         if other_id >= 0:          diff[""klines""][symbol] = {           str(dur): {            ""data"": {             str(other_id): {k: v for k, v in                 serials[i][""data""].get(str(other_id), {}).items()}            }           }          }        yield timestamp, diff, self._get_quotes_from_kline(self._data[""quotes""][symbol_list[0]],                    timestamp,                    item) # K线结束时生成quote数据       current_id += 1    finally:     # 释放chart资源     chart_info[""ins_list""] = """"     await self._md_send_chan.send(chart_info.copy())     chart_info[""chart_id""] = chart_id_b if chart_info[""chart_id""] == chart_id_a else chart_id_a     await self._md_send_chan.send(chart_info.copy())  def _gc_data(self):   # api 应该删除的数据 diff   need_rangeset = {}   for ins, dur in self._serials:    if dur == 0: # tick 在发送数据过程中已经回收内存     continue    symbol_list = ins.split(',')    for s in symbol_list:     need_rangeset.setdefault((s, dur), [])    main_serial = _get_obj(self._data, [""klines"", symbol_list[0], str(dur)])    main_serial_rangeset = self._sended_to_api.get((symbol_list[0], dur), []) # 此 request 还没有给 api 发送过任何数据时为 []    if not main_serial_rangeset:     continue    last_id = main_serial_rangeset[-1][-1] - 1    assert last_id > -1    need_rangeset[(symbol_list[0], dur)] = _rangeset_range_union(need_rangeset[(symbol_list[0], dur)],                   (last_id - 8963, last_id + 1))    for symbol in symbol_list[1:]:     symbol_need_rangeset = []     symbol_binding = main_serial.get(""binding"", {}).get(symbol, {})     if symbol_binding:      for i in range(last_id - 8963, last_id + 1):       other_id = symbol_binding.get(str(i))       if other_id:        symbol_need_rangeset = _rangeset_range_union(symbol_need_rangeset, (other_id, other_id + 1))     if symbol_need_rangeset:      need_rangeset[(symbol, dur)] = _rangeset_union(need_rangeset[(symbol, dur)], symbol_need_rangeset)   gc_rangeset = {}   for key, rs in self._sended_to_api.items():    gc_rangeset[key] = _rangeset_difference(rs, need_rangeset.get(key, []))   # 更新 self._sended_to_api   for key, rs in gc_rangeset.items():    self._sended_to_api[key] = _rangeset_difference(self._sended_to_api[key], rs)   gc_klines_diff = {}   for (symbol, dur), rs in gc_rangeset.items():    gc_klines_diff.setdefault(symbol, {})    gc_klines_diff[symbol][str(dur)] = {""data"": {}}    serial = _get_obj(self._data, [""klines"", symbol, str(dur)])    serial_binding = serial.get(""binding"", None)    if serial_binding:     gc_klines_diff[symbol][str(dur)][""binding""] = {s: {} for s in serial_binding.keys()}    for start_id, end_id in rs:     for i in range(start_id, end_id):      gc_klines_diff[symbol][str(dur)][""data""][str(i)] = None      if serial_binding:       for s, s_binding in serial_binding.items():        gc_klines_diff[symbol][str(dur)][""binding""][s][str(i)] = None   return {""klines"": gc_klines_diff}  @staticmethod  def _get_quotes_from_tick(tick):   quote = {k: v for k, v in tick.items()}   quote[""datetime""] = _timestamp_nano_to_str(tick[""datetime""])   return [quote]  @staticmethod  def _get_quotes_from_kline_open(info, timestamp, kline):   return [    { # K线刚生成时的数据都为开盘价     ""datetime"": _timestamp_nano_to_str(timestamp),     ""ask_price1"": kline[""open""] + info[""price_tick""],     ""ask_volume1"": 1,     ""bid_price1"": kline[""open""] - info[""price_tick""],     ""bid_volume1"": 1,     ""last_price"": kline[""open""],     ""highest"": float(""nan""),     ""lowest"": float(""nan""),     ""average"": float(""nan""),     ""volume"": 0,     ""amount"": float(""nan""),     ""open_interest"": kline[""open_oi""],    },   ]  @staticmethod  def _get_quotes_from_kline(info, timestamp, kline):   """"""   分为三个包发给下游：   1. 根据 diff 协议，对于用户收到的最终结果没有影响   2. TqSim 撮合交易会按顺序处理收到的包，分别比较 high、low、close 三个价格对应的买卖价   3. TqSim 撮合交易只用到了买卖价，所以最新价只产生一次 close，而不会发送三次   """"""   return [    {     ""datetime"": _timestamp_nano_to_str(timestamp),     ""ask_price1"": kline[""high""] + info[""price_tick""],     ""ask_volume1"": 1,     ""bid_price1"": kline[""high""] - info[""price_tick""],     ""bid_volume1"": 1,     ""last_price"": kline[""close""],     ""highest"": float(""nan""),     ""lowest"": float(""nan""),     ""average"": float(""nan""),     ""volume"": 0,     ""amount"": float(""nan""),     ""open_interest"": kline[""close_oi""],    },    {     ""ask_price1"": kline[""low""] + info[""price_tick""],     ""bid_price1"": kline[""low""] - info[""price_tick""],    },    {     ""ask_price1"": kline[""close""] + info[""price_tick""],     ""bid_price1"": kline[""close""] - info[""price_tick""],    }   ] "
113,n\tqsdk\backtest\repla,"n\tqsdk\backtest\repla. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' import asyncio import json import time from datetime import date import aiohttp import requests from tqsdk.channel import TqChan class TqReplay(object):  """"""天勤复盘类""""""  def __init__(self, replay_dt: date):   """"""   除了传统的回测模式以外，TqSdk 提供独具特色的复盘模式，它与回测模式有以下区别   1.复盘模式为时间驱动，回测模式为事件驱动   复盘模式下，你可以指定任意一天交易日，后端行情服务器会传输用户订阅合约的当天的所有历史行情数据，重演当天行情，而在回测模式下，我们根据用户订阅的合约周期数据来进行推送   因此在复盘模式下K线更新和实盘一模一样，而回测模式下就算订阅了 Tick 数据，回测中任意周期 K 线最后一根的 close 和其他数据也不会随着 Tick 更新而更新，而是随着K线频率生成和结束时更新一次   2.复盘和回测的行情速度   因为两者的驱动机制不同，回测会更快，但是我们在复盘模式下也提供行情速度调节功能，可以结合web_gui来实现   3.复盘目前只支持单日复盘   因为复盘提供对应合约当日全部历史行情数据，对后端服务器会有较大压力，目前只支持复盘模式下选择单日进行复盘   Args:    replay_dt (date): 指定复盘交易日   """"""   if isinstance(replay_dt, date):    self._replay_dt = replay_dt   else:    raise Exception(""复盘时间(dt)类型 %s 错误, 请检查 dt 数据类型是否填写正确"" % (type(replay_dt)))   if self._replay_dt.weekday() >= 5:    # 0~6, 检查周末[5,6] 提前抛错退出    raise Exception(""无法创建复盘服务器，请检查复盘日期后重试。"")   self._default_speed = 1   self._api = None  def _create_server(self, api):   self._api = api   self._logger = api._logger.getChild(""TqReplay"") # 调试信息输出   self._logger.debug('replay prepare', replay_dt=self._replay_dt)   session = self._prepare_session()   self._session_url = ""http://%s:%d/t/rmd/replay/session/%s"" % (    session[""ip""], session[""session_port""], session[""session""])   self._ins_url = ""http://%s:%d/t/rmd/replay/session/%s/symbol"" % (    session[""ip""], session[""session_port""], session[""session""])   self._md_url = ""ws://%s:%d/t/rmd/front/mobile"" % (session[""ip""], session[""gateway_web_port""])   self._server_status = None   self._server_status = self._wait_server_status(""running"", 60)   if self._server_status == ""running"":    self._logger.debug('replay start successed', replay_dt=self._replay_dt)    return self._ins_url, self._md_url   else:    self._logger.debug('replay start failed', replay_dt=self._replay_dt)    raise Exception(""无法创建复盘服务器，请检查复盘日期后重试。"")  async def _run(self):   try:    self._send_chan = TqChan(self._api)    self._send_chan.send_nowait({""aid"": ""ratio"", ""speed"": self._default_speed})    _senddata_task = self._api.create_task(self._senddata_handler())    while True:     await self._send_chan.send({""aid"": ""heartbeat""})     await asyncio.sleep(30)   finally:    await self._send_chan.close()    _senddata_task.cancel()    await asyncio.gather(_senddata_task, return_exceptions=True)  def _prepare_session(self):   create_session_url = ""http://replay.api.shinnytech.com/t/rmd/replay/create_session""   response = requests.post(create_session_url,         headers=self._api._base_headers,         data=json.dumps({'dt': self._replay_dt.strftime(""%Y%m%d"")}),         timeout=5)   if response.status_code == 200:    return json.loads(response.content)   else:    raise Exception(""创建复盘服务器失败，请检查复盘日期后重试。"")  def _wait_server_status(self, target_status, timeout):   """"""等服务器状态为 target_status，超时时间 timeout 秒""""""   deadline = time.time() + timeout   server_status = self._get_server_status()   while deadline > time.time():    if target_status == server_status:     break    else:     time.sleep(1)     server_status = self._get_server_status()   return server_status  def _get_server_status(self):   try:    response = requests.get(self._session_url,          headers=self._api._base_headers,          timeout=5)    if response.status_code == 200:     return json.loads(response.content)[""status""]    else:     raise Exception(""无法创建复盘服务器，请检查复盘日期后重试。"")   except requests.exceptions.ConnectionError as e:    # 刚开始 _session_url 还不能访问的时候～    return None  async def _senddata_handler(self):   try:    session = aiohttp.ClientSession(headers=self._api._base_headers)    async for data in self._send_chan:     await session.post(self._session_url, data=json.dumps(data))   finally:    await session.post(self._session_url, data=json.dumps({""aid"": ""terminate""}))    await session.close()  def set_replay_speed(self, speed: float = 10.0) -> None:   """"""   调整复盘服务器行情推进速度   Args:    speed (float): 复盘服务器行情推进速度, 默认为 10.0   Example::    from datetime import date    from tqsdk import TqApi, TqAuth, TqReplay    replay = TqReplay(date(2020, 9, 10))    api = TqApi(backtest=replay, auth=(""信易账户,账户密码""))    replay.set_replay_speed(3.0)    quote = api.get_quote(""SHFE.cu2012"")    while True:     api.wait_update()     if api.is_changing(quote):      print(""最新价"", quote.datetime, quote.last_price)   """"""   if self._api:    self._send_chan.send_nowait({""aid"": ""ratio"", ""speed"": speed})   else:    # _api 未初始化，只记录用户设定的速度，在复盘服务器启动完成后，发动请求    self._default_speed = speed "
114,n\tqsdk\backtest\util,"n\tqsdk\backtest\util. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' from datetime import datetime import requests from tqsdk.calendar import TqContCalendar class TqBacktestContinuous(object):  def __init__(self, start_dt: int, end_dt: int, headers=None) -> None:   """"""   为回测时提供某个交易日的主连表   start_dt 开始的交易日   end_dt 结束的交易日   """"""   self._cont_calendar = TqContCalendar(start_dt=datetime.fromtimestamp(start_dt / 1e9),            end_dt=datetime.fromtimestamp(end_dt / 1e9),            headers=headers)  def _get_history_cont_quotes(self, trading_day):   df = self._cont_calendar._get_cont_underlying_on_date(dt=datetime.fromtimestamp(trading_day / 1e9))   quotes = {k: {""underlying_symbol"": df.iloc[0][k]} for k in df.columns if k.startswith(""KQ.m"")}   return quotes class TqBacktestDividend(object):  def __init__(self, start_dt: int, end_dt: int, headers=None) -> None:   """"""   为回测时提供分红送股信息   start_dt 开始的交易日   end_dt 结束的交易日   """"""   self._headers = headers   self._start_dt = start_dt   self._end_dt = end_dt   self._start_date = datetime.fromtimestamp(self._start_dt / 1000000000).strftime('%Y%m%d')   self._end_date = datetime.fromtimestamp(self._end_dt / 1000000000).strftime('%Y%m%d')   self._stocks = {} # 记录全部股票合约及从 stock-dividend 服务获取的原始数据  def _get_dividend(self, quotes, trading_day):   dt = datetime.fromtimestamp(trading_day / 1000000000).strftime('%Y%m%d')   self._request_stock_dividend(quotes)   rsp_quotes = {}   # self._stocks 中应该已经记录了 quotes 中全部股票合约   for symbol, stock in self._stocks.items():    if stock['request_successed'] is True: # 从 stock-dividend 服务获取的原始数据     rsp_quotes[symbol] = {      'cash_dividend_ratio': [f""{item['drdate']},{item['cash']}"" for item in stock['dividend_list']            if item['recorddate'] <= dt and item['cash'] > 0], # 除权除息日,每股分红（税后）      'stock_dividend_ratio': [f""{item['drdate']},{item['share']}"" for item in stock['dividend_list']            if item['recorddate'] <= dt and item['share'] > 0] # 除权除息日,每股送转股数量     }    else:     # todo: stock['request_successed'] == False 表示请求不成功, 退回到原始合约服务中的分红送股数据, 用户会收到未来数据,     # 但是 tqsim 能保证取到结算时下一个交易日的分红信息     # 此时，quotes 为 tqbacktest._data['quotes'] 应该保存了全部的合约信息     rsp_quotes[symbol] = {      'cash_dividend_ratio': quotes[symbol].get('cash_dividend_ratio', []),      'stock_dividend_ratio': quotes[symbol].get('stock_dividend_ratio', [])     }   return rsp_quotes  def _request_stock_dividend(self, quotes):   # 对于股票合约，从 stock-dividend 服务请求回测时间段的分红方案   stock_list = [s for s in quotes if quotes[s]['ins_class'] == 'STOCK' and s not in self._stocks]   if len(stock_list) == 0:    return   # 每个合约只会请求一次，请求失败就退回到原始合约服务中的分红送股数据   for s in stock_list:    self._stocks[s] = {     'request_successed': False,     'dividend_list': []    }   # https://github.com/shinnytech/stock-dividend   rsp = requests.get(url=""https://stock-dividend.shinnytech.com/query"",       headers=self._headers, timeout=30,       params={        ""stock_list"": ','.join(stock_list),        ""start_date"": self._start_date,        ""end_date"": self._end_date       })   if rsp.status_code != 200:    return   result = rsp.json().get('result')   for s in stock_list:    self._stocks[s]['request_successed'] = True   for item in result:    """"""    stockcode: 证券代码    marketcode: 市场代码    share: 每股送转股数量    cash: 每股分红（税后）    recorddate: 股权登记日    drdate: 除权除息日    """"""    self._stocks[f""{item['marketcode']}.{item['stockcode']}""][""dividend_list""].append(item) "
115,n\tqsdk\backtest\  init ,n\tqsdk\backtest\  init . #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' from tqsdk.backtest.backtest import TqBacktest from tqsdk.backtest.replay import TqReplay
116,n\tqsdk\demo\download order,"n\tqsdk\demo\download order. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'yanqiong' import csv import os from datetime import datetime from tqsdk import TqApi, TqAuth, TqKq """""" 本示例用于下载账户当前交易日到目前位置的全部委托单、成交记录分别到 orders.csv、trades.csv 文件。 如果文件已经存在，会将记录追加到文件末尾。 用户可以在交易日结束之后，运行本示例，可以将当日的委托单、成交记录保存到本地。 """""" order_cols = [""order_id"", ""exchange_order_id"", ""exchange_id"", ""instrument_id"", ""direction"", ""offset"", ""status"", ""volume_orign"", ""volume_left"", ""limit_price"", ""price_type"", ""volume_condition"", ""time_condition"", ""insert_date_time"", ""last_msg""] trade_cols = [""trade_id"", ""order_id"", ""exchange_trade_id"", ""exchange_id"", ""instrument_id"", ""direction"", ""offset"", ""price"", ""volume"", ""trade_date_time""] def write_csv(file_name, cols, datas):  file_exists = os.path.exists(file_name) and os.path.getsize(file_name) > 0  with open(file_name, 'a', newline='') as csvfile:   csv_writer = csv.writer(csvfile, dialect='excel')   if not file_exists:    csv_writer.writerow(['datetime'] + cols)   for item in datas.values():    if 'insert_date_time' in cols:     dt = datetime.fromtimestamp(item['insert_date_time'] / 1e9).strftime('%Y-%m-%d %H:%M:%S.%f')    elif 'trade_date_time' in cols:     dt = datetime.fromtimestamp(item['trade_date_time'] / 1e9).strftime('%Y-%m-%d %H:%M:%S.%f')    else:     dt = None    row = [dt] + [item[k] for k in cols]    csv_writer.writerow(row) with TqApi(TqKq(), auth=TqAuth(""信易账户"", ""账户密码"")) as api:  # 将当前账户下全部委托单、成交信息写入 csv 文件中  write_csv(""orders.csv"", order_cols, api.get_order())  write_csv(""trades.csv"", trade_cols, api.get_trade()) "
117,n\tqsdk\demo\multiaccoun,"n\tqsdk\demo\multiaccoun. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'hongyan' from tqsdk import TqApi, TqAuth, TqAccount, TqKq, TqSim, TqMultiAccount # 多账户模式下, 同时操作实盘、模拟交易和快期模拟账户交易 tqact = TqAccount(""H海通期货"", ""123456"", ""123456"") sim = TqSim() kq = TqKq() with TqApi(TqMultiAccount([tqact, sim, kq]), auth=TqAuth(""信易账户"", ""账户密码"")) as api:  order1 = api.insert_order(symbol=""DCE.m2101"", direction=""BUY"", offset=""OPEN"", volume=5, account=tqact)  order2 = api.insert_order(symbol=""SHFE.au2012C308"", direction=""BUY"", offset=""OPEN"", volume=5, limit_price=78.1, account=sim)  order3 = api.insert_order(symbol=""SHFE.cu2101"", direction=""Sell"", offset=""OPEN"", volume=10, limit_price=51610, account=kq)  api.cancel_order(order3, kq)  while order1.status != ""FINISHED"" or order2.status != ""FINISHED"":   api.wait_update()  # 分别获取账户资金信息  account_info1 = tqact.get_account()  account_info2 = sim.get_account()  account_info3 = kq.get_account()  # 分别获取账户持仓信息  position1 = tqact.get_position(""DCE.m2101"", )  position2 = sim.get_position()  position3 = kq.get_position()  # 分别获取账户委托数据  orders1 = tqact.get_order(order_id=order1.order_id, )  orders2 = sim.get_position()  orders3 = kq.get_position()  # 分别获取账户成交数据  trades1 = tqact.get_trade()  trades2 = sim.get_trade()  trades3 = kq.get_trade()"
118,n\tqsdk\demo\t,"n\tqsdk\demo\t. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' import datetime from tqsdk import TqApi, TqAuth from tqsdk.ta import * api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 获得 cu1909 10秒K线的引用 klines = api.get_kline_serial(""SHFE.cu1910"", 10, data_length=3000) print(""K线时间"", datetime.datetime.fromtimestamp(klines.iloc[-1][""datetime""] / 1e9)) print(klines) print(""ATR"", ATR(klines, 26)) print(""BIAS"", BIAS(klines, 6)) print(""BOLL"", BOLL(klines, 3, 5)) print(""DMI"", DMI(klines, 14, 6)) print(""KDJ"", KDJ(klines, 9, 3, 3)) print(""MA"", MA(klines, 3)) print(""MACD"", MACD(klines, 20, 35, 10)) print(""SAR"", SAR(klines, 4, 0.02, 0.2)) api.close() "
119,n\tqsdk\demo\ta optio,"n\tqsdk\demo\ta optio. #!usr/bin/env python3 #-*- coding:utf-8 -*- from tqsdk import TqApi, TqAuth, tafunc from tqsdk.ta import * api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) underlying_quote = api.get_quote(""SHFE.cu2009"") klines = api.get_kline_serial('SHFE.cu2009', 24 * 60 * 60, 20) v = tafunc.get_his_volatility(klines, underlying_quote) print(""历史波动率:"", v) quote = api.get_quote(""SHFE.cu2009C44000"") bs_serise = BS_VALUE(klines, quote, 0.025) print(""理论价:"", list(round(bs_serise['bs_price'], 2))) klines2 = api.get_kline_serial([""SHFE.cu2009C44000"", ""SHFE.cu2009""], 24 * 60 * 60, 20) values = OPTION_VALUE(klines2, quote) print(""内在价值:"", list(values[""intrins""])) print(""时间价值:"", list(values[""time""])) impv = OPTION_IMPV(klines2, quote, 0.025) print(""隐含波动率:"", list(round(impv['impv'] * 100, 2))) greeks = OPTION_GREEKS(klines2, quote, 0.025, impv['impv']) print(""delta:"", list(greeks[""delta""])) print(""theta:"", list(greeks[""theta""])) print(""gamma:"", list(greeks[""gamma""])) print(""vega:"", list(greeks[""vega""])) print(""rho:"", list(greeks[""rho""])) api.close() "
120,n\tqsdk\demo\  init ,n\tqsdk\demo\  init . 
121,n\tqsdk\demo\example\aberratio,"n\tqsdk\demo\example\aberratio. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = ""Ringo"" ''' Aberration策略 (难度：初级) 参考: https://www.shinnytech.com/blog/aberration/ 注: 该示例策略仅用于功能示范, 实盘时请根据自己的策略/经验进行修改 ''' from tqsdk import TqApi, TqAuth, TargetPosTask from tqsdk.ta import BOLL # 设置合约代码 SYMBOL = ""DCE.m2105"" api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) quote = api.get_quote(SYMBOL) klines = api.get_kline_serial(SYMBOL, 60 * 60 * 24) position = api.get_position(SYMBOL) target_pos = TargetPosTask(api, SYMBOL) # 使用BOLL指标计算中轨、上轨和下轨，其中26为周期N ，2为参数p def boll_line(klines):  boll = BOLL(klines, 26, 2)  midline = boll[""mid""].iloc[-1]  topline = boll[""top""].iloc[-1]  bottomline = boll[""bottom""].iloc[-1]  print(""策略运行，中轨：%.2f，上轨为:%.2f，下轨为:%.2f"" % (midline, topline, bottomline))  return midline, topline, bottomline midline, topline, bottomline = boll_line(klines) while True:  api.wait_update()  # 每次生成新的K线时重新计算BOLL指标  if api.is_changing(klines.iloc[-1], ""datetime""):   midline, topline, bottomline = boll_line(klines)  # 每次最新价发生变化时进行判断  if api.is_changing(quote, ""last_price""):   # 判断开仓条件   if position.pos_long == 0 and position.pos_short == 0:    # 如果最新价大于上轨，K线上穿上轨，开多仓    if quote.last_price > topline:     print(""K线上穿上轨，开多仓"")     target_pos.set_target_volume(20)    # 如果最新价小于轨，K线下穿下轨，开空仓    elif quote.last_price < bottomline:     print(""K线下穿下轨，开空仓"")     target_pos.set_target_volume(-20)    else:     print(""当前最新价%.2f,未穿上轨或下轨，不开仓"" % quote.last_price)   # 在多头情况下，空仓条件   elif position.pos_long > 0:    # 如果最新价低于中线，多头清仓离场    if quote.last_price < midline:     print(""最新价低于中线，多头清仓离场"")     target_pos.set_target_volume(0)    else:     print(""当前多仓，未穿越中线，仓位无变化"")   # 在空头情况下，空仓条件   elif position.pos_short > 0:    # 如果最新价高于中线，空头清仓离场    if quote.last_price > midline:     print(""最新价高于中线，空头清仓离场"")     target_pos.set_target_volume(0)    else:     print(""当前空仓，未穿越中线，仓位无变化"") "
122,n\tqsdk\demo\example\doublem,"n\tqsdk\demo\example\doublem. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' ''' 双均线策略 注: 该示例策略仅用于功能示范, 实盘时请根据自己的策略/经验进行修改 ''' from tqsdk import TqApi, TqAuth, TargetPosTask from tqsdk.tafunc import ma SHORT = 30 # 短周期 LONG = 60 # 长周期 SYMBOL = ""SHFE.bu2012"" # 合约代码 api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) print(""策略开始运行"") data_length = LONG + 2 # k线数据长度 # ""duration_seconds=60""为一分钟线, 日线的duration_seconds参数为: 24*60*60 klines = api.get_kline_serial(SYMBOL, duration_seconds=60, data_length=data_length) target_pos = TargetPosTask(api, SYMBOL) while True:  api.wait_update()  if api.is_changing(klines.iloc[-1], ""datetime""): # 产生新k线:重新计算SMA   short_avg = ma(klines[""close""], SHORT) # 短周期   long_avg = ma(klines[""close""], LONG) # 长周期   # 均线下穿，做空   if long_avg.iloc[-2] < short_avg.iloc[-2] and long_avg.iloc[-1] > short_avg.iloc[-1]:    target_pos.set_target_volume(-3)    print(""均线下穿，做空"")   # 均线上穿，做多   if short_avg.iloc[-2] < long_avg.iloc[-2] and short_avg.iloc[-1] > long_avg.iloc[-1]:    target_pos.set_target_volume(3)    print(""均线上穿，做多"") "
123,n\tqsdk\demo\example\dualthrus,"n\tqsdk\demo\example\dualthrus. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' ''' Dual Thrust策略 (难度：中级) 参考: https://www.shinnytech.com/blog/dual-thrust 注: 该示例策略仅用于功能示范, 实盘时请根据自己的策略/经验进行修改 ''' from tqsdk import TqApi, TqAuth, TargetPosTask SYMBOL = ""DCE.jd2011"" # 合约代码 NDAY = 5 # 天数 K1 = 0.2 # 上轨K值 K2 = 0.2 # 下轨K值 api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) print(""策略开始运行"") quote = api.get_quote(SYMBOL) klines = api.get_kline_serial(SYMBOL, 24 * 60 * 60) # 86400使用日线 target_pos = TargetPosTask(api, SYMBOL) def dual_thrust(quote, klines):  current_open = klines.iloc[-1][""open""]  HH = max(klines.high.iloc[-NDAY - 1:-1]) # N日最高价的最高价  HC = max(klines.close.iloc[-NDAY - 1:-1]) # N日收盘价的最高价  LC = min(klines.close.iloc[-NDAY - 1:-1]) # N日收盘价的最低价  LL = min(klines.low.iloc[-NDAY - 1:-1]) # N日最低价的最低价  range = max(HH - LC, HC - LL)  buy_line = current_open + range * K1 # 上轨  sell_line = current_open - range * K2 # 下轨  print(""当前开盘价: %f, 上轨: %f, 下轨: %f"" % (current_open, buy_line, sell_line))  return buy_line, sell_line buy_line, sell_line = dual_thrust(quote, klines) # 获取上下轨 while True:  api.wait_update()  if api.is_changing(klines.iloc[-1], [""datetime"", ""open""]): # 新产生一根日线或开盘价发生变化: 重新计算上下轨   buy_line, sell_line = dual_thrust(quote, klines)  if api.is_changing(quote, ""last_price""):   if quote.last_price > buy_line: # 高于上轨    print(""高于上轨,目标持仓 多头3手"")    target_pos.set_target_volume(3) # 交易   elif quote.last_price < sell_line: # 低于下轨    print(""低于下轨,目标持仓 空头3手"")    target_pos.set_target_volume(-3) # 交易   else:    print('未穿越上下轨,不调整持仓') "
124,n\tqsdk\demo\example\escalato,"n\tqsdk\demo\example\escalato. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = ""Ringo"" ''' 自动扶梯 策略 (难度：初级) 参考: https://www.shinnytech.com/blog/escalator/ 注: 该示例策略仅用于功能示范, 实盘时请根据自己的策略/经验进行修改 ''' from tqsdk import TqApi, TqAuth, TargetPosTask from tqsdk.ta import MA # 设置合约 SYMBOL = ""SHFE.rb2012"" # 设置均线长短周期 MA_SLOW, MA_FAST = 8, 40 api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) klines = api.get_kline_serial(SYMBOL, 60 * 60 * 24) quote = api.get_quote(SYMBOL) position = api.get_position(SYMBOL) target_pos = TargetPosTask(api, SYMBOL) # K线收盘价在这根K线波动范围函数 def kline_range(num):  kl_range = (klines.iloc[num].close - klines.iloc[num].low) / \    (klines.iloc[num].high - klines.iloc[num].low)  return kl_range # 获取长短均线值 def ma_caculate(klines):  ma_slow = MA(klines, MA_SLOW).iloc[-1].ma  ma_fast = MA(klines, MA_FAST).iloc[-1].ma  return ma_slow, ma_fast ma_slow, ma_fast = ma_caculate(klines) print(""慢速均线为%.2f,快速均线为%.2f"" % (ma_slow, ma_fast)) while True:  api.wait_update()  # 每次k线更新，重新计算快慢均线  if api.is_changing(klines.iloc[-1], ""datetime""):   ma_slow, ma_fast = ma_caculate(klines)   print(""慢速均线为%.2f,快速均线为%.2f"" % (ma_slow, ma_fast))  if api.is_changing(quote, ""last_price""):   # 开仓判断   if position.pos_long == 0 and position.pos_short == 0:    # 计算前后两根K线在当时K线范围波幅    kl_range_cur = kline_range(-2)    kl_range_pre = kline_range(-3)    # 开多头判断，最近一根K线收盘价在短期均线和长期均线之上，前一根K线收盘价位于K线波动范围底部25%，最近这根K线收盘价位于K线波动范围顶部25%    if klines.iloc[-2].close > max(ma_slow, ma_fast) and kl_range_pre <= 0.25 and kl_range_cur >= 0.75:     print(""最新价为:%.2f 开多头"" % quote.last_price)     target_pos.set_target_volume(100)    # 开空头判断，最近一根K线收盘价在短期均线和长期均线之下，前一根K线收盘价位于K线波动范围顶部25%，最近这根K线收盘价位于K线波动范围底部25%    elif klines.iloc[-2].close < min(ma_slow, ma_fast) and kl_range_pre >= 0.75 and kl_range_cur <= 0.25:     print(""最新价为:%.2f 开空头"" % quote.last_price)     target_pos.set_target_volume(-100)    else:     print(""最新价位:%.2f ，未满足开仓条件"" % quote.last_price)   # 多头持仓止损策略   elif position.pos_long > 0:    # 在两根K线较低点减一跳，进行多头止损    kline_low = min(klines.iloc[-2].low, klines.iloc[-3].low)    if klines.iloc[-1].close <= kline_low - quote.price_tick:     print(""最新价为:%.2f,进行多头止损"" % (quote.last_price))     target_pos.set_target_volume(0)    else:     print(""多头持仓，当前价格 %.2f,多头离场价格%.2f"" %      (quote.last_price, kline_low - quote.price_tick))   # 空头持仓止损策略   elif position.pos_short > 0:    # 在两根K线较高点加一跳，进行空头止损    kline_high = max(klines.iloc[-2].high, klines.iloc[-3].high)    if klines.iloc[-1].close >= kline_high + quote.price_tick:     print(""最新价为:%.2f 进行空头止损"" % quote.last_price)     target_pos.set_target_volume(0)    else:     print(""空头持仓，当前价格 %.2f,空头离场价格%.2f"" %      (quote.last_price, kline_high + quote.price_tick)) "
125,n\tqsdk\demo\example\fairy four pric,"n\tqsdk\demo\example\fairy four pric. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' ''' 菲阿里四价 策略(日内突破策略, 在每日收盘前对所持合约进行平仓) 参考: https://www.shinnytech.com/blog/fairy-four-price/ 注: 该示例策略仅用于功能示范, 实盘时请根据自己的策略/经验进行修改 ''' from tqsdk import TqApi, TqAuth, TargetPosTask from datetime import datetime import time symbol = ""SHFE.ni2012"" # 合约代码 close_hour, close_minute = 14, 50 # 平仓时间 api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 使用模拟帐号直连行情和交易服务器 quote = api.get_quote(symbol) # 获取指定合约的盘口行情 klines = api.get_kline_serial(symbol, 24 * 60 * 60) # 获取日线 position = api.get_position(symbol) # 持仓信息 target_pos = TargetPosTask(api, symbol) # 目标持仓 top_rail = klines.high.iloc[-2] # 上轨: 昨日高点 bottom_rail = klines.low.iloc[-2] # 下轨: 昨日低点 print(""上轨:"", top_rail, "",下轨:"", bottom_rail, "",昨日收盘价:"", klines.close.iloc[-2], "",今日开盘价:"", klines.open.iloc[-1]) while True:  api.wait_update()  if api.is_changing(klines.iloc[-1], ""datetime""): # 如果产生一根新日线 (即到达下一个交易日): 重新获取上下轨   top_rail = klines.high.iloc[-2]   bottom_rail = klines.low.iloc[-2]   print(""上轨:"", top_rail, "",下轨:"", bottom_rail, "",昨日收盘价:"", klines.close.iloc[-2], "",今日开盘价:"", klines.open.iloc[-1])  if api.is_changing(quote, ""last_price""): # 如果行情最新价发生变化   print(""当前最新价"", quote.last_price)   # 开仓突破   if quote.last_price > top_rail and position.pos_long == 0: # 如果价格突破上轨: 买入开仓    print(""最新价:"", quote.last_price, "", 价格突破上轨,买入开仓"")    target_pos.set_target_volume(3) # 设置目标持仓手数，将指定合约调整到目标头寸   elif quote.last_price < bottom_rail and position.pos_short == 0: # 如果价格跌破下轨: 卖出开仓    print(""最新价:"", quote.last_price, "", 价格跌破下轨, 卖出开仓"")    target_pos.set_target_volume(-3)   # 平仓止损: 当价格 向上突破上轨 或 向下突破下轨 后, 再次回破当日开盘价   if (quote.highest > top_rail and quote.last_price <= quote.open) or (     quote.lowest < bottom_rail and quote.last_price >= quote.open):    print(""平仓止损"")    target_pos.set_target_volume(0)  if api.is_changing(quote, ""datetime""):   now_time = datetime.strptime(quote.datetime, ""%Y-%m-%d %H:%M:%S.%f"") # 获取当前的行情时间   if now_time.hour == close_hour and now_time.minute >= close_minute: # 到达平仓时间: 平仓    print(""临近本交易日收盘: 平仓"")    target_pos.set_target_volume(0)    deadline = time.time() + 60 # 设置截止时间为当前时间的60秒以后    while api.wait_update(deadline=deadline): # 等待60秒     pass    api.close() # 关闭api    break # 退出while循环 "
126,n\tqsdk\demo\example\gridtradin,"n\tqsdk\demo\example\gridtradin. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' """""" 网格交易策略 (难度：中级) 参考: https://www.shinnytech.com/blog/grid-trading/ 注: 该示例策略仅用于功能示范, 实盘时请根据自己的策略/经验进行修改 """""" from functools import reduce from tqsdk import TqApi, TqAuth, TargetPosTask SYMBOL = ""DCE.jd2011"" # 合约代码 START_PRICE = 4247 # 起始价位 GRID_AMOUNT = 10 # 网格在多头、空头方向的格子(档位)数量 api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) grid_region_long = [0.005] * GRID_AMOUNT # 多头每格价格跌幅(网格密度) grid_region_short = [0.005] * GRID_AMOUNT # 空头每格价格涨幅(网格密度) grid_volume_long = [i for i in range(GRID_AMOUNT + 1)] # 多头每格持仓手数 grid_volume_short = [i for i in range(GRID_AMOUNT + 1)] # 空头每格持仓手数 grid_prices_long = [reduce(lambda p, r: p * (1 - r), grid_region_long[:i], START_PRICE) for i in      range(GRID_AMOUNT + 1)] # 多头每格的触发价位列表 grid_prices_short = [reduce(lambda p, r: p * (1 + r), grid_region_short[:i], START_PRICE) for i in      range(GRID_AMOUNT + 1)] # 空头每格的触发价位列表 print(""策略开始运行, 起始价位: %f, 多头每格持仓手数:%s, 多头每格的价位:%s, 空头每格的价位:%s"" % ( START_PRICE, grid_volume_long, grid_prices_long, grid_prices_short)) quote = api.get_quote(SYMBOL) # 行情数据 target_pos = TargetPosTask(api, SYMBOL) position = api.get_position(SYMBOL) # 持仓信息 def wait_price(layer):  """"""等待行情最新价变动到其他档位,则进入下一档位或回退到上一档位; 如果从下一档位回退到当前档位,则设置为当前对应的持仓手数;   layer : 当前所在第几个档位层次; layer>0 表示多头方向, layer<0 表示空头方向  """"""  if layer > 0 or quote.last_price <= grid_prices_long[1]: # 是多头方向   while True:    api.wait_update()    # 如果当前档位小于最大档位,并且最新价小于等于下一个档位的价格: 则设置为下一档位对应的手数后进入下一档位层次    if layer < GRID_AMOUNT and quote.last_price <= grid_prices_long[layer + 1]:     target_pos.set_target_volume(grid_volume_long[layer + 1])     print(""最新价: %f, 进入: 多头第 %d 档"" % (quote.last_price, layer + 1))     wait_price(layer + 1)     # 从下一档位回退到当前档位后, 设置回当前对应的持仓手数     target_pos.set_target_volume(grid_volume_long[layer + 1])    # 如果最新价大于当前档位的价格: 则回退到上一档位    if quote.last_price > grid_prices_long[layer]:     print(""最新价: %f, 回退到: 多头第 %d 档"" % (quote.last_price, layer))     return  elif layer < 0 or quote.last_price >= grid_prices_short[1]: # 是空头方向   layer = -layer # 转为正数便于计算   while True:    api.wait_update()    # 如果当前档位小于最大档位层次,并且最新价大于等于下一个档位的价格: 则设置为下一档位对应的持仓手数后进入下一档位层次    if layer < GRID_AMOUNT and quote.last_price >= grid_prices_short[layer + 1]:     target_pos.set_target_volume(-grid_volume_short[layer + 1])     print(""最新价: %f, 进入: 空头第 %d 档"" % (quote.last_price, layer + 1))     wait_price(-(layer + 1))     # 从下一档位回退到当前档位后, 设置回当前对应的持仓手数     target_pos.set_target_volume(-grid_volume_short[layer + 1])    # 如果最新价小于当前档位的价格: 则回退到上一档位    if quote.last_price < grid_prices_short[layer]:     print(""最新价: %f, 回退到: 空头第 %d 档"" % (quote.last_price, layer))     return while True:  api.wait_update()  wait_price(0) # 从第0层开始进入网格  target_pos.set_target_volume(0) "
127,n\tqsdk\demo\example\gridtrading asyn,"n\tqsdk\demo\example\gridtrading asyn. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' """""" 网格交易策略 参考: https://www.shinnytech.com/blog/grid-trading/ 注: 该示例策略仅用于功能示范, 实盘时请根据自己的策略/经验进行修改 """""" from functools import reduce from contextlib import closing from tqsdk import TqApi, TqAuth, TargetPosTask # 网格计划参数: symbol = ""DCE.jd2011"" # 合约代码 start_price = 4247 # 起始价位 grid_amount = 10 # 网格在多头、空头方向的格子(档位)数量 grid_region_long = [0.005] * grid_amount # 多头每格价格跌幅(网格密度) grid_region_short = [0.005] * grid_amount # 空头每格价格涨幅(网格密度) grid_volume_long = [1] * grid_amount # 多头每格交易手数 grid_volume_short = [-1] * grid_amount # 空头每格交易手数 grid_prices_long = [reduce(lambda p, r: p*(1-r), grid_region_long[:i], start_price) for i in range(grid_amount + 1)] # 多头每格的触发价位列表, 第一个元素为起始价位 grid_prices_short = [reduce(lambda p, r: p*(1+r), grid_region_short[:i], start_price) for i in range(grid_amount + 1)] # 空头每格的触发价位列表, 第一个元素为起始价位 print(""起始价位:"", start_price) print(""多头每格交易量:"", grid_volume_long) print(""多头每格的价位:"", grid_prices_long) print(""空头每格的价位:"", grid_prices_short) api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) quote = api.get_quote(symbol) # 行情数据 target_pos = TargetPosTask(api, symbol) target_volume = 0 # 目标持仓手数 async def price_watcher(open_price, close_price, volume):  """"""该task在价格触发开仓价时开仓，触发平仓价时平仓""""""  global target_volume  async with api.register_update_notify(quote) as update_chan: # 当 quote 有更新时会发送通知到 update_chan 上   while True:    async for _ in update_chan: # 当从 update_chan 上收到行情更新通知时判断是否触发开仓条件     if (volume > 0 and quote.last_price <= open_price) or (volume < 0 and quote.last_price >= open_price):      break    target_volume += volume    target_pos.set_target_volume(target_volume)    print(""时间:"", quote.datetime, ""最新价:"", quote.last_price, ""开仓"", volume, ""手"", ""总仓位:"", target_volume, ""手"")    async for _ in update_chan: # 当从 update_chan 上收到行情更新通知时判断是否触发平仓条件     if (volume > 0 and quote.last_price > close_price) or (volume < 0 and quote.last_price < close_price):      break    target_volume -= volume    target_pos.set_target_volume(target_volume)    print(""时间:"", quote.datetime, ""最新价:"", quote.last_price, ""平仓"", volume, ""手"", ""总仓位:"", target_volume, ""手"") for i in range(grid_amount):  api.create_task(price_watcher(grid_prices_long[i+1], grid_prices_long[i], grid_volume_long[i]))  api.create_task(price_watcher(grid_prices_short[i+1], grid_prices_short[i], grid_volume_short[i])) with closing(api):  while True:   api.wait_update() "
128,n\tqsdk\demo\example\momentu,"n\tqsdk\demo\example\momentu. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = ""Ringo"" ''' 价格动量 策略 (难度：初级) 参考: https://www.shinnytech.com/blog/momentum-strategy/ 注: 该示例策略仅用于功能示范, 实盘时请根据自己的策略/经验进行修改 ''' from tqsdk import TqApi, TqAuth, TargetPosTask # 设置指定合约,获取N条K线计算价格动量 SYMBOL = ""SHFE.au2012"" N = 15 api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) klines = api.get_kline_serial(SYMBOL, 60 * 60 * 24, N) quote = api.get_quote(SYMBOL) target_pos = TargetPosTask(api, SYMBOL) position = api.get_position(SYMBOL) def AR(kline1):  """"""价格动量函数AR，以前N-1日K线计算价格动量ar""""""  spread_ho = sum(kline1.high[:-1] - kline1.open[:-1])  spread_oc = sum(kline1.open[:-1] - kline1.low[:-1])  # spread_oc 为0时，设置为最小价格跳动值  if spread_oc == 0:   spread_oc = quote.price_tick  ar = (spread_ho / spread_oc) * 100  return ar ar = AR(klines) print(""策略开始启动"") while True:  api.wait_update()  # 生成新K线时，重新计算价格动量值ar  if api.is_changing(klines.iloc[-1], ""datetime""):   ar = AR(klines)   print(""价格动量是："", ar)  # 每次最新价发生变动时，重新进行判断  if api.is_changing(quote, ""last_price""):   # 开仓策略   if position.pos_long == 0 and position.pos_short == 0:    # 如果ar大于110并且小于150，开多仓    if 110 < ar < 150:     print(""价值动量超过110，小于150，做多"")     target_pos.set_target_volume(100)    # 如果ar大于50，小于90，开空仓    elif 50 < ar < 90:     print(""价值动量大于50，小于90，做空"")     target_pos.set_target_volume(-100)   # 止损策略，多头下当前ar值小于90则平仓止损，空头下当前ar值大于110则平仓止损   elif (position.pos_long > 0 and ar < 90) or (position.pos_short > 0 and ar > 110):    print(""止损平仓"")    target_pos.set_target_volume(0) "
129,n\tqsdk\demo\example\random fores,"n\tqsdk\demo\example\random fores. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' import pandas as pd import datetime from contextlib import closing from tqsdk import TqApi, TqAuth, TqBacktest, BacktestFinished, TargetPosTask from tqsdk.tafunc import sma, ema2, trma from sklearn.ensemble import RandomForestClassifier pd.set_option('display.max_rows', None) # 设置Pandas显示的行数 pd.set_option('display.width', None) # 设置Pandas显示的宽度 ''' 应用随机森林对某交易日涨跌情况的预测(使用sklearn包) 参考:https://www.joinquant.com/post/1571 注: 该示例策略仅用于功能示范, 实盘时请根据自己的策略/经验进行修改 ''' symbol = ""SHFE.ru1811"" # 交易合约代码 close_hour, close_minute = 14, 50 # 预定收盘时间(因为真实收盘后无法进行交易, 所以提前设定收盘时间) def get_prediction_data(klines, n):  """"""获取用于随机森林的n个输入数据(n为数据长度): n天中每天的特征参数及其涨跌情况""""""  close_prices = klines.close[- 30 - n:] # 获取本交易日及以前的收盘价(此时在预定的收盘时间: 认为本交易日已收盘)  # 计算所需指标  sma_data = sma(close_prices, 30, 0.02)[-n:] # SMA指标, 函数默认时间周期参数:30  wma_data = ema2(close_prices, 30)[-n:] # WMA指标  mom_data = trma(close_prices, 30)[-n:] # MOM指标  x_all = list(zip(sma_data, wma_data, mom_data)) # 样本特征组  y_all = list(klines.close.iloc[i] >= klines.close.iloc[i - 1] for i in list(reversed(range(-1, -n - 1, -1)))) # 样本标签组  # x_all:   大前天指标 前天指标 昨天指标 (今天指标)  # y_all: (大前天) 前天  昨天 今天  -明天-  # 准备算法需要用到的数据  x_train = x_all[: -1] # 训练数据: 特征  x_predict = x_all[-1] # 预测数据(用本交易日的指标预测下一交易日的涨跌)  y_train = y_all[1:] # 训练数据: 标签 (去掉第一个数据后让其与指标隔一位对齐(例如: 昨天的特征 -> 对应预测今天的涨跌标签))  return x_train, y_train, x_predict predictions = [] # 用于记录每次的预测结果(在每个交易日收盘时用收盘数据预测下一交易日的涨跌,并记录在此列表里) api = TqApi(backtest=TqBacktest(start_dt=datetime.date(2018, 7, 2), end_dt=datetime.date(2018, 9, 26)), auth=TqAuth(""信易账户"", ""账户密码"")) quote = api.get_quote(symbol) klines = api.get_kline_serial(symbol, duration_seconds=24 * 60 * 60) # 日线 target_pos = TargetPosTask(api, symbol) with closing(api):  try:   while True:    while not api.is_changing(klines.iloc[-1], ""datetime""): # 等到达下一个交易日     api.wait_update()    while True:     api.wait_update()     # 在收盘后预测下一交易日的涨跌情况     if api.is_changing(quote, ""datetime""):      now = datetime.datetime.strptime(quote.datetime, ""%Y-%m-%d %H:%M:%S.%f"") # 当前quote的时间      # 判断是否到达预定收盘时间: 如果到达 则认为本交易日收盘, 此时预测下一交易日的涨跌情况, 并调整为对应仓位      if now.hour == close_hour and now.minute >= close_minute:       # 1- 获取数据       x_train, y_train, x_predict = get_prediction_data(klines, 75) # 参数1: K线, 参数2:需要的数据长度       # 2- 利用机器学习算法预测下一个交易日的涨跌情况       # n_estimators 参数: 选择森林里（决策）树的数目; bootstrap 参数: 选择建立决策树时，是否使用有放回抽样       clf = RandomForestClassifier(n_estimators=30, bootstrap=True)       clf.fit(x_train, y_train) # 传入训练数据, 进行参数训练       predictions.append(bool(clf.predict([x_predict]))) # 传入测试数据进行预测, 得到预测的结果       # 3- 进行交易       if predictions[-1] == True: # 如果预测结果为涨: 买入        print(quote.datetime, ""预测下一交易日为 涨"")        target_pos.set_target_volume(10)       else: # 如果预测结果为跌: 卖出        print(quote.datetime, ""预测下一交易日为 跌"")        target_pos.set_target_volume(-10)       break  except BacktestFinished: # 回测结束, 获取预测结果，统计正确率   klines[""pre_close""] = klines[""close""].shift(1) # 增加 pre_close(上一交易日的收盘价) 字段   klines = klines[-len(predictions) + 1:] # 取出在回测日期内的K线数据   klines[""prediction""] = predictions[:-1] # 增加预测的本交易日涨跌情况字段(向后移一个数据目的: 将 本交易日对应下一交易日的涨跌 调整为 本交易日对应本交易日的涨跌)   results = (klines[""close""] - klines[""pre_close""] >= 0) == klines[""prediction""]   print(klines)   print(""----回测结束----"")   print(""预测结果正误:\n"", results)   print(""预测结果数目统计: 总计"", len(results),""个预测结果"")   print(pd.value_counts(results))   print(""预测的准确率:"")   print((pd.value_counts(results)[True]) / len(results)) "
130,n\tqsdk\demo\example\rbreake,"n\tqsdk\demo\example\rbreake. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' ''' R-Breaker策略(隔夜留仓) (难度：初级) 参考: https://www.shinnytech.com/blog/r-breaker 注: 该示例策略仅用于功能示范, 实盘时请根据自己的策略/经验进行修改 ''' from tqsdk import TqApi, TqAuth, TargetPosTask SYMBOL = ""SHFE.au2006"" # 合约代码 STOP_LOSS_PRICE = 10 # 止损点(价格) def get_index_line(klines):  '''计算指标线'''  high = klines.high.iloc[-2] # 前一日的最高价  low = klines.low.iloc[-2] # 前一日的最低价  close = klines.close.iloc[-2] # 前一日的收盘价  pivot = (high + low + close) / 3 # 枢轴点  b_break = high + 2 * (pivot - low) # 突破买入价  s_setup = pivot + (high - low) # 观察卖出价  s_enter = 2 * pivot - low # 反转卖出价  b_enter = 2 * pivot - high # 反转买入价  b_setup = pivot - (high - low) # 观察买入价  s_break = low - 2 * (high - pivot) # 突破卖出价  print(""已计算新标志线, 枢轴点: %f, 突破买入价: %f, 观察卖出价: %f, 反转卖出价: %f, 反转买入价: %f, 观察买入价: %f, 突破卖出价: %f""   % (pivot, b_break, s_setup, s_enter, b_enter, b_setup, s_break))  return pivot, b_break, s_setup, s_enter, b_enter, b_setup, s_break api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) quote = api.get_quote(SYMBOL) klines = api.get_kline_serial(SYMBOL, 24 * 60 * 60) # 86400: 使用日线 position = api.get_position(SYMBOL) target_pos = TargetPosTask(api, SYMBOL) target_pos_value = position.pos_long - position.pos_short # 目标净持仓数 open_position_price = position.open_price_long if target_pos_value > 0 else position.open_price_short # 开仓价 pivot, b_break, s_setup, s_enter, b_enter, b_setup, s_break = get_index_line(klines) # 七条标准线 while True:  target_pos.set_target_volume(target_pos_value)  api.wait_update()  if api.is_changing(klines.iloc[-1], ""datetime""): # 产生新k线,则重新计算7条指标线   pivot, b_break, s_setup, s_enter, b_enter, b_setup, s_break = get_index_line(klines)  '''交易规则'''  if api.is_changing(quote, ""last_price""):   print(""最新价: "", quote.last_price)   # 开仓价与当前行情价之差大于止损点则止损   if (target_pos_value > 0 and open_position_price - quote.last_price >= STOP_LOSS_PRICE) or \     (target_pos_value < 0 and quote.last_price - open_position_price >= STOP_LOSS_PRICE):    target_pos_value = 0 # 平仓   # 反转:   if target_pos_value > 0: # 多头持仓    if quote.highest > s_setup and quote.last_price < s_enter:     # 多头持仓,当日内最高价超过观察卖出价后，     # 盘中价格出现回落，且进一步跌破反转卖出价构成的支撑线时，     # 采取反转策略，即在该点位反手做空     print(""多头持仓,当日内最高价超过观察卖出价后跌破反转卖出价: 反手做空"")     target_pos_value = -3 # 做空     open_position_price = quote.last_price   elif target_pos_value < 0: # 空头持仓    if quote.lowest < b_setup and quote.last_price > b_enter:     # 空头持仓，当日内最低价低于观察买入价后，     # 盘中价格出现反弹，且进一步超过反转买入价构成的阻力线时，     # 采取反转策略，即在该点位反手做多     print(""空头持仓,当日最低价低于观察买入价后超过反转买入价: 反手做多"")     target_pos_value = 3 # 做多     open_position_price = quote.last_price   # 突破:   elif target_pos_value == 0: # 空仓条件    if quote.last_price > b_break:     # 在空仓的情况下，如果盘中价格超过突破买入价，     # 则采取趋势策略，即在该点位开仓做多     print(""空仓,盘中价格超过突破买入价: 开仓做多"")     target_pos_value = 3 # 做多     open_position_price = quote.last_price    elif quote.last_price < s_break:     # 在空仓的情况下，如果盘中价格跌破突破卖出价，     # 则采取趋势策略，即在该点位开仓做空     print(""空仓,盘中价格跌破突破卖出价: 开仓做空"")     target_pos_value = -3 # 做空     open_position_price = quote.last_price "
131,n\tqsdk\demo\example\rbreaker,"n\tqsdk\demo\example\rbreaker. # !/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' ''' R-Breaker策略(非隔夜留仓: 在每日收盘前，对所持合约进行平仓) 参考: https://www.shinnytech.com/blog/r-breaker 注: 该示例策略仅用于功能示范, 实盘时请根据自己的策略/经验进行修改 ''' from datetime import datetime from tqsdk import TqApi, TqAuth, TargetPosTask SYMBOL = ""SHFE.au2006"" # 合约代码 CLOSE_HOUR, CLOSE_MINUTE = 14, 50 # 平仓时间 STOP_LOSS_PRICE = 10 # 止损点(价格) api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) print(""策略开始运行"") def get_index_line(klines):  '''计算指标线'''  high = klines.high.iloc[-2] # 前一日的最高价  low = klines.low.iloc[-2] # 前一日的最低价  close = klines.close.iloc[-2] # 前一日的收盘价  pivot = (high + low + close) / 3 # 枢轴点  b_break = high + 2 * (pivot - low) # 突破买入价  s_setup = pivot + (high - low) # 观察卖出价  s_enter = 2 * pivot - low # 反转卖出价  b_enter = 2 * pivot - high # 反转买入价  b_setup = pivot - (high - low) # 观察买入价  s_break = low - 2 * (high - pivot) # 突破卖出价  print(""已计算新标志线, 枢轴点: %f, 突破买入价: %f, 观察卖出价: %f, 反转卖出价: %f, 反转买入价: %f, 观察买入价: %f, 突破卖出价: %f""   % (pivot, b_break, s_setup, s_enter, b_enter, b_setup, s_break))  return pivot, b_break, s_setup, s_enter, b_enter, b_setup, s_break quote = api.get_quote(SYMBOL) klines = api.get_kline_serial(SYMBOL, 24 * 60 * 60) # 86400: 使用日线 position = api.get_position(SYMBOL) target_pos = TargetPosTask(api, SYMBOL) target_pos_value = position.pos_long - position.pos_short # 目标净持仓数 open_position_price = position.open_price_long if target_pos_value > 0 else position.open_price_short # 开仓价 pivot, b_break, s_setup, s_enter, b_enter, b_setup, s_break = get_index_line(klines) # 七条标准线 while True:  target_pos.set_target_volume(target_pos_value)  api.wait_update()  if api.is_changing(klines.iloc[-1], ""datetime""): # 产生新k线,则重新计算7条指标线   pivot, b_break, s_setup, s_enter, b_enter, b_setup, s_break = get_index_line(klines)  if api.is_changing(quote, ""datetime""):   now = datetime.strptime(quote.datetime, ""%Y-%m-%d %H:%M:%S.%f"")   if now.hour == CLOSE_HOUR and now.minute >= CLOSE_MINUTE: # 到达平仓时间: 平仓    print(""临近本交易日收盘: 平仓"")    target_pos_value = 0 # 平仓    pivot = b_break = s_setup = s_enter = b_enter = b_setup = s_break = float(""nan"") # 修改各指标线的值, 避免平仓后再次触发  '''交易规则'''  if api.is_changing(quote, ""last_price""):   print(""最新价: %f"" % quote.last_price)   # 开仓价与当前行情价之差大于止损点则止损   if (target_pos_value > 0 and open_position_price - quote.last_price >= STOP_LOSS_PRICE) or \     (target_pos_value < 0 and quote.last_price - open_position_price >= STOP_LOSS_PRICE):    target_pos_value = 0 # 平仓   # 反转:   if target_pos_value > 0: # 多头持仓    if quote.highest > s_setup and quote.last_price < s_enter:     # 多头持仓,当日内最高价超过观察卖出价后，     # 盘中价格出现回落，且进一步跌破反转卖出价构成的支撑线时，     # 采取反转策略，即在该点位反手做空     print(""多头持仓,当日内最高价超过观察卖出价后跌破反转卖出价: 反手做空"")     target_pos_value = -3 # 做空     open_position_price = quote.last_price   elif target_pos_value < 0: # 空头持仓    if quote.lowest < b_setup and quote.last_price > b_enter:     # 空头持仓，当日内最低价低于观察买入价后，     # 盘中价格出现反弹，且进一步超过反转买入价构成的阻力线时，     # 采取反转策略，即在该点位反手做多     print(""空头持仓,当日最低价低于观察买入价后超过反转买入价: 反手做多"")     target_pos_value = 3 # 做多     open_position_price = quote.last_price   # 突破:   elif target_pos_value == 0: # 空仓条件    if quote.last_price > b_break:     # 在空仓的情况下，如果盘中价格超过突破买入价，     # 则采取趋势策略，即在该点位开仓做多     print(""空仓,盘中价格超过突破买入价: 开仓做多"")     target_pos_value = 3 # 做多     open_position_price = quote.last_price    elif quote.last_price < s_break:     # 在空仓的情况下，如果盘中价格跌破突破卖出价，     # 则采取趋势策略，即在该点位开仓做空     print(""空仓,盘中价格跌破突破卖出价: 开仓做空"")     target_pos_value = -3 # 做空     open_position_price = quote.last_price "
132,n\tqsdk\demo\example\turtl,"n\tqsdk\demo\example\turtl. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' ''' 海龟策略 (难度：中级) 参考: https://www.shinnytech.com/blog/turtle/ 注: 该示例策略仅用于功能示范, 实盘时请根据自己的策略/经验进行修改 ''' import json import time from tqsdk import TqApi, TqAuth, TargetPosTask from tqsdk.ta import ATR class Turtle:  def __init__(self, symbol, account=None, auth=None, donchian_channel_open_position=20,     donchian_channel_stop_profit=10,     atr_day_length=20, max_risk_ratio=0.5):   self.account = account # 交易账号   self.auth = auth # 信易账户   self.symbol = symbol # 合约代码   self.donchian_channel_open_position = donchian_channel_open_position # 唐奇安通道的天数周期(开仓)   self.donchian_channel_stop_profit = donchian_channel_stop_profit # 唐奇安通道的天数周期(止盈)   self.atr_day_length = atr_day_length # ATR计算所用天数   self.max_risk_ratio = max_risk_ratio # 最高风险度   self.state = {    ""position"": 0, # 本策略净持仓数(正数表示多头，负数表示空头，0表示空仓)    ""last_price"": float(""nan""), # 上次调仓价   }   self.n = 0 # 平均真实波幅(N值)   self.unit = 0 # 买卖单位   self.donchian_channel_high = 0 # 唐奇安通道上轨   self.donchian_channel_low = 0 # 唐奇安通道下轨   self.api = TqApi(self.account, auth=self.auth)   self.quote = self.api.get_quote(self.symbol)   # 由于ATR是路径依赖函数，因此使用更长的数据序列进行计算以便使其值稳定下来   kline_length = max(donchian_channel_open_position + 1, donchian_channel_stop_profit + 1, atr_day_length * 5)   self.klines = self.api.get_kline_serial(self.symbol, 24 * 60 * 60, data_length=kline_length)   self.account = self.api.get_account()   self.target_pos = TargetPosTask(self.api, self.symbol)  def recalc_paramter(self):   # 平均真实波幅(N值)   self.n = ATR(self.klines, self.atr_day_length)[""atr""].iloc[-1]   # 买卖单位   self.unit = int((self.account.balance * 0.01) / (self.quote.volume_multiple * self.n))   # 唐奇安通道上轨：前N个交易日的最高价   self.donchian_channel_high = max(self.klines.high[-self.donchian_channel_open_position - 1:-1])   # 唐奇安通道下轨：前N个交易日的最低价   self.donchian_channel_low = min(self.klines.low[-self.donchian_channel_open_position - 1:-1])   print(""唐其安通道上下轨: %f, %f"" % (self.donchian_channel_high, self.donchian_channel_low))   return True  def set_position(self, pos):   self.state[""position""] = pos   self.state[""last_price""] = self.quote[""last_price""]   self.target_pos.set_target_volume(self.state[""position""])  def try_open(self):   """"""开仓策略""""""   while self.state[""position""] == 0:    self.api.wait_update()    if self.api.is_changing(self.klines.iloc[-1], ""datetime""): # 如果产生新k线,则重新计算唐奇安通道及买卖单位     self.recalc_paramter()    if self.api.is_changing(self.quote, ""last_price""):     print(""最新价: %f"" % self.quote.last_price)     if self.quote.last_price > self.donchian_channel_high: # 当前价>唐奇安通道上轨，买入1个Unit；(持多仓)      print(""当前价>唐奇安通道上轨，买入1个Unit(持多仓): %d 手"" % self.unit)      self.set_position(self.state[""position""] + self.unit)     elif self.quote.last_price < self.donchian_channel_low: # 当前价<唐奇安通道下轨，卖出1个Unit；(持空仓)      print(""当前价<唐奇安通道下轨，卖出1个Unit(持空仓): %d 手"" % self.unit)      self.set_position(self.state[""position""] - self.unit)  def try_close(self):   """"""交易策略""""""   while self.state[""position""] != 0:    self.api.wait_update()    if self.api.is_changing(self.quote, ""last_price""):     print(""最新价: "", self.quote.last_price)     if self.state[""position""] > 0: # 持多单      # 加仓策略: 如果是多仓且行情最新价在上一次建仓（或者加仓）的基础上又上涨了0.5N，就再加一个Unit的多仓,并且风险度在设定范围内(以防爆仓)      if self.quote.last_price >= self.state[       ""last_price""] + 0.5 * self.n and self.account.risk_ratio <= self.max_risk_ratio:       print(""加仓:加1个Unit的多仓"")       self.set_position(self.state[""position""] + self.unit)      # 止损策略: 如果是多仓且行情最新价在上一次建仓（或者加仓）的基础上又下跌了2N，就卖出全部头寸止损      elif self.quote.last_price <= self.state[""last_price""] - 2 * self.n:       print(""止损:卖出全部头寸"")       self.set_position(0)      # 止盈策略: 如果是多仓且行情最新价跌破了10日唐奇安通道的下轨，就清空所有头寸结束策略,离场      if self.quote.last_price <= min(self.klines.low[-self.donchian_channel_stop_profit - 1:-1]):       print(""止盈:清空所有头寸结束策略,离场"")       self.set_position(0)     elif self.state[""position""] < 0: # 持空单      # 加仓策略: 如果是空仓且行情最新价在上一次建仓（或者加仓）的基础上又下跌了0.5N，就再加一个Unit的空仓,并且风险度在设定范围内(以防爆仓)      if self.quote.last_price <= self.state[       ""last_price""] - 0.5 * self.n and self.account.risk_ratio <= self.max_risk_ratio:       print(""加仓:加1个Unit的空仓"")       self.set_position(self.state[""position""] - self.unit)      # 止损策略: 如果是空仓且行情最新价在上一次建仓（或者加仓）的基础上又上涨了2N，就平仓止损      elif self.quote.last_price >= self.state[""last_price""] + 2 * self.n:       print(""止损:卖出全部头寸"")       self.set_position(0)      # 止盈策略: 如果是空仓且行情最新价升破了10日唐奇安通道的上轨，就清空所有头寸结束策略,离场      if self.quote.last_price >= max(self.klines.high[-self.donchian_channel_stop_profit - 1:-1]):       print(""止盈:清空所有头寸结束策略,离场"")       self.set_position(0)  def strategy(self):   """"""海龟策略""""""   print(""等待K线及账户数据..."")   deadline = time.time() + 5   while not self.recalc_paramter():    if not self.api.wait_update(deadline=deadline):     raise Exception(""获取数据失败，请确认行情连接正常并已经登录交易账户"")   while True:    self.try_open()    self.try_close() turtle = Turtle(""SHFE.au2006"") print(""策略开始运行"") try:  turtle.state = json.load(open(""turtle_state.json"", ""r"")) # 读取数据: 本策略目标净持仓数,上一次开仓价 except FileNotFoundError:  pass print(""当前持仓数: %d, 上次调仓价: %f"" % (turtle.state[""position""], turtle.state[""last_price""])) try:  turtle.strategy() finally:  turtle.api.close()  json.dump(turtle.state, open(""turtle_state.json"", ""w"")) # 保存数据 "
133,n\tqsdk\demo\example\vwa,"n\tqsdk\demo\example\vwa. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' ''' Volume Weighted Average Price策略 (难度：高级) 参考: https://www.shinnytech.com/blog/vwap 注: 该示例策略仅用于功能示范, 实盘时请根据自己的策略/经验进行修改 ''' import datetime from tqsdk import TqApi, TqAuth, TargetPosTask TIME_CELL = 5 * 60 # 等时长下单的时间单元, 单位: 秒 TARGET_VOLUME = 300 # 目标交易手数 (>0: 多头, <0: 空头) SYMBOL = ""DCE.jd2001"" # 交易合约代码 HISTORY_DAY_LENGTH = 20 # 使用多少天的历史数据用来计算每个时间单元的下单手数 START_HOUR, START_MINUTE = 9, 35 # 计划交易时段起始时间点 END_HOUR, END_MINUTE = 10, 50 # 计划交易时段终点时间点 api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) print(""策略开始运行"") # 根据 HISTORY_DAY_LENGTH 推算出需要订阅的历史数据长度, 需要注意history_day_length与time_cell的比例关系以避免超过订阅限制 time_slot_start = datetime.time(START_HOUR, START_MINUTE) # 计划交易时段起始时间点 time_slot_end = datetime.time(END_HOUR, END_MINUTE) # 计划交易时段终点时间点 klines = api.get_kline_serial(SYMBOL, TIME_CELL, data_length=int(10 * 60 * 60 / TIME_CELL * HISTORY_DAY_LENGTH)) target_pos = TargetPosTask(api, SYMBOL) position = api.get_position(SYMBOL) # 持仓信息 def get_kline_time(kline_datetime):  """"""获取k线的时间(不包含日期)""""""  kline_time = datetime.datetime.fromtimestamp(kline_datetime // 1000000000).time() # 每根k线的时间  return kline_time def get_market_day(kline_datetime):  """"""获取k线所对应的交易日""""""  kline_dt = datetime.datetime.fromtimestamp(kline_datetime // 1000000000) # 每根k线的日期和时间  if kline_dt.hour >= 18: # 当天18点以后: 移到下一个交易日   kline_dt = kline_dt + datetime.timedelta(days=1)  while kline_dt.weekday() >= 5: # 是周六或周日,移到周一   kline_dt = kline_dt + datetime.timedelta(days=1)  return kline_dt.date() # 添加辅助列: time及date, 分别为K线时间的时:分:秒和其所属的交易日 klines[""time""] = klines.datetime.apply(lambda x: get_kline_time(x)) klines[""date""] = klines.datetime.apply(lambda x: get_market_day(x)) # 获取在预设交易时间段内的所有K线, 即时间位于 time_slot_start 到 time_slot_end 之间的数据 if time_slot_end > time_slot_start: # 判断是否类似 23:00:00 开始， 01:00:00 结束这样跨天的情况  klines = klines[(klines[""time""] >= time_slot_start) & (klines[""time""] <= time_slot_end)] else:  klines = klines[(klines[""time""] >= time_slot_start) | (klines[""time""] <= time_slot_end)] # 由于可能有节假日导致部分天并没有填满整个预设交易时间段 # 因此去除缺失部分交易时段的日期(即剩下的每个日期都包含预设的交易时间段内所需的全部时间单元) date_cnt = klines[""date""].value_counts() max_num = date_cnt.max() # 所有日期中最完整的交易时段长度 need_date = date_cnt[date_cnt == max_num].sort_index().index[-HISTORY_DAY_LENGTH - 1:-1] # 获取今天以前的预设数目个交易日的日期 df = klines[klines[""date""].isin(need_date)] # 最终用来计算的k线数据 # 计算每个时间单元的成交量占比, 并使用算数平均计算出预测值 datetime_grouped = df.groupby(['date', 'time'])['volume'].sum() # 将K线的volume按照date、time建立多重索引分组 # 计算每个交易日内的预设交易时间段内的成交量总和(level=0: 表示按第一级索引""data""来分组)后,将每根k线的成交量除以所在交易日内的总成交量,计算其所占比例 volume_percent = datetime_grouped / datetime_grouped.groupby(level=0).sum() predicted_percent = volume_percent.groupby(level=1).mean() # 将历史上相同时间单元的成交量占比使用算数平均计算出预测值 print(""各时间单元成交量占比: %s"" % predicted_percent) # 计算每个时间单元的成交量预测值 predicted_volume = {} # 记录每个时间单元需调整的持仓量 percentage_left = 1 # 剩余比例 volume_left = TARGET_VOLUME # 剩余手数 for index, value in predicted_percent.items():  volume = round(volume_left * (value / percentage_left))  predicted_volume[index] = volume  percentage_left -= value  volume_left -= volume print(""各时间单元应下单手数: %s"" % predicted_volume) # 交易 current_volume = 0 # 记录已调整持仓量 while True:  api.wait_update()  # 新产生一根K线并且在计划交易时间段内: 调整目标持仓量  if api.is_changing(klines.iloc[-1], ""datetime""):   t = datetime.datetime.fromtimestamp(klines.iloc[-1][""datetime""] // 1000000000).time()   if t in predicted_volume:    current_volume += predicted_volume[t]    print(""到达下一时间单元,调整持仓为: %d"" % current_volume)    target_pos.set_target_volume(current_volume)  # 用持仓信息判断是否完成所有目标交易手数  if api.is_changing(position, ""volume_long"") or api.is_changing(position, ""volume_short""):   if position[""volume_long""] - position[""volume_short""] == TARGET_VOLUME:    break api.close() "
134,n\tqsdk\demo\example\  init ,n\tqsdk\demo\example\  init . 
135,n\tqsdk\demo\option tutorial\o1,"n\tqsdk\demo\option tutorial\o1. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'ringo' from tqsdk import TqApi, TqAuth # 创建API实例,传入自己的信易账户 api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 获取大商所豆粕期权行情 quote_m = api.get_quote(""DCE.m1807-C-2450"") # 获取中金所股指期权行情 quote_IO = api.get_quote(""CFFEX.IO2002-C-3550"") # 输出 m1807-C-2450 的最新行情时间和最新价 print(quote_m.datetime, quote_m.last_price) # 关闭api,释放资源 api.close() "
136,n\tqsdk\demo\option tutorial\o2,"n\tqsdk\demo\option tutorial\o2. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'ringo' from tqsdk import TqApi, TqAuth api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) ls = api.query_options(""SHFE.au2012"") print(ls) # 标的为 ""SHFE.au2012"" 的所有期权 ls = api.query_options(""SHFE.au2012"", option_class=""PUT"") print(ls) # 标的为 ""SHFE.au2012"" 的看跌期权 ls = api.query_options(""SHFE.au2012"", option_class=""PUT"", expired=False) print(ls) # 标的为 ""SHFE.au2012"" 的看跌期权, 未下市的 ls = api.query_options(""SHFE.au2012"", strike_price=340) print(ls) # 标的为 ""SHFE.au2012"" 、行权价为 340 的期权 ls = api.query_options(""SSE.000300"", exchange_id=""CFFEX"") print(ls) # 中金所沪深300股指期权 ls = api.query_options(""SSE.510300"", exchange_id=""SSE"") print(ls) # 上交所沪深300etf期权 ls = api.query_options(""SSE.510300"", exchange_id=""SSE"", exercise_year=2020, exercise_month=12) print(ls) # 上交所沪深300etf期权, 限制条件 2020 年 12 月份行权 api.close()"
137,n\tqsdk\demo\option tutorial\o3,"n\tqsdk\demo\option tutorial\o3. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'ringo' from tqsdk import TqApi, TqAuth api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) quote = api.get_quote(""SHFE.au2012"") # 预计输出的为以au2012现在最新价来比对的认购的平值期权，当没有符合的平值期权时返回为空,如果有返回则格式为 [""SHFE.au2012C30000""] ls = api.query_atm_options(""SHFE.au2012"", quote.last_price, 0, ""CALL"") # 预计输出的为au2012，以开盘价来比对的认购的实值3档，实值2档，实值1档期权，如果没有符合要求的期权则对应栏返回为None，如果有则返回格式例如 [None,None,""SHFE.au2012C30000""] ls = api.query_atm_options(""SHFE.au2012"", quote.open, [3, 2, 1], ""CALL"") # 预计输出的为au2012，以开盘价来比对的认购的实值1档，平值期权，虚值1档，如果没有符合要求的期权则对应栏返回为None，如果有则返回格式例如 ls = api.query_atm_options(""SHFE.au2012"", quote.open, [1, 0, -1], ""CALL"") # 预计输出的为au2012，以现在最新价来比对的认购的虚值1档期权 ls = api.query_atm_options(""SHFE.au2012"", quote.last_price, -1, ""CALL"") # 预计输出沪深300股指期权,2020年12月的虚值1档期权 ls = api.query_atm_options(""SSE.000300"", quote.last_price, -1, ""CALL"", exercise_year=2020, exercise_month=12) # 预计输出 上交所 沪深300股指ETF期权,2020年12月的虚值1档期权 ls = api.query_atm_options(""SSE.510300"", quote.last_price, -1, ""CALL"", exercise_year=2020, exercise_month=12) api.close() "
138,n\tqsdk\demo\option tutorial\o4,"n\tqsdk\demo\option tutorial\o4. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'ringo' from tqsdk import TqApi, TqAuth from tqsdk.ta import OPTION_GREEKS api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 获取指定期权行情 quote = api.get_quote(""SHFE.cu2006C44000"") # 获取期权和其对应标的的多合约的 kline 数据 klines = api.get_kline_serial([""SHFE.cu2006C44000"", ""SHFE.cu2006""], 24 * 60 * 60, 30) # 运行 OPTION_GREEKS 希腊值计算函数 greeks = OPTION_GREEKS(klines, quote, 0.025) # 输出希腊字母 print(list(greeks[""delta""])) print(list(greeks[""theta""])) print(list(greeks[""gamma""])) print(list(greeks[""vega""])) print(list(greeks[""rho""])) api.close() "
139,n\tqsdk\demo\option tutorial\o4,"n\tqsdk\demo\option tutorial\o4. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'ringo' from tqsdk import TqApi, TqAuth from tqsdk.ta import OPTION_IMPV api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 获取指定期权行情 quote = api.get_quote(""SHFE.cu2006C50000"") # 获取期权和对应标的的多合约 kline klines = api.get_kline_serial([""SHFE.cu2006C50000"", ""SHFE.cu2006""], 24 * 60 * 60, 20) # 通过 OPTION_IMPV 函数计算隐含波动率，设置无风险利率为 0.025 impv = OPTION_IMPV(klines, quote, 0.025) print(list(impv[""impv""] * 100)) api.close() "
140,n\tqsdk\demo\option tutorial\o6,"n\tqsdk\demo\option tutorial\o6. from tqsdk import TqApi, TqAuth from tqsdk.ta import VOLATILITY_CURVE api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 获取 m2112 的看跌期权 underlying = ""DCE.m2101"" options = api.query_options(underlying_symbol=underlying, option_class=""PUT"", expired=False) # 批量获取合约的行情信息, 存储结构必须为 dict, key 为合约, value 为行情数据 quote = {} for symbol in options:  quote[symbol] = api.get_quote(symbol) options.append(underlying) klines = api.get_kline_serial(options, 24 * 60 * 60, 20) # 使用 VOLATILITY_CURVE 函数计算波动率曲面 vc = VOLATILITY_CURVE(klines, quote, underlying, r=0.025) print(vc) api.close() "
141,n\tqsdk\demo\option tutorial\o7,"n\tqsdk\demo\option tutorial\o7. from tqsdk import TqApi, TqAuth ''' 如果买入看涨期权构建多头期货的价格小于卖出期货价格 存在套利机会则发出双边挂单 ''' api = TqApi(auth=TqAuth(""信易账户"", ""账号密码"")) # 获取行权价为2950的MA109看涨期权的quote数据 quote_option = api.get_quote('CZCE.MA109C2950') # 获取期权对应标的期货，即MA109的quote数据 quote = api.get_quote(quote_option.underlying_symbol) # 套利机会尝试次数 times = 0 while True:  api.wait_update()  # 以对手价来计算买入看涨期权然后行权后的期货成本价格  option_buy = quote_option.strike_price + quote_option.ask_price1  # 判断当期货的买入1档，即卖出期货价格大于买入看涨期权的期货成本价格，形成套利空间时进行限价下单  if quote.bid_price1 > option_buy and times == 0:   times += 1   # 以现在卖1档价格买入看涨期权   order_opiton = api.insert_order('CZCE.MA109C2950', ""BUY"", ""OPEN"", 1, quote_option.ask_price1)   # 以现在买1档的价格卖出期货   order_future = api.insert_order(quote.underlying_symbol, ""SELL"", ""OPEN"", 1, quote.bid_price1)   print(""存在期货，期权套利空间尝试买入"") "
142,n\tqsdk\demo\option tutorial\o7,"n\tqsdk\demo\option tutorial\o7. from tqsdk import TqApi, TqAuth ''' 获取标的对应看涨期权的期权和行权价对应列表 ''' api = TqApi(auth=TqAuth(""信易账户"", ""账号密码"")) # 获取沪深300股指期权的认购在市合约 ls = api.query_options(""SSE.000300"", ""CALL"", expired=False) # 批量获取这些合约的quote合约信息 quote_ls = api.get_quote_list(ls) option_ls = {} # 遍历quote合约信息，将合约和其对应行权价组装成字典 for i in quote_ls:  option_ls[i.instrument_id] = i.strike_price print(option_ls) api.close()"
143,n\tqsdk\demo\option tutorial\o7,"n\tqsdk\demo\option tutorial\o7. from tqsdk import TqApi, TqAuth from datetime import datetime from tqsdk.tafunc import time_to_datetime ''' 查询标的对应期权按虚值平值实值分类 ''' from tqsdk import TqApi, TqAuth api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) quote = api.get_quote(""SHFE.au2112"") in_money_options, at_money_options, out_of_money_options = api.query_all_level_options(""SHFE.au2112"", quote.last_price, ""CALL"") print(in_money_options) # 实值期权列表 print(at_money_options) # 平值期权列表 print(out_of_money_options) # 虚值期权列表 api.close() "
144,n\tqsdk\demo\option tutorial\o7,"n\tqsdk\demo\option tutorial\o7. from tqsdk import TqApi, TqAuth from datetime import datetime from tqsdk.tafunc import time_to_datetime ''' 查询标的对应期权按虚值平值实值分类 ''' from tqsdk import TqApi, TqAuth api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) quote = api.get_quote(""SSE.510300"") # 获取下月的上交所看涨300etf期权 in_money_options, at_money_options, out_of_money_options = api.query_all_level_finance_options(""SSE.510300"", quote.last_price, ""CALL"", nearbys = 1) print(in_money_options) # 实值期权列表 print(at_money_options) # 平值期权列表 print(out_of_money_options) # 虚值期权列表 api.close() "
145,n\tqsdk\demo\option tutorial\o7,"n\tqsdk\demo\option tutorial\o7. from tqsdk import TqApi, TqAuth ''' 根据输入的ETF期权来查询该期权的交易所规则下的理论卖方保证金，实际情况请以期货公司收取的一手保证金为准 ''' def etf_margin_cal(symbol):  quote_etf = api.get_quote(symbol)  # 判断期权标的是不是ETF  if quote_etf.underlying_symbol in [""SSE.510050"", ""SSE.510300"", ""SZSE.159919""]:   if quote_etf.option_class == ""CALL"":    # 认购期权虚值＝Max（行权价-合约标的前收盘价，0）    call_out_value = max(quote_etf.strike_price - quote_etf.underlying_quote.pre_close, 0)    # 认购期权义务仓开仓保证金＝[合约前结算价+Max（12%×合约标的前收盘价-认购期权虚值，7%×合约标的前收盘价）]×合约单位    call_margin = (quote_etf.pre_settlement + max(0.12 * quote_etf.underlying_quote.pre_close - call_out_value,               0.07 * quote_etf.underlying_quote.pre_close)) * quote_etf.volume_multiple    return round(call_margin, 2)   elif quote_etf.option_class == ""PUT"":    # 认沽期权虚值＝Max（合约标的前收盘价-行权价，0）    put_out_value = max(quote_etf.underlying_quote.pre_close - quote_etf.strike_price, 0)    # 认沽期权义务仓开仓保证金＝Min[合约前结算价+Max（12%×合约标的前收盘价-认沽期权虚值，7%×行权价），行权价]×合约单位。    put_margin = min(quote_etf.pre_settlement + max(0.12 * quote_etf.underlying_quote.pre_close - put_out_value,                0.07 * quote_etf.strike_price),        quote_etf.strike_price) * quote_etf.volume_multiple    return round(put_margin, 2)  else:   print(""输入的不是ETF期权合约"")   return None # 创建api api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 深交所300etf期权 symbol = ""SZSE.90000833"" print(etf_margin_cal(symbol)) api.close() "
146,n\tqsdk\demo\option tutorial\  init ,n\tqsdk\demo\option tutorial\  init . 
147,n\tqsdk\demo\tutorial\backtes,"n\tqsdk\demo\tutorial\backtes. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' from datetime import date from tqsdk import TqApi, TqAuth, TqBacktest, TargetPosTask ''' 如果当前价格大于5分钟K线的MA15则开多仓 如果小于则平仓 回测从 2018-05-01 到 2018-10-01 ''' # 在创建 api 实例时传入 TqBacktest 就会进入回测模式 api = TqApi(backtest=TqBacktest(start_dt=date(2018, 5, 1), end_dt=date(2018, 10, 1)), auth=TqAuth(""信易账户"", ""账户密码"")) # 获得 m1901 5分钟K线的引用 klines = api.get_kline_serial(""DCE.m1901"", 5 * 60, data_length=15) # 创建 m1901 的目标持仓 task，该 task 负责调整 m1901 的仓位到指定的目标仓位 target_pos = TargetPosTask(api, ""DCE.m1901"") while True:  api.wait_update()  if api.is_changing(klines):   ma = sum(klines.close.iloc[-15:]) / 15   print(""最新价"", klines.close.iloc[-1], ""MA"", ma)   if klines.close.iloc[-1] > ma:    print(""最新价大于MA: 目标多头5手"")    # 设置目标持仓为多头5手    target_pos.set_target_volume(5)   elif klines.close.iloc[-1] < ma:    print(""最新价小于MA: 目标空仓"")    # 设置目标持仓为空仓    target_pos.set_target_volume(0) "
148,n\tqsdk\demo\tutorial\downloade,"n\tqsdk\demo\tutorial\downloade. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' from datetime import datetime from contextlib import closing from tqsdk import TqApi, TqAuth from tqsdk.tools import DataDownloader api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 下载从 2018-01-01凌晨6点 到 2018-06-01下午4点 的 cu1805 分钟线数据 kd = DataDownloader(api, symbol_list=""SHFE.cu1805"", dur_sec=60,      start_dt=datetime(2018, 1, 1, 6, 0 ,0), end_dt=datetime(2018, 6, 1, 16, 0, 0), csv_file_name=""kline.csv"") # 下载从 2018-05-01凌晨0点 到 2018-07-01凌晨0点 的 T1809 盘口Tick数据 td = DataDownloader(api, symbol_list=""CFFEX.T1809"", dur_sec=0,      start_dt=datetime(2018, 5, 1), end_dt=datetime(2018, 7, 1), csv_file_name=""tick.csv"") # 使用with closing机制确保下载完成后释放对应的资源 with closing(api):  while not kd.is_finished() or not td.is_finished():   api.wait_update()   print(""progress: kline: %.2f%% tick:%.2f%%"" % (kd.get_progress(), td.get_progress())) "
149,n\tqsdk\demo\tutorial\repla,"n\tqsdk\demo\tutorial\repla. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' from datetime import date from tqsdk import TqApi, TqAuth, TqReplay ''' 复盘模式示例: 指定日期行情完全复盘 复盘 2020-05-26 行情 ''' # 在创建 api 实例时传入 TqReplay 就会进入复盘模式 api = TqApi(backtest=TqReplay(date(2020, 5, 26)), auth=TqAuth(""信易账户"", ""账户密码"")) quote = api.get_quote(""SHFE.cu2009"") while True:  api.wait_update()  if api.is_changing(quote):   print(""最新价"", quote.datetime, quote.last_price) "
150,n\tqsdk\demo\tutorial\replay,"n\tqsdk\demo\tutorial\replay. #!usr/bin/env python3 #-*- coding:utf-8 -*- #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' from datetime import date from tqsdk import TqApi, TqAuth, TqReplay, TargetPosTask ''' 复盘 2020-05-26 如果当前价格大于5分钟K线的MA15则开多仓,如果小于则平仓 ''' # 在创建 api 实例时传入 TqReplay 就会进入复盘模式, 同时打开 web_gui api = TqApi(backtest=TqReplay(date(2020, 5, 26)), web_gui=True, auth=TqAuth(""信易账户"", ""账户密码"")) # 获得 cu2009 5分钟K线的引用 klines = api.get_kline_serial(""SHFE.cu2009"", 5 * 60, data_length=15) # 创建 cu2009 的目标持仓 task，该 task 负责调整 m1901 的仓位到指定的目标仓位 target_pos = TargetPosTask(api, ""SHFE.cu2009"") while True:  api.wait_update()  if api.is_changing(klines):   ma = sum(klines.close.iloc[-15:]) / 15   print(""最新价"", klines.close.iloc[-1], ""MA"", ma)   if klines.close.iloc[-1] > ma:    print(""最新价大于MA: 目标多头5手"")    # 设置目标持仓为多头5手    target_pos.set_target_volume(5)   elif klines.close.iloc[-1] < ma:    print(""最新价小于MA: 目标空仓"")    # 设置目标持仓为空仓    target_pos.set_target_volume(0) "
151,n\tqsdk\demo\tutorial\t1,"n\tqsdk\demo\tutorial\t1. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' from tqsdk import TqApi, TqAuth # 创建API实例,传入自己的信易账户 api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 获得上期所 ni2206 的行情引用，当行情有变化时 quote 中的字段会对应更新 quote = api.get_quote(""SHFE.ni2206"") # 输出 ni2206 的最新行情时间和最新价 print(quote.datetime, quote.last_price) # 关闭api,释放资源 api.close() "
152,n\tqsdk\demo\tutorial\t2,"n\tqsdk\demo\tutorial\t2. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' from tqsdk import TqApi, TqAuth # 可以指定debug选项将调试信息写入指定的文件中 api = TqApi(debug=""debug.log"", auth=TqAuth(""信易账户"", ""账户密码"")) quote = api.get_quote(""CZCE.FG209"") print(quote.datetime, quote.last_price, quote.ask_price1, quote.ask_price2) while True:  # 调用 wait_update 等待业务信息发生变化，例如: 行情发生变化, 委托单状态变化, 发生成交等等  # 注意：其他合约的行情的更新也会触发业务信息变化，因此下面使用 is_changing 判断 FG209 的行情是否有变化  api.wait_update()  # 如果 FG209 的任何字段有变化，is_changing就会返回 True  if api.is_changing(quote):   print(""行情变化"", quote)  # 只有当 FG209 的最新价有变化，is_changing才会返回 True  if api.is_changing(quote, ""last_price""):   print(""最新价变化"", quote.last_price)  # 当 FG209 的买1价/买1量/卖1价/卖1量中任何一个有变化，is_changing都会返回 True  if api.is_changing(quote, [""ask_price1"", ""ask_volume1"", ""bid_price1"", ""bid_volume1""]):   print(""盘口变化"", quote.ask_price1, quote.ask_volume1, quote.bid_price1, quote.bid_volume1) "
153,n\tqsdk\demo\tutorial\t3,"n\tqsdk\demo\tutorial\t3. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' from tqsdk import TqApi, TqAuth import datetime api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 获得 i2209 tick序列的引用 ticks = api.get_tick_serial(""DCE.i2209"") # 获得 i2209 10秒K线的引用 klines = api.get_kline_serial(""DCE.i2209"", 10) print(datetime.datetime.fromtimestamp(klines.iloc[-1][""datetime""] / 1e9)) while True:  api.wait_update()  # 判断整个tick序列是否有变化  if api.is_changing(ticks):   # ticks.iloc[-1]返回序列中最后一个tick   print(""tick变化"", ticks.iloc[-1])  # 判断最后一根K线的时间是否有变化，如果发生变化则表示新产生了一根K线  if api.is_changing(klines.iloc[-1], ""datetime""):   # datetime: 自unix epoch(1970-01-01 00:00:00 GMT)以来的纳秒数   print(""新K线"", datetime.datetime.fromtimestamp(klines.iloc[-1][""datetime""] / 1e9))  # 判断最后一根K线的收盘价是否有变化  if api.is_changing(klines.iloc[-1], ""close""):   # klines.close返回收盘价序列   print(""K线变化"", datetime.datetime.fromtimestamp(klines.iloc[-1][""datetime""] / 1e9), klines.close.iloc[-1]) "
154,n\tqsdk\demo\tutorial\t4,"n\tqsdk\demo\tutorial\t4. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' from tqsdk import TqApi, TqAuth api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 获得 m2105 的持仓引用，当持仓有变化时 position 中的字段会对应更新 position = api.get_position(""DCE.m2105"") # 获得资金账户引用，当账户有变化时 account 中的字段会对应更新 account = api.get_account() # 下单并返回委托单的引用，当该委托单有变化时 order 中的字段会对应更新 order = api.insert_order(symbol=""DCE.m2105"", direction=""BUY"", offset=""OPEN"", volume=5, limit_price=2750) while True:  api.wait_update()  if api.is_changing(order, [""status"", ""volume_orign"", ""volume_left""]):   print(""单状态: %s, 已成交: %d 手"" % (order.status, order.volume_orign - order.volume_left))  if api.is_changing(position, ""pos_long_today""):   print(""今多头: %d 手"" % (position.pos_long_today))  if api.is_changing(account, ""available""):   print(""可用资金: %.2f"" % (account.available)) "
155,n\tqsdk\demo\tutorial\t4,"n\tqsdk\demo\tutorial\t4. #!/usr/bin/env python # -*- coding: utf-8 -*- from tqsdk import TqApi, TqAuth api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) quote = api.get_quote(""SHFE.ni2206"") # 开仓两手并等待完成 order = api.insert_order(symbol=""SHFE.ni2206"", direction=""BUY"", offset=""OPEN"", limit_price=quote.ask_price1, volume=2) while order.status != ""FINISHED"":  api.wait_update() print(""已开仓"") # 平今两手并等待完成 order = api.insert_order(symbol=""SHFE.ni2206"", direction=""SELL"", offset=""CLOSETODAY"", limit_price=quote.bid_price1,       volume=2) while order.status != ""FINISHED"":  api.wait_update() print(""已平今"") # 关闭api,释放相应资源 api.close() "
156,n\tqsdk\demo\tutorial\t6,"n\tqsdk\demo\tutorial\t6. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' from tqsdk import TqApi, TqAuth ''' 如果当前价格大于10秒K线的MA15则开多仓 (使用 insert_order() 函数) 如果小于则平仓 ''' api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 获得 m2207 10秒K线的引用 klines = api.get_kline_serial(""DCE.m2207"", 10) # 判断开仓条件 while True:  api.wait_update()  if api.is_changing(klines):   ma = sum(klines.close.iloc[-15:]) / 15   print(""最新价"", klines.close.iloc[-1], ""MA"", ma)   if klines.close.iloc[-1] > ma:    print(""最新价大于MA: 市价开仓"")    api.insert_order(symbol=""DCE.m2207"", direction=""BUY"", offset=""OPEN"", volume=5)    break # 判断平仓条件 while True:  api.wait_update()  if api.is_changing(klines):   ma = sum(klines.close.iloc[-15:]) / 15   print(""最新价"", klines.close.iloc[-1], ""MA"", ma)   if klines.close.iloc[-1] < ma:    print(""最新价小于MA: 市价平仓"")    api.insert_order(symbol=""DCE.m2207"", direction=""SELL"", offset=""CLOSE"", volume=5)    break # 关闭api,释放相应资源 api.close() "
157,n\tqsdk\demo\tutorial\t7,"n\tqsdk\demo\tutorial\t7. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' from tqsdk import TqApi, TqAuth, TargetPosTask ''' 如果当前价格大于10秒K线的MA15则开多仓 (使用 TargetPosTask 调仓工具) 如果小于则平仓 ''' api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 获得 m2207 10秒K线的引用 klines = api.get_kline_serial(""DCE.m2207"", 10) # 创建 m2207 的目标持仓 task，该 task 负责调整 m2207 的仓位到指定的目标仓位 target_pos = TargetPosTask(api, ""DCE.m2207"") while True:  api.wait_update()  if api.is_changing(klines):   ma = sum(klines.close.iloc[-15:]) / 15   print(""最新价"", klines.close.iloc[-1], ""MA"", ma)   if klines.close.iloc[-1] > ma:    print(""最新价大于MA: 目标多头5手"")    # 设置目标持仓为多头5手    target_pos.set_target_volume(5)   elif klines.close.iloc[-1] < ma:    print(""最新价小于MA: 目标空仓"")    # 设置目标持仓为空仓    target_pos.set_target_volume(0) "
158,n\tqsdk\demo\tutorial\t7,"n\tqsdk\demo\tutorial\t7. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'yanqiong' from tqsdk import TqApi, TqAuth, TargetPosTask ''' 连续3根阴线就做空，连续3根阳线就做多，否则空仓 ''' api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 设定连续多少根阳线/阴线 length = 3 # 获得 ni2205 10秒K线的引用, 长度为 length+1 klines = api.get_kline_serial(""SHFE.ni2205"", 10, data_length=length + 1) # 创建 ni2205 的目标持仓 task，该 task 负责调整 ni2105 的仓位到指定的目标仓位, offset_priority的用法详见文档 target_pos = TargetPosTask(api, ""SHFE.ni2205"", offset_priority=""今昨开"") while True:  api.wait_update()  # 只有在新创建出K线时才判断开平仓条件  if api.is_changing(klines.iloc[-1], ""datetime""):   # 跳过最后一根刚生成的K线   df = klines.iloc[:-1]   # 比较收盘价和开盘价，判断是阳线还是阴线   # df.close 为收盘价序列, df.open 为开盘价序列, "">""(pandas.Series.gt) 返回收盘价是否大于开盘价的一个新序列   up = df.close > df.open   down = df.close < df.open   if all(up):    print(""连续阳线: 目标持仓 多头1手"")    # 设置目标持仓为正数表示多头，负数表示空头，0表示空仓    target_pos.set_target_volume(1)   elif all(down):    print(""连续阴线: 目标持仓 空头1手"")    target_pos.set_target_volume(-1)   else:    print(""目标持仓: 空仓"")    target_pos.set_target_volume(0) "
159,n\tqsdk\demo\tutorial\t7,"n\tqsdk\demo\tutorial\t7. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'ringo' from tqsdk import TqApi, TqAuth from tqsdk.tafunc import time_to_datetime ''' 使用get_trading_status来判断合约是否进入交易状态来进行下单，该接口需要有天勤量化专业版资格才可使用 ''' api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) ts = api.get_trading_status(""SHFE.cu2201"") print(ts.trade_status) while True:  api.wait_update()  # 如果处于集合竞价状态则进行下单  if ts.trade_status == ""AUCTIONORDERING"":   order = api.insert_order(""SHFE.cu2201"", ""BUY"", ""OPEN"", 1, 71400)   break # insert_order指令会在下一次wait_update()发出 api.wait_update() api.close() "
160,n\tqsdk\demo\tutorial\t8,"n\tqsdk\demo\tutorial\t8. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' from tqsdk import TqApi, TqAuth, TargetPosTask ''' 价差回归 当近月-远月的价差大于250时做空近月，做多远月 当价差小于200时平仓 ''' api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) quote_near = api.get_quote(""SHFE.rb2104"") quote_deferred = api.get_quote(""SHFE.rb2105"") # 创建 rb2104 的目标持仓 task，该 task 负责调整 rb2104 的仓位到指定的目标仓位 target_pos_near = TargetPosTask(api, ""SHFE.rb2104"") # 创建 rb2105 的目标持仓 task，该 task 负责调整 rb2105 的仓位到指定的目标仓位 target_pos_deferred = TargetPosTask(api, ""SHFE.rb2105"") while True:  api.wait_update()  if api.is_changing(quote_near) or api.is_changing(quote_deferred):   spread = quote_near.last_price - quote_deferred.last_price   print(""当前价差:"", spread)   if spread > 250:    print(""目标持仓: 空近月，多远月"")    # 设置目标持仓为正数表示多头，负数表示空头，0表示空仓    target_pos_near.set_target_volume(-1)    target_pos_deferred.set_target_volume(1)   elif spread < 200:    print(""目标持仓: 空仓"")    target_pos_near.set_target_volume(0)    target_pos_deferred.set_target_volume(0) "
161,n\tqsdk\demo\tutorial\t9,"n\tqsdk\demo\tutorial\t9. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' from tqsdk import TqApi, TqAuth from tqsdk.ta import MA ''' 画图示例: 在主图中画指标线 注意: 画图示例中用到的数据不含有实际意义，请根据自己的实际策略情况进行修改 ''' api = TqApi(web_gui=True, auth=TqAuth(""信易账户"", ""账户密码"")) # web_gui=True, 开启使用 web 界面查看绘图结果的功能 klines = api.get_kline_serial(""SHFE.rb2105"", 5) # 画一次指标线 ma = MA(klines, 30) # 使用 tqsdk 自带指标函数计算均线 klines[""ma_MAIN""] = ma.ma # 在主图中画一根默认颜色（红色）的 ma 指标线 # 由于需要在浏览器中查看绘图结果，因此程序不能退出 while True:  api.wait_update() "
162,n\tqsdk\demo\tutorial\t9,"n\tqsdk\demo\tutorial\t9. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' from tqsdk import TqApi, TqAuth from tqsdk.ta import MA ''' 画图示例: 在附图中画指标线 (将画图代码放在循环中即可使图像随着行情推进而更新) 注意: 画图示例中用到的数据不含有实际意义，请根据自己的实际策略情况进行修改 ''' api = TqApi(web_gui="":9878"", auth=TqAuth(""信易账户"", ""账户密码"")) # web_gui=""[ip]:port"", 指定 web 界面地址的 ip 和 port klines = api.get_kline_serial(""SHFE.rb2105"", 24 * 60 * 60) while True:  # 将画图代码放在循环中即可使图像随着行情推进而更新  ma = MA(klines, 30) # 使用tqsdk自带指标函数计算均线  # 示例1: 在附图中画一根绿色的ma指标线  klines[""ma_B2""] = ma.ma  klines[""ma_B2.board""] = ""B2"" # 设置附图: 可以设置任意字符串,同一字符串表示同一副图  klines[""ma_B2.color""] = ""green"" # 设置为绿色. 以下设置颜色方式都可行: ""green"", ""#00FF00"", ""rgb(0,255,0)"", ""rgba(0,125,0,0.5)""  # 示例2: 在另一个附图画一根比ma小4的宽度为4的紫色指标线  klines[""ma_4""] = ma.ma - 4  klines[""ma_4.board""] = ""MA4"" # 设置为另一个附图  klines[""ma_4.color""] = 0xFF9933CC # 设置为紫色, 或者 ""#9933FF""  klines[""ma_4.width""] = 4 # 设置宽度为4，默认为1  api.wait_update() "
163,n\tqsdk\demo\tutorial\t9,"n\tqsdk\demo\tutorial\t9. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' from tqsdk import TqApi, TqAuth ''' 画图示例: 在主图中画信号线及文字标注 注意: 画图示例中用到的数据不含有实际意义，请根据自己的实际策略情况进行修改 ''' api = TqApi(web_gui=True, auth=TqAuth(""信易账户"", ""账户密码"")) # web_gui=True, 开启使用 web 界面查看绘图结果的功能 klines = api.get_kline_serial(""SHFE.rb2105"", 300) # 示例1: 在主图中最后一根K线上画射线以标注需要的信号 api.draw_line(klines, -1, klines.iloc[-1].close, -1, klines.iloc[-1].high, line_type=""SEG"", color=0xFFFF9900, width=3) # 示例2: 绘制字符串 api.draw_text(klines, ""信号1"", x=-1, y=klines.iloc[-1].high + 5, color=0xFFFF3333) # 示例3: 给主图最后5根K线加一个方框 api.draw_box(klines, x1=-5, y1=klines.iloc[-5][""high""], x2=-1, y2=klines.iloc[-1][""low""], width=1, color=0xFF0000FF,    bg_color=0x7000FF00) # 由于需要在浏览器中查看绘图结果，因此程序不能退出 while True:  api.wait_update() "
164,n\tqsdk\demo\tutorial\t9,"n\tqsdk\demo\tutorial\t9. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' from tqsdk import TqApi, TqAuth ''' 画图示例: 在主图中画线和方框 注意: 画图示例中用到的数据不含有实际意义，请根据自己的实际策略情况进行修改 ''' api = TqApi(web_gui=True, auth=TqAuth(""信易账户"", ""账户密码"")) # web_gui=True, 开启使用 web 界面查看绘图结果的功能 klines = api.get_kline_serial(""SHFE.rb2105"", 60) # 由于需要在浏览器中查看绘图结果，因此程序不能退出 while True:  api.wait_update() # 当有业务信息发生变化时执行  # 当最后 1 根柱子最大最小值价差大于 0.05 时，在主图绘制信号  high = klines.iloc[-1].high  low = klines.iloc[-1].low  if high - low > 0.05:   # 绘制直线, 每一个 id 对应同一条直线   api.draw_line(klines, -1, high, -1, low, id=""box%.0f"" % (klines.iloc[-1].id), color=0xaa662244, width=4)   # 绘制字符串   api.draw_text(klines, ""信号1"", x=-1, y=low, id=""text%.0f"" % (klines.iloc[-1].id), color=0xFFFF3333) "
165,n\tqsdk\demo\tutorial\t9,"n\tqsdk\demo\tutorial\t9. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' from tqsdk import TqApi, TqAuth ''' 画图示例: 在附图中画K线 注意: 画图示例中用到的数据不含有实际意义，请根据自己的实际策略情况进行修改 ''' api = TqApi(web_gui=True, auth=TqAuth(""信易账户"", ""账户密码"")) klines = api.get_kline_serial(""SHFE.rb2104"", 86400) klines2 = api.get_kline_serial(""SHFE.rb2105"", 86400) while True:  # 将画图代码放在循环中即可使图像随着行情推进而更新  # 在附图画出 rb2105 的K线: 需要将open、high、log、close的数据都设置正确  klines[""rb2105.open""] = klines2[""open""]  klines[""rb2105.high""] = klines2[""high""]  klines[""rb2105.low""] = klines2[""low""]  klines[""rb2105.close""] = klines2[""close""]  klines[""rb2105.board""] = ""B2""  api.wait_update() "
166,n\tqsdk\demo\tutorial\t9,"n\tqsdk\demo\tutorial\t9. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'limin' from tqsdk import TqApi, TqAuth from tqsdk.ta import MA ''' 画图示例: 在同一附图中画K线、线段和方框 注意: 画图示例中用到的数据不含有实际意义，请根据自己的实际策略情况进行修改 ''' api = TqApi(web_gui=True, auth=TqAuth(""信易账户"", ""账户密码"")) klines = api.get_kline_serial(""CFFEX.T2103"", 10) klines2 = api.get_kline_serial(""CFFEX.T2012"", 10) # 示例1 : 在附图画出 T2012 的K线: 需要将open、high、log、close的数据都设置正确 klines[""T2012.open""] = klines2[""open""] klines[""T2012.high""] = klines2[""high""] klines[""T2012.low""] = klines2[""low""] klines[""T2012.close""] = klines2[""close""] klines[""T2012.board""] = ""B2"" ma = MA(klines, 30) klines[""ma_MAIN""] = ma.ma # 示例2: 在附图中画线段(默认为红色) api.draw_line(klines, -10, klines2.iloc[-10].low, -3, klines2.iloc[-3].high, id=""my_line"", board=""B2"", line_type=""SEG"",    color=0xFFFF00FF, width=3) # 示例3: 在附图K线上画黄色的方框: 需要设置画在附图时, 将board参数选择到对应的图板即可 api.draw_box(klines, x1=-5, y1=klines2.iloc[-5][""high""], x2=-1, y2=klines2.iloc[-1][""low""], id=""my_box"", board=""B2"",    width=1, color=0xFF0000FF, bg_color=0x70FFFF00) # 由于需要在浏览器中查看绘图结果，因此程序不能退出 while True:  api.wait_update() "
167,n\tqsdk\demo\tutorial\t9,"n\tqsdk\demo\tutorial\t9. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'yanqiong' from tqsdk import TqApi, TqAuth from tqsdk.ta import MACD ''' 画图示例: 在附图中画 macd 指标示例 注意: 画图示例中用到的数据不含有实际意义，请根据自己的实际策略情况进行修改 ''' def calc_macd_klines(klines):  # 计算 macd 指标  macd = MACD(klines, 12, 26, 9)  # 用 K 线图模拟 MACD 指标柱状图  klines[""MACD.open""] = 0.0  klines[""MACD.close""] = macd[""bar""]  klines[""MACD.high""] = klines[""MACD.close""].where(klines[""MACD.close""] > 0, 0)  klines[""MACD.low""] = klines[""MACD.close""].where(klines[""MACD.close""] < 0, 0)  klines[""MACD.board""] = ""MACD""  # 在 board=MACD 上添加 diff、dea 线  klines[""diff""] = macd[""diff""]  klines[""diff.board""] = ""MACD""  klines[""diff.color""] = ""gray""  klines[""dea""] = macd[""dea""]  klines[""dea.board""] = ""MACD""  klines[""dea.color""] = ""rgb(255,128,0)"" api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""), web_gui=True) klines = api.get_kline_serial(""SHFE.rb2105"", 5*60, 200) while True:  calc_macd_klines(klines)  api.wait_update() "
168,n\tqsdk\demo\tutorial\underlying symbo,"n\tqsdk\demo\tutorial\underlying symbo. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = ""Ringo"" from tqsdk import TqApi, TqAuth api = TqApi(auth=TqAuth(""信易账户"", ""账户密码"")) # 订阅螺纹钢主连 quote = api.get_quote(""KQ.m@SHFE.rb"") # 打印现在螺纹钢主连的标的合约 print(quote.underlying_symbol) api.close()"
169,n\tqsdk\demo\tutorial\  init ,n\tqsdk\demo\tutorial\  init . 
170,n\tqsdk\lib\notif,"n\tqsdk\lib\notif. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' from tqsdk.api import TqApi from tqsdk.diff import _get_obj class TqNotify(object):  """"""  用于在同步代码中接受服务器通知  """"""  def __init__(self, api: TqApi) -> None:   """"""   创建 TqNotify 实例   Args:    api (tqsdk.api.TqApi): TqApi 实例   Example::    from tqsdk import TqApi, TqAuth, TqKq, TqNotify    api = TqApi(account=TqKq(), auth=TqAuth(""信易账户"", ""账户密码""))    tqNotify = TqNotify(api) # 构造实例类    while True:     api.wait_update()     # 每次调用返回距离上一次调用 tqNotify.get_notifies() 之后产生的通知列表，没有的话返回 []     notify_list = tqNotify.get_notifies()     for notify in notify_list:      print(notify) # 打印出通知内容      # send_message(notify['content']) 可以发送通知到其他工具   """"""   self._api = api   self._notify = _get_obj(self._api._data, [""notify""])   # 用户未读取过的通知，用 list 类型尽量保证用户读到通知的顺序和进程收到的顺序一致，但是不能完全保证   self._unread_notifies_list = [k for k in self._notify if not k.startswith(""_"")]   # 已经添加到 _unread_notifies 的通知   self._processed_notifies_set = {k for k in self._notify if not k.startswith(""_"")}   self._task = self._api.create_task(self._run())  async def _run(self):   async with self._api.register_update_notify(self._notify) as update_chan:    async for _ in update_chan:     all_notifies = {k for k in self._notify if not k.startswith(""_"")}     notifies = all_notifies - self._processed_notifies_set # 最近更新的通知     self._processed_notifies_set = all_notifies     self._unread_notifies_list.extend([k for k in notifies])  def get_notifies(self):   notifies = [self._notify[n] for n in self._unread_notifies_list]   self._unread_notifies_list = []   return notifies "
171,n\tqsdk\lib\target pos schedule,"n\tqsdk\lib\target pos schedule. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' import asyncio from typing import Optional, Union from pandas import DataFrame from tqsdk.api import TqApi, TqAccount, TqSim, TqKq from tqsdk.channel import TqChan from tqsdk.datetime import _get_trade_timestamp from tqsdk.lib.target_pos_task import TargetPosTask from tqsdk.lib.utils import _check_time_table, _get_deadline_from_interval from tqsdk.objs import Trade class TargetPosScheduler(object):  """"""算法执行引擎，根据设定的目标持仓任务列表，调整指定合约到目标头寸""""""  def __init__(self, api: TqApi, symbol: str, time_table: DataFrame, offset_priority: str = ""今昨,开"",     min_volume: Optional[int] = None, max_volume: Optional[int] = None, trade_chan: Optional[TqChan] = None,     trade_objs_chan: Optional[TqChan] = None, account: Optional[Union[TqAccount, TqKq, TqSim]] = None) -> None:   """"""   创建算法执行引擎实例，根据设定的目标持仓任务列表，调用 TargetPosTask 来调整指定合约到目标头寸。   **注意:**    1. TargetPosScheduler 创建后不会立即不下单或撤单, 它的下单和撤单动作, 是在之后的每次 wait_update 时执行的. 因此, **需保证后续还会调用wait_update()** 。    2. 请勿同时使用 TargetPosScheduler、TargetPosTask、insert_order() 函数, 否则将导致报错或错误下单。    3. `symbol`，`offset_priority`，`min_volume`，`max_volume`，`trade_chan`，`trade_objs_chan`，`account` 这几个参数会直接传给 TargetPosTask，请按照 TargetPosTask 的说明设置参数。   Args:    api (TqApi): TqApi实例，该task依托于指定api下单/撤单    symbol (str): 负责调整的合约代码    time_table (DataFrame): 目标持仓任务列表，每一行表示一项目标持仓任务，其应该包含以下几列：     + interval: 当前这项任务的持续时间长度，单位为秒，经过这么多秒之后，此项任务应该退出，剩余未调整到的目标持仓，会留到下一项任务中      * 注意1：对于最后一项任务，会按照当前项参数，调整到目标持仓后立即退出（时间参数不对最后一项任务起作用）      * 注意2：时间长度可以跨非交易时间段（可以跨小节等待），但是不可以跨交易日     + target_pos: 当前这项任务的目标净持仓手数     + price: 当前这项任务的下单价格模式，此列中非 None 的项，会作为创建 TargetPosTask 实例的 price 参数，支持以下几种参数：      * None: 不下单，表示暂停一段时间      * ""PASSIVE"" : 排队价下单      * ""ACTIVE"": 对价下单      * Callable (direction: str) -> Union[float, int]: 传入函数作为价格参数，函数参数为下单方向，函数返回值是下单价格。如果返回 nan，程序会抛错。    offset_priority (str): [可选]开平仓顺序，昨=平昨仓，今=平今仓，开=开仓，逗号=等待之前操作完成          对于下单指令区分平今/昨的交易所(如上期所)，按照今/昨仓的数量计算是否能平今/昨仓         对于下单指令不区分平今/昨的交易所(如中金所)，按照“先平当日新开仓，再平历史仓”的规则计算是否能平今/昨仓，如果这些交易所设置为""昨开""在有当日新开仓和历史仓仓的情况下，会自动跳过平昨仓进入到下一步          * ""今昨,开"" 表示先平今仓，再平昨仓，等待平仓完成后开仓，对于没有单向大边的品种避免了开仓保证金不足         * ""今昨开"" 表示先平今仓，再平昨仓，并开仓，所有指令同时发出，适合有单向大边的品种         * ""昨开"" 表示先平昨仓，再开仓，禁止平今仓，适合股指这样平今手续费较高的品种         * ""开"" 表示只开仓，不平仓，适合需要进行锁仓操作的品种    min_volume (int): [可选] **大单拆分模式下** 每笔最小下单的手数，默认不启用 **大单拆分模式**    max_volume (int): [可选] **大单拆分模式下** 每笔最大下单的手数，默认不启用 **大单拆分模式**    trade_chan (TqChan): [可选]成交通知channel, 当有成交发生时会将成交手数(多头为正数，空头为负数)发到该channel上    trade_objs_chan (TqChan): [可选]成交对象通知channel, 当有成交发生时会将成交对象发送到该channel上    account (TqAccount/TqKq/TqSim): [可选]指定发送下单指令的账户实例, 多账户模式下，该参数必须指定   Example::    from pandas import DataFrame    from tqsdk import TqApi, TargetPosScheduler    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    time_table = DataFrame([     [25, 10, ""PASSIVE""],     [5, 10, ""ACTIVE""],     [25, 20, ""PASSIVE""],     [5, 20, ""ACTIVE""],    ], columns=['interval', 'target_pos', 'price'])    scheduler = TargetPosScheduler(api, 'SHFE.cu2112', time_table=time_table)    while True:     api.wait_update()     if scheduler.is_finished():      break    print(""打印出 scheduler 全部成交以及成交均价"")    print(scheduler.trades_df)    average_trade_price = sum(scheduler.trades_df['price'] * scheduler.trades_df['volume']) / sum(scheduler.trades_df['volume'])    print(""成交均价:"", average_trade_price)    api.close()   """"""   self._api = api   self._account = api._account._check_valid(account)   # 这些参数直接传给 TargetPosTask，由 TargetPosTask 来检查其合法性   self._symbol = symbol   self._offset_priority = offset_priority   self._min_volume = min_volume   self._max_volume = max_volume   self._trade_chan = trade_chan   self._trade_objs_chan = trade_objs_chan if trade_objs_chan else TqChan(self._api)   self._time_table = _check_time_table(time_table)   self._task = self._api.create_task(self._run())   self._trade_keys = list(Trade(None).keys())   self.trades_df = DataFrame(columns=self._trade_keys) # 所有的 trade 列表   self._trade_recv_task = self._api.create_task(self._trade_recv())  async def _run(self):   """"""负责调整目标持仓的task""""""   quote = await self._api.get_quote(self._symbol)   self._time_table['deadline'] = _get_deadline_from_interval(quote, self._time_table['interval'])   target_pos_task = None   try:    _index = 0 # _index 表示下标    for index, row in self._time_table.iterrows():     if row['price'] is None:      target_pos_task = None     else:      target_pos_task = TargetPosTask(api=self._api, symbol=self._symbol, price=row['price'],              offset_priority=self._offset_priority,              min_volume=self._min_volume, max_volume=self._max_volume,              trade_chan=self._trade_chan,              trade_objs_chan=self._trade_objs_chan,              account=self._account)      target_pos_task.set_target_volume(row['target_pos'])     if _index < self._time_table.shape[0] - 1: # 非最后一项      async for _ in self._api.register_update_notify(quote):       if _get_trade_timestamp(quote.datetime, float('nan')) > row['deadline']:        if target_pos_task:         target_pos_task._task.cancel()         await asyncio.gather(target_pos_task._task, return_exceptions=True)        break     elif target_pos_task: # 最后一项，如果有 target_pos_task 等待持仓调整完成，否则直接退出      position = self._account.get_position(self._symbol)      async for _ in self._api.register_update_notify(position):       if position.pos == row['target_pos']:        break     _index = _index + 1   finally:    if target_pos_task:     target_pos_task._task.cancel()     await asyncio.gather(target_pos_task._task, return_exceptions=True)    await self._trade_objs_chan.close()    await self._trade_recv_task  async def _trade_recv(self):   async for trade in self._trade_objs_chan:    self.trades_df.loc[self.trades_df.shape[0]] = [trade[k] for k in self._trade_keys]  def cancel(self):   """"""   取消当前 TargetPosScheduler 实例，会将该实例已经发出但还是未成交的委托单撤单。   Example::    from pandas import DataFrame    from tqsdk import TqApi, TargetPosScheduler    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    time_table = DataFrame([     [25, 10, ""PASSIVE""],     [5, 10, ""ACTIVE""],     [25, 20, ""PASSIVE""],     [5, 20, ""ACTIVE""],    ], columns=['interval', 'target_pos', 'price'])    scheduler = TargetPosScheduler(api, 'SHFE.cu2112', time_table=time_table)    api.wait_update()    # 运行代码。。。    scheduler.cancel()    while True:     api.wait_update()     if scheduler.is_finished():      break    api.close()   """"""   if not self._task.done():    self._task.cancel()   return  def is_finished(self):   """"""   返回当前 TargetPosScheduler 实例是否已经结束。即此实例不会再发出下单或者撤单的任何动作。   Returns:    bool: 当前 TargetPosScheduler 实例是否已经结束   """"""   return self._task.done() "
172,n\tqsdk\lib\target pos tas,"n\tqsdk\lib\target pos tas. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' import asyncio import time from datetime import datetime from asyncio import gather from inspect import isfunction from typing import Optional, Union, Callable from tqsdk import utils from tqsdk.api import TqApi from tqsdk.backtest import TqBacktest from tqsdk.channel import TqChan from tqsdk.datetime import _is_in_trading_time, _timestamp_nano_to_str from tqsdk.diff import _get_obj from tqsdk.lib.utils import _check_volume_limit, _check_direction, _check_offset, _check_volume, _check_price, \  _check_offset_priority from tqsdk.tradeable import TqAccount, TqKq, TqSim class TargetPosTaskSingleton(type):  """"""  TargetPosTask 需要保证在每个账户下每个合约只有一个 TargetPosTask 实例。  当用户多次调用时，应该保证对于同一账户同一合约使用相同的参数构造，否则抛错。  在修改 TargetPosTask 构造参数时，同时应该修改 TargetPosTaskSingleton.__call__ 方法的参数，要确保其个数、名称、默认值和文档描述一致，\  这些参数才是实际传给 TargetPosTask.__init__ 方法的参数。  同时应该在 TargetPosTask 实例运行结束时释放相应的资源，_instances 需要情况对应的引用。  """"""  # key 为 id(account) + '#' + symbol， 值为 TargetPosTask 实例。  _instances = {}  def __call__(cls, api, symbol, price=""ACTIVE"", offset_priority=""今昨,开"", min_volume=None, max_volume=None,     trade_chan=None, trade_objs_chan=None, account: Optional[Union[TqAccount, TqKq, TqSim]]=None, *args, **kwargs):   target_account = api._account._check_valid(account)   if target_account is None:    raise Exception(f""多账户模式下, 需要指定账户实例 account"")   key = api._account._get_account_key(target_account) + ""#"" + symbol   if key not in TargetPosTaskSingleton._instances:    TargetPosTaskSingleton._instances[key] = super(TargetPosTaskSingleton, cls).__call__(api, symbol, price,                         offset_priority,                         min_volume, max_volume,                         trade_chan,                         trade_objs_chan,                         target_account,                         *args, **kwargs)   else:    instance = TargetPosTaskSingleton._instances[key]    if instance._offset_priority != offset_priority:     raise Exception(""您试图用不同的 offset_priority 参数创建两个 %s 调仓任务, offset_priority参数原为 %s, 现为 %s"" % (      symbol, instance._offset_priority, offset_priority))    if instance._price != price:     raise Exception(""您试图用不同的 price 参数创建两个 %s 调仓任务, price参数原为 %s, 现为 %s"" % (symbol, instance._price, price))    if instance._min_volume != min_volume:     raise Exception(f""您试图用不同的 min_volume 参数创建两个 {symbol} 调仓任务, min_volume 参数原为 {instance._min_volume}, 现为 {min_volume}"")    if instance._max_volume != max_volume:     raise Exception(f""您试图用不同的 max_volume 参数创建两个 {symbol} 调仓任务, max_volume 参数原为 {instance._max_volume}, 现为 {max_volume}"")   return TargetPosTaskSingleton._instances[key] class TargetPosTask(object, metaclass=TargetPosTaskSingleton):  """"""目标持仓 task, 该 task 可以将指定合约调整到目标头寸""""""  def __init__(self, api: TqApi, symbol: str, price: Union[str, Callable[[str], Union[float, int]]] = ""ACTIVE"",     offset_priority: str = ""今昨,开"", min_volume: Optional[int] = None, max_volume: Optional[int] = None,     trade_chan: Optional[TqChan] = None, trade_objs_chan: Optional[TqChan] = None,     account: Optional[Union[TqAccount, TqKq, TqSim]] = None) -> None:   """"""   创建目标持仓task实例，负责调整归属于该task的持仓 **(默认为整个账户的该合约净持仓)**.   **注意:**    1. TargetPosTask 在 set_target_volume 时并不下单或撤单, 它的下单和撤单动作, 是在之后的每次 wait_update 时执行的. 因此, **需保证 set_target_volume 后还会继续调用wait_update()** 。    2. 请勿在使用 TargetPosTask 的同时使用 insert_order() 函数, 否则将导致 TargetPosTask 报错或错误下单。    3. TargetPosTask 如果同时设置 min_volume（每笔最小下单手数），max_volume（每笔最大下单的手数）两个参数，表示采用 **大单拆分模式** 下单。     在 **大单拆分模式** 下，每次下单的手数为随机生成的正整数，值介于 min_volume、max_volume 之间。     具体说明：调用 set_target_volume 后，首先会根据目标持仓手数、开平仓顺序计算出，需要平今、平昨、开仓的目标下单手数及顺序。     + 如果在调整持仓的目标下单手数小于 max_volume，则直接以目标下单手数下单。     + 如果在调整持仓的目标下单手数大于等于 max_volume，则会以 min_volume、max_volume 之间的随机手数下一笔委托单，手数全部成交后，会接着处理剩余的手数；\     继续以随机手数下一笔委托单，全部成交后，继续处理剩余的手数，直至剩余手数小于 max_volume 时，直接以剩余手数下单。     当使用大单拆分模式下单时，必须同时填写 min_volume、max_volume，且需要满足 max_volume >= min_volume > 0。   Args:    api (TqApi): TqApi实例，该task依托于指定api下单/撤单    symbol (str): 负责调整的合约代码    price (str / Callable): [可选]下单方式, 默认为 ""ACTIVE""。     * ""ACTIVE""：对价下单，在持仓调整过程中，若下单方向为买，对价为卖一价；若下单方向为卖，对价为买一价。     * ""PASSIVE""：排队价下单，在持仓调整过程中，若下单方向为买，对价为买一价；若下单方向为卖，对价为卖一价。     * Callable[[str], Union[float, int]]: 函数参数为下单方向，函数返回值是下单价格。如果返回 nan，程序会抛错。    offset_priority (str): [可选]开平仓顺序，昨=平昨仓，今=平今仓，开=开仓，逗号=等待之前操作完成          对于下单指令区分平今/昨的交易所(如上期所)，按照今/昨仓的数量计算是否能平今/昨仓         对于下单指令不区分平今/昨的交易所(如中金所)，按照“先平当日新开仓，再平历史仓”的规则计算是否能平今/昨仓，如果这些交易所设置为""昨开""在有当日新开仓和历史仓仓的情况下，会自动跳过平昨仓进入到下一步          * ""今昨,开"" 表示先平今仓，再平昨仓，等待平仓完成后开仓，对于没有单向大边的品种避免了开仓保证金不足         * ""今昨开"" 表示先平今仓，再平昨仓，并开仓，所有指令同时发出，适合有单向大边的品种         * ""昨开"" 表示先平昨仓，再开仓，禁止平今仓，适合股指这样平今手续费较高的品种         * ""开"" 表示只开仓，不平仓，适合需要进行锁仓操作的品种    min_volume (int): [可选] **大单拆分模式下** 每笔最小下单的手数，默认不启用 **大单拆分模式**    max_volume (int): [可选] **大单拆分模式下** 每笔最大下单的手数，默认不启用 **大单拆分模式**    trade_chan (TqChan): [可选]成交通知channel, 当有成交发生时会将成交手数(多头为正数，空头为负数)发到该channel上    trade_objs_chan (TqChan): [可选]成交对象通知channel, 当有成交发生时会将成交对象发送到该channel上    account (TqAccount/TqKq/TqSim): [可选]指定发送下单指令的账户实例, 多账户模式下，该参数必须指定   **注意**   当 price 参数为函数类型时，该函数应该返回一个有效的价格值，应该避免返回 nan。以下为 price 参数是函数类型时的示例。   Example1::    # ... 用户代码 ...    quote = api.get_quote(""SHFE.cu2012"")    def get_price(direction):     # 在 BUY 时使用买一价加一档价格，SELL 时使用卖一价减一档价格     if direction == ""BUY"":      price = quote.bid_price1 + quote.price_tick     else:      price = quote.ask_price1 - quote.price_tick     # 如果 price 价格是 nan，使用最新价报单     if price != price:      price = quote.last_price     return price    target_pos = TargetPosTask(api, ""SHFE.cu2012"", price=get_price)    # ... 用户代码 ...   Example2::    # ... 用户代码 ...    quote_list = api.get_quote_list([""SHFE.cu2012"",""SHFE.au2012""])    def get_price_by_quote(quote):     def get_price(direction):      # 在 BUY 时使用涨停价，SELL 时使用跌停价      if direction == ""BUY"":       price = quote[""upper_limit""]      else:       price = quote.lower_limit      # 如果 price 价格是 nan，使用最新价报单      if price != price:       price = quote.last_price      return price     return get_price    for quote in quote_list:     target_pos_active_dict[quote.instrument_id] = TargetPosTask(api, quote.instrument_id, price=get_price_by_quote(quote))    # ... 用户代码 ...   Example3::    # 大单拆分模式用法示例    from tqsdk import TqApi, TqAuth, TargetPosTask    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    position = api.get_position('SHFE.rb2106')    # 同时设置 min_volume、max_volume 两个参数，表示使用大单拆分模式    t = TargetPosTask(api, 'SHFE.rb2106', min_volume=2, max_volume=10)    t.set_target_volume(50)    while True:     api.wait_update()     if position.pos_long == 50:      break    api.close()    # 说明：    # 以上代码使用 TqSim 交易，开始时用户没有 SHFE.cu2012 合约的任何持仓，那么在 t.set_target_volume(50) 之后应该开多仓 50 手    # 根据用户参数，下单使用大单拆分模式，每次下单手数在 2～10 之间，打印出的成交通知可能是这样的：    # 2021-03-15 11:29:48 -  INFO - 模拟交易成交记录    # 2021-03-15 11:29:48 -  INFO - 时间: 2021-03-15 11:29:47.516138, 合约: SHFE.rb2106, 开平: OPEN, 方向: BUY, 手数: 7, 价格: 4687.000,手续费: 32.94    # 2021-03-15 11:29:48 -  INFO - 时间: 2021-03-15 11:29:47.519699, 合约: SHFE.rb2106, 开平: OPEN, 方向: BUY, 手数: 8, 价格: 4687.000,手续费: 37.64    # 2021-03-15 11:29:48 -  INFO - 时间: 2021-03-15 11:29:47.522848, 合约: SHFE.rb2106, 开平: OPEN, 方向: BUY, 手数: 10, 价格: 4687.000,手续费: 47.05    # 2021-03-15 11:29:48 -  INFO - 时间: 2021-03-15 11:29:47.525617, 合约: SHFE.rb2106, 开平: OPEN, 方向: BUY, 手数: 8, 价格: 4687.000,手续费: 37.64    # 2021-03-15 11:29:48 -  INFO - 时间: 2021-03-15 11:29:47.528151, 合约: SHFE.rb2106, 开平: OPEN, 方向: BUY, 手数: 7, 价格: 4687.000,手续费: 32.94    # 2021-03-15 11:29:48 -  INFO - 时间: 2021-03-15 11:29:47.530930, 合约: SHFE.rb2106, 开平: OPEN, 方向: BUY, 手数: 7, 价格: 4687.000,手续费: 32.94    # 2021-03-15 11:29:48 -  INFO - 时间: 2021-03-15 11:29:47.533515, 合约: SHFE.rb2106, 开平: OPEN, 方向: BUY, 手数: 3, 价格: 4687.000,手续费: 14.12   """"""   if symbol.startswith(""CZCE.CJ""):    raise Exception(""红枣期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 4 手，这些函数还未支持该规则!"")   if symbol.startswith(""CZCE.ZC""):    raise Exception(""动力煤期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 4 手，这些函数还未支持该规则!"")   if symbol.startswith(""CZCE.WH""):    raise Exception(""强麦期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 10 手，这些函数还未支持该规则!"")   if symbol.startswith(""CZCE.PM""):    raise Exception(""普麦期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 10 手，这些函数还未支持该规则!"")   if symbol.startswith(""CZCE.RI""):    raise Exception(""早籼稻期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 10 手，这些函数还未支持该规则!"")   if symbol.startswith(""CZCE.JR""):    raise Exception(""粳稻期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 10 手，这些函数还未支持该规则!"")   if symbol.startswith(""CZCE.LR""):    raise Exception(""晚籼稻期货不支持创建 targetpostask、twap、vwap 任务，交易所规定该品种最小开仓手数为大于等于 10 手，这些函数还未支持该规则!"")   super(TargetPosTask, self).__init__()   self._api = api   self._account = api._account._check_valid(account)   self._symbol = symbol   self._exchange = symbol.split(""."")[0]   self._offset_priority = _check_offset_priority(offset_priority)   self._min_volume, self._max_volume = _check_volume_limit(min_volume, max_volume)   self._price = _check_price(price)   self._pos = self._account.get_position(self._symbol)   self._pos_chan = TqChan(self._api, last_only=True)   self._trade_chan = trade_chan   self._trade_objs_chan = trade_objs_chan   self._task = self._api.create_task(self._target_pos_task())   self._time_update_task = self._api.create_task(self._update_time_from_md()) # 监听行情更新并记录当时本地时间的task   self._local_time_record = time.time() - 0.005 # 更新最新行情时间时的本地时间   self._local_time_record_update_chan = TqChan(self._api, last_only=True) # 监听 self._local_time_record 更新  def set_target_volume(self, volume: int) -> None:   """"""   设置目标持仓手数   Args:    volume (int): 目标持仓手数，正数表示多头，负数表示空头，0表示空仓   Example1::    # 设置 rb1810 持仓为多头5手    from tqsdk import TqApi, TqAuth, TargetPosTask    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    target_pos = TargetPosTask(api, ""SHFE.rb1810"")    target_pos.set_target_volume(5)    while True:     # 需在 set_target_volume 后调用wait_update()以发出指令     api.wait_update()   Example2::    # 多账户模式下使用 TargetPosTask    from tqsdk import TqApi, TqMultiAccount, TqAuth, TargetPosTask    account1 = TqAccount(""H海通期货"", ""123456"", ""123456"")    account2 = TqAccount(""H宏源期货"", ""654321"", ""123456"")    api = TqApi(TqMultiAccount([account1, account2]), auth=TqAuth(""信易账户"", ""账户密码""))    symbol1 = ""DCE.m2105""    symbol2 = ""DCE.i2101""    # 多账户模式下, 调仓工具需要指定账户实例    target_pos1 = TargetPosTask(api, symbol1, account=account1)    target_pos2 = TargetPosTask(api, symbol2, account=account2)    target_pos1.set_target_volume(30)    target_pos2.set_target_volume(80)    while True:     api.wait_update()    api.close()   """"""   if self._task.done():    raise Exception(""已经结束的 TargetPosTask 实例不可以再设置手数。"")   self._pos_chan.send_nowait(int(volume))  def _get_order(self, offset, vol, pending_frozen):   """"""   根据指定的offset和预期下单手数vol, 返回符合要求的委托单最大报单手数   :param offset: ""昨"" / ""今"" / ""开""   :param vol: int, <0表示SELL, >0表示BUY   :return: order_offset: ""CLOSE""/""CLOSETODAY""/""OPEN""; order_dir: ""BUY""/""SELL""; ""order_volume"": >=0, 报单手数   """"""   if vol > 0: # 买单(增加净持仓)    order_dir = ""BUY""    pos_all = self._pos.pos_short   else: # 卖单    order_dir = ""SELL""    pos_all = self._pos.pos_long   if offset == ""昨"":    order_offset = ""CLOSE""    if self._exchange == ""SHFE"" or self._exchange == ""INE"":     if vol > 0:      pos_all = self._pos.pos_short_his     else:      pos_all = self._pos.pos_long_his     frozen_volume = sum([order.volume_left for order in self._pos.orders.values() if          not order.is_dead and order.offset == order_offset and order.direction == order_dir])    else:     frozen_volume = pending_frozen + sum([order.volume_left for order in self._pos.orders.values() if              not order.is_dead and order.offset != ""OPEN"" and order.direction == order_dir])     # 判断是否有未冻结的今仓手数: 若有则不平昨仓     if (self._pos.pos_short_today if vol > 0 else self._pos.pos_long_today) - frozen_volume > 0:      pos_all = frozen_volume    order_volume = min(abs(vol), max(0, pos_all - frozen_volume))   elif offset == ""今"":    if self._exchange == ""SHFE"" or self._exchange == ""INE"":     order_offset = ""CLOSETODAY""     if vol > 0:      pos_all = self._pos.pos_short_today     else:      pos_all = self._pos.pos_long_today     frozen_volume = sum([order.volume_left for order in self._pos.orders.values() if          not order.is_dead and order.offset == order_offset and order.direction == order_dir])    else:     order_offset = ""CLOSE""     frozen_volume = pending_frozen + sum([order.volume_left for order in self._pos.orders.values() if              not order.is_dead and order.offset != ""OPEN"" and order.direction == order_dir])     pos_all = self._pos.pos_short_today if vol > 0 else self._pos.pos_long_today    order_volume = min(abs(vol), max(0, pos_all - frozen_volume))   elif offset == ""开"":    order_offset = ""OPEN""    order_volume = abs(vol)   else:    order_offset = """"    order_volume = 0   return order_offset, order_dir, order_volume  async def _update_time_from_md(self):   """"""监听行情更新并记录当时本地时间的task""""""   try:    chan = TqChan(self._api, last_only=True)    self._quote = await self._api.get_quote(self._symbol)    self._api.register_update_notify(self._quote, chan) # quote有更新时: 更新记录的时间    if isinstance(self._api._backtest, TqBacktest):     # 回测情况下，在收到回测时间有更新的时候，也需要更新记录的时间     self._api.register_update_notify(_get_obj(self._api._data, [""_tqsdk_backtest""]), chan)    async for _ in chan:     self._local_time_record = time.time() - 0.005 # 更新最新行情时间时的本地时间     self._local_time_record_update_chan.send_nowait(True) # 通知记录的时间有更新   finally:    await chan.close()  async def _target_pos_task(self):   """"""负责调整目标持仓的task""""""   all_tasks = []   try:    self._quote = await self._api.get_quote(self._symbol)    async for target_pos in self._pos_chan:     # lib 中对于时间判断的方案:     # 如果当前时间（模拟交易所时间）不在交易时间段内，则：等待直到行情更新     # 行情更新（即下一交易时段开始）后：获取target_pos最新的目标仓位, 开始调整仓位     # 如果不在可交易时间段内（回测时用 backtest 下发的时间判断，实盘使用 quote 行情判断）: 等待更新     while True:      if isinstance(self._api._backtest, TqBacktest):       cur_timestamp = self._api._data.get(""_tqsdk_backtest"", {}).get(""current_dt"", float(""nan""))       cur_dt = _timestamp_nano_to_str(cur_timestamp)       time_record = float(""nan"")      else:       cur_dt = self._quote[""datetime""]       time_record = self._local_time_record      if _is_in_trading_time(self._quote, cur_dt, time_record):       break      await self._local_time_record_update_chan.recv()     target_pos = self._pos_chan.recv_latest(target_pos) # 获取最后一个target_pos目标仓位     # 确定调仓增减方向     delta_volume = target_pos - self._pos.pos     pending_forzen = 0     for each_priority in self._offset_priority + "","": # 按不同模式的优先级顺序报出不同的offset单，股指(“昨开”)平昨优先从不平今就先报平昨，原油平今优先(""今昨开"")就报平今      if each_priority == "","":       await gather(*[each._task for each in all_tasks])       pending_forzen = 0       all_tasks = []       continue      order_offset, order_dir, order_volume = self._get_order(each_priority, delta_volume, pending_forzen)      if order_volume == 0: # 如果没有则直接到下一种offset       continue      elif order_offset != ""OPEN"":       pending_forzen += order_volume      order_task = InsertOrderUntilAllTradedTask(self._api, self._symbol, order_dir, offset=order_offset,                volume=order_volume, min_volume=self._min_volume,                max_volume=self._max_volume, price=self._price,                trade_chan=self._trade_chan,                trade_objs_chan=self._trade_objs_chan,                account=self._account)      all_tasks.append(order_task)      delta_volume -= order_volume if order_dir == ""BUY"" else -order_volume   finally:    # 执行 task.cancel() 时, 删除掉该 symbol 对应的 TargetPosTask 实例    # self._account 类型为 TqSim/TqKq/TqAccount，都包括 _account_key 变量    TargetPosTaskSingleton._instances.pop(self._account._account_key + ""#"" + self._symbol, None)    await self._pos_chan.close()    self._time_update_task.cancel()    await asyncio.gather(*([t._task for t in all_tasks] + [self._time_update_task]), return_exceptions=True)  def cancel(self):   """"""   取消当前 TargetPosTask 实例，会将该实例已经发出但还是未成交的委托单撤单，并且如果后续调用此实例的 set_target_volume 函数会报错。   任何时刻，每个账户下一个合约只能有一个 TargetPosTask 实例，并且其构造参数不能修改。   如果对于同一个合约要构造不同参数的 TargetPosTask 实例，需要调用 cancel 方法销毁，才能创建新的 TargetPosTask 实例   Example1::    from datetime import datetime, time    from tqsdk import TqApi, TargetPosTask    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SHFE.rb2110"")    target_pos_passive = TargetPosTask(api, ""SHFE.rb2110"", price=""PASSIVE"")    while datetime.strptime(quote.datetime, ""%Y-%m-%d %H:%M:%S.%f"").time() < time(14, 50):     api.wait_update()     # ... 策略代码 ...    # 取消 TargetPosTask 实例    target_pos_passive.cancel()    while not target_pos_passive.is_finished(): # 此循环等待 target_pos_passive 处理 cancel 结束     api.wait_update() # 调用wait_update()，会对已经发出但还是未成交的委托单撤单    # 创建新的 TargetPosTask 实例    target_pos_active = TargetPosTask(api, ""SHFE.rb2110"", price=""ACTIVE"")    target_pos_active.set_target_volume(0) # 平所有仓位    while True:     api.wait_update()     # ... 策略代码 ...    api.close()   """"""   self._task.cancel()  def is_finished(self) -> bool:   """"""   返回当前 TargetPosTask 实例是否已经结束。即如果后续调用此实例的 set_target_volume 函数会报错，此实例不会再下单或者撤单。   Returns:    bool: 当前 TargetPosTask 实例是否已经结束   """"""   return self._task.done() class InsertOrderUntilAllTradedTask(object):  """"""追价下单task, 该task会在行情变化后自动撤单重下，直到全部成交  （注：此类主要在tqsdk内部使用，并非简单用法，不建议用户使用）""""""  def __init__(self, api, symbol, direction, offset, volume, min_volume: Optional[int] = None,     max_volume: Optional[int] = None, price: Union[str, Callable[[str], Union[float, int]]] = ""ACTIVE"",     trade_chan=None, trade_objs_chan=None, account: Optional[Union[TqAccount, TqKq, TqSim]] = None):   """"""   创建追价下单task实例   Args:    api (TqApi): TqApi实例，该task依托于指定api下单/撤单    symbol (str): 拟下单的合约symbol, 格式为 交易所代码.合约代码, 例如 ""SHFE.cu1801""    direction (str): ""BUY"" 或 ""SELL""    offset (str): ""OPEN"", ""CLOSE"" 或 ""CLOSETODAY""    volume (int): 需要下单的手数    min_volume (int): [可选] **大单拆分模式下** 每笔最小下单的手数，默认不启用 **大单拆分模式**    max_volume (int): [可选] **大单拆分模式下** 每笔最大下单的手数，默认不启用 **大单拆分模式**    price (str / Callable): [可选]下单方式, 默认为 ""ACTIVE""。     * ""ACTIVE""：对价下单，在持仓调整过程中，若下单方向为买，对价为卖一价；若下单方向为卖，对价为买一价。     * ""PASSIVE""：对价下单，在持仓调整过程中，若下单方向为买，对价为买一价；若下单方向为卖，对价为卖一价。     * Callable[[str], Union[float, int]]: 函数参数为下单方向，函数返回值是下单价格。如果返回 nan，程序会抛错。    trade_chan (TqChan): [可选]成交通知channel, 当有成交发生时会将成交手数(多头为正数，空头为负数)发到该channel上    trade_objs_chan (TqChan): [可选]成交对象通知channel, 当有成交发生时会将成交对象发送到该channel上    account (TqAccount/TqKq/TqSim): [可选]指定发送下单指令的账户实例, 多账户模式下，该参数必须指定   """"""   self._api = api   self._account = account   self._symbol = symbol   self._direction = _check_direction(direction)   self._offset = _check_offset(offset)   self._volume = _check_volume(volume)   self._min_volume, self._max_volume = _check_volume_limit(min_volume, max_volume)   self._price = _check_price(price)   self._trade_chan = trade_chan   self._trade_objs_chan = trade_objs_chan   self._task = self._api.create_task(self._run())  async def _run(self):   """"""负责追价下单的task""""""   self._quote = await self._api.get_quote(self._symbol)   while self._volume != 0:    limit_price = self._get_price(self._direction)    if limit_price != limit_price:     raise Exception(""设置价格函数返回 nan，无法处理。请检查后重试。"")    # 当前下单手数    if self._min_volume and self._max_volume and self._volume >= self._max_volume:     this_volume = utils.RD.randint(self._min_volume, self._max_volume)    else:     this_volume = self._volume    insert_order_task = InsertOrderTask(self._api, self._symbol, self._direction, self._offset,             this_volume, limit_price=limit_price, trade_chan=self._trade_chan,             trade_objs_chan=self._trade_objs_chan, account=self._account)    order = await insert_order_task._order_chan.recv()    check_chan = TqChan(self._api, last_only=True)    check_task = self._api.create_task(self._check_price(check_chan, limit_price, order['order_id']))    try:     # 当父 task 被 cancel，子 task 如果正在执行，也会捕获 CancelError     # 添加 asyncio.shield 后，如果父 task 被 cancel，asyncio.shield 也会被 cancel，但是子 task 不会收到 CancelError     # 这里需要 asyncio.shield，是因为 insert_order_task._task 预期不会被 cancel， 应该等待到 order 状态是 FINISHED 才返回     await asyncio.shield(insert_order_task._task)     order = insert_order_task._order_chan.recv_latest(order)     self._volume -= (this_volume - order['volume_left'])     if order['volume_left'] != 0 and not check_task.done():      raise Exception(""遇到错单: %s %s %s %d手 %f %s"" % (       self._symbol, self._direction, self._offset, this_volume, limit_price, order['last_msg']))    finally:     if self._api.get_order(order['order_id'], account=self._account).status == ""ALIVE"":      # 当 task 被 cancel 时，主动撤掉未成交的挂单      self._api.cancel_order(order['order_id'], account=self._account)     await check_chan.close()     await check_task     # 在每次退出时，都等到 insert_order_task 执行完，此时 order 状态一定是 FINISHED；self._trade_chan 也一定会收到全部的成交手数     try:      # 当用户调用 api.close(), 会主动 cancel 所有由 api 创建的 task，包括 TargetPosTask._target_pos_task，      # 此时，insert_order_task._task 如果有未完成委托单，会永远等待下去（因为网络连接已经断开），所以这里增加超时机制。      await asyncio.wait_for(insert_order_task._task, timeout=30)     except asyncio.TimeoutError:      raise Exception(f""InsertOrderTask 执行超时，30s 内报单未执行完。此错误产生可能的原因：""          f""可能是用户调用了 api.close() 之后，已经创建的 InsertOrderTask 无法正常结束。"")  def _get_price(self, direction):   """"""根据最新行情和下单方式计算出最优的下单价格""""""   if self._price not in ('ACTIVE', 'PASSIVE'):    assert isfunction(self._price)    return self._price(direction)   # 主动买的价格序列(优先判断卖价，如果没有则用买价)   price_list = [self._quote.ask_price1, self._quote.bid_price1]   if direction == ""SELL"":    price_list.reverse()   if self._price == ""PASSIVE"":    price_list.reverse()   limit_price = price_list[0]   if limit_price != limit_price:    limit_price = price_list[1]   if limit_price != limit_price:    limit_price = self._quote.last_price   if limit_price != limit_price:    limit_price = self._quote.pre_close   return limit_price  async def _check_price(self, update_chan, order_price, order_id):   """"""判断价格是否变化的task""""""   async with self._api.register_update_notify(chan=update_chan):    async for _ in update_chan:     new_price = self._get_price(self._direction)     if (self._direction == ""BUY"" and new_price > order_price) or (       self._direction == ""SELL"" and new_price < order_price):      self._api.cancel_order(order_id, account=self._account)      break class InsertOrderTask(object):  """"""下单task （注：此类主要在tqsdk内部使用，并非简单用法，不建议用户使用）""""""  def __init__(self, api, symbol, direction, offset, volume, limit_price=None, order_chan=None, trade_chan=None,     trade_objs_chan=None, account: Optional[Union[TqAccount, TqKq, TqSim]] = None):   """"""   创建下单task实例   Args:    api (TqApi): TqApi实例，该task依托于指定api下单/撤单    symbol (str): 拟下单的合约symbol, 格式为 交易所代码.合约代码, 例如 ""SHFE.cu1801""    direction (str): ""BUY"" 或 ""SELL""    offset (str): ""OPEN"", ""CLOSE"" 或 ""CLOSETODAY""    volume (int): 需要下单的手数    limit_price (float): [可选]下单价格, 默认市价单    order_chan (TqChan): [可选]委托单通知channel, 当委托单状态发生时会将委托单信息发到该channel上    trade_chan (TqChan): [可选]成交通知channel, 当有成交发生时会将成交手数(多头为正数，空头为负数)发到该channel上    trade_objs_chan (TqChan): [可选]成交对象通知channel, 当有成交发生时会将成交对象发送到该channel上    account (TqAccount/TqKq/TqSim): [可选]指定发送下单指令的账户实例, 多账户模式下，该参数必须指定   """"""   self._api = api   self._account = account   self._symbol = symbol   self._direction = _check_direction(direction)   self._offset = _check_offset(offset)   self._volume = _check_volume(volume)   self._offset = offset   self._volume = int(volume)   self._limit_price = float(limit_price) if limit_price is not None else None   self._order_chan = order_chan if order_chan is not None else TqChan(self._api)   self._trade_chan = trade_chan   self._trade_objs_chan = trade_objs_chan   self._task = self._api.create_task(self._run())  async def _run(self):   """"""负责下单的task""""""   order_id = utils._generate_uuid(""PYSDK_target"")   order = self._api.insert_order(self._symbol, self._direction, self._offset, self._volume, self._limit_price,          order_id=order_id, account=self._account)   last_order = order.copy() # 保存当前 order 的状态   last_left = self._volume   all_trades_id = set() # 记录所有的 trade_id   async with self._api.register_update_notify() as update_chan:    await self._order_chan.send({k: v for k, v in last_order.items() if not k.startswith(""_"")}) # 将副本的数据及所有权转移    while order.status != ""FINISHED"" or (order.volume_orign - order.volume_left) != sum(      [trade.volume for trade in order.trade_records.values()]):     await update_chan.recv()     if order.volume_left != last_left:      vol = last_left - order.volume_left      last_left = order.volume_left      if self._trade_chan:       await self._trade_chan.send(vol if order.direction == ""BUY"" else -vol)     if self._trade_objs_chan:      # 当前用户需要接受 trade_obj，才会运行以下代码      rest_trades_id = set(order.trade_records) - all_trades_id      for trade_id in rest_trades_id:       # 新收到的 trade 发送到 self._trade_objs_chan       await self._trade_objs_chan.send({k: v for k, v in order.trade_records[trade_id].items() if not k.startswith(""_"")})       all_trades_id.add(trade_id)     if order != last_order:      last_order = order.copy()      await self._order_chan.send({k: v for k, v in last_order.items() if not k.startswith(""_"")}) "
173,n\tqsdk\lib\util,"n\tqsdk\lib\util. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' import numpy as np from pandas import DataFrame from tqsdk.datetime import _get_trading_timestamp, _get_trade_timestamp from tqsdk.rangeset import _rangeset_head, _rangeset_slice, _rangeset_length """""" 检查参数类型 """""" from inspect import isfunction def _check_volume_limit(min_volume, max_volume):  if min_volume is not None and min_volume <= 0:   raise Exception(""最小下单手数(min_volume) %s 错误, 请检查 min_volume 是否填写正确"" % min_volume)  if max_volume is not None and max_volume <= 0:   raise Exception(""最大下单手数(max_volume) %s 错误, 请检查 max_volume 是否填写正确"" % max_volume)  if (min_volume is None and max_volume) or (max_volume is None and min_volume):   raise Exception(""最小下单手数(min_volume) %s 和 最大下单手数(max_volume) %s 必须用时填写"" % (min_volume, max_volume))  if min_volume and max_volume and min_volume > max_volume:   raise Exception(""最小下单手数(min_volume) %s ，最大下单手数(max_volume) %s 错误, 请检查 min_volume, max_volume 是否填写正确"" % (    min_volume, max_volume))  return int(min_volume) if min_volume else None, int(max_volume) if max_volume else None def _check_direction(direction):  if direction not in (""BUY"", ""SELL""):   raise Exception(""下单方向(direction) %s 错误, 请检查 direction 参数是否填写正确"" % direction)  return direction def _check_offset(offset):  if offset not in (""OPEN"", ""CLOSE"", ""CLOSETODAY""):   raise Exception(""开平标志(offset) %s 错误, 请检查 offset 是否填写正确"" % offset)  return offset def _check_offset_priority(offset_priority):  if len(offset_priority.replace("","", """").replace(""今"", """", 1).replace(""昨"", """", 1).replace(""开"", """", 1)) > 0:   raise Exception(""开平仓顺序(offset_priority) %s 错误, 请检查 offset_priority 参数是否填写正确"" % offset_priority)  return offset_priority def _check_volume(volume):  _volume = int(volume)  if _volume <= 0:   raise Exception(""下单手数(volume) %s 错误, 请检查 volume 是否填写正确"" % volume)  return _volume def _check_price(price):  if price in (""ACTIVE"", ""PASSIVE"") or isfunction(price):   return price  else:   raise Exception(""下单方式(price) %s 错误, 请检查 price 参数是否填写正确"" % price) def _check_time_table(time_table: DataFrame):  if not isinstance(time_table, DataFrame):   raise Exception(f""time_table 参数应该是 pandas.DataFrame 类型"")  need_columns = {'price', 'target_pos', 'interval'} - set(time_table.columns)  if need_columns:   raise Exception(f""缺少必要的列 {need_columns}"")  if time_table.shape[0] > 0:   if time_table['interval'].isnull().values.any() or np.where(time_table['interval'] < 0, True, False).any():    raise Exception(f""interval 列必须为正数，请检查参数 {time_table['interval']}"")   if time_table['target_pos'].isnull().values.any() or not np.issubdtype(time_table['target_pos'].dtype, np.integer):    raise Exception(f""target_pos 列必须为整数，请检查参数 {time_table['target_pos']}"")   if not (np.isin(time_table['price'], ('PASSIVE', 'ACTIVE', None)) | time_table['price'].apply(isfunction)).all():    raise Exception(f""price 列必须为 ('PASSIVE', 'ACTIVE', None, Callable) 之一，请检查参数 {time_table['price']}"")  return time_table def _get_deadline_from_interval(quote, interval):  """"""将 interval （持续长度 seconds）列转换为 deadline（结束时间 nano_timestamp）""""""  # 当前交易日完整的交易时间段  trading_timestamp = _get_trading_timestamp(quote, quote.datetime)  trading_timestamp_nano_range = trading_timestamp['night'] + trading_timestamp['day'] # 当前交易日完整的交易时间段  # 当前时间 行情时间  current_timestamp_nano = _get_trade_timestamp(quote.datetime, float('nan'))  if not trading_timestamp_nano_range[0][0] <= current_timestamp_nano < trading_timestamp_nano_range[-1][1]:   raise Exception(""当前时间不在指定的交易时间段内"")  deadline = []  for index, value in interval.items():   r = _rangeset_head(_rangeset_slice(trading_timestamp_nano_range, current_timestamp_nano), int(value * 1e9))   if _rangeset_length(r) < int(value * 1e9):    raise Exception(""指定时间段超出当前交易日"")   deadline.append(r[-1][1])   current_timestamp_nano = r[-1][1]  return deadline "
174,n\tqsdk\lib\  init ,"n\tqsdk\lib\  init . #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' from tqsdk.lib.target_pos_task import TargetPosTask, InsertOrderUntilAllTradedTask, InsertOrderTask from tqsdk.lib.target_pos_scheduler import TargetPosScheduler from tqsdk.lib.notify import TqNotify "
175,n\tqsdk\sim\trad,"n\tqsdk\sim\trad. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' import math from tqsdk.sim.trade_base import SimTradeBase from tqsdk.sim.utils import _get_option_margin, _get_premium, _get_close_profit, _get_commission, _get_future_margin class SimTrade(SimTradeBase):  """"""  天勤模拟交易账户，期货及商品期权  """"""  def _generate_account(self, init_balance):   return {    ""currency"": ""CNY"",    ""pre_balance"": init_balance,    ""static_balance"": init_balance,    ""balance"": init_balance,    ""available"": init_balance,    ""float_profit"": 0.0,    ""position_profit"": 0.0, # 期权没有持仓盈亏    ""close_profit"": 0.0,    ""frozen_margin"": 0.0,    ""margin"": 0.0,    ""frozen_commission"": 0.0,    ""commission"": 0.0,    ""frozen_premium"": 0.0,    ""premium"": 0.0,    ""deposit"": 0.0,    ""withdraw"": 0.0,    ""risk_ratio"": 0.0,    ""market_value"": 0.0,    ""ctp_balance"": float(""nan""),    ""ctp_available"": float(""nan"")   }  def _generate_position(self, symbol, quote, underlying_quote) -> dict:   return {    ""exchange_id"": symbol.split(""."", maxsplit=1)[0],    ""instrument_id"": symbol.split(""."", maxsplit=1)[1],    ""pos_long_his"": 0,    ""pos_long_today"": 0,    ""pos_short_his"": 0,    ""pos_short_today"": 0,    ""volume_long_today"": 0,    ""volume_long_his"": 0,    ""volume_long"": 0,    ""volume_long_frozen_today"": 0,    ""volume_long_frozen_his"": 0,    ""volume_long_frozen"": 0,    ""volume_short_today"": 0,    ""volume_short_his"": 0,    ""volume_short"": 0,    ""volume_short_frozen_today"": 0,    ""volume_short_frozen_his"": 0,    ""volume_short_frozen"": 0,    ""open_price_long"": float(""nan""),    ""open_price_short"": float(""nan""),    ""open_cost_long"": 0.0,    ""open_cost_short"": 0.0,    ""position_price_long"": float(""nan""),    ""position_price_short"": float(""nan""),    ""position_cost_long"": 0.0,    ""position_cost_short"": 0.0,    ""float_profit_long"": 0.0,    ""float_profit_short"": 0.0,    ""float_profit"": 0.0,    ""position_profit_long"": 0.0,    ""position_profit_short"": 0.0,    ""position_profit"": 0.0,    ""margin_long"": 0.0,    ""margin_short"": 0.0,    ""margin"": 0.0,    ""last_price"": quote[""last_price""],    ""underlying_last_price"": underlying_quote[""last_price""] if underlying_quote else float(""nan""),    ""market_value_long"": 0.0, # 权利方市值(始终 >= 0)    ""market_value_short"": 0.0, # 义务方市值(始终 <= 0)    ""market_value"": 0.0,    ""future_margin"": _get_future_margin(quote),   }  def _generate_order(self, pack: dict) -> dict:   """"""order 对象预处理""""""   order = pack.copy()   order[""exchange_order_id""] = order[""order_id""]   order[""volume_orign""] = order[""volume""]   order[""volume_left""] = order[""volume""]   order[""frozen_margin""] = 0.0   order[""frozen_premium""] = 0.0   order[""last_msg""] = ""报单成功""   order[""status""] = ""ALIVE""   order[""insert_date_time""] = self._get_trade_timestamp()   del order[""aid""]   del order[""volume""]   self._append_to_diffs(['orders', order[""order_id""]], order)   return order  def _generate_trade(self, order, quote, price) -> dict:   trade_id = order[""order_id""] + ""|"" + str(order[""volume_left""])   return {    ""user_id"": order[""user_id""],    ""order_id"": order[""order_id""],    ""trade_id"": trade_id,    ""exchange_trade_id"": order[""order_id""] + ""|"" + str(order[""volume_left""]),    ""exchange_id"": order[""exchange_id""],    ""instrument_id"": order[""instrument_id""],    ""direction"": order[""direction""],    ""offset"": order[""offset""],    ""price"": price,    ""volume"": order[""volume_left""],    ""trade_date_time"": self._get_trade_timestamp(), # todo: 可能导致测试结果不确定    ""commission"": order[""volume_left""] * _get_commission(quote)   }  def _on_settle(self):   for symbol in self._orders:    for order in self._orders[symbol].values():     order[""frozen_margin""] = 0.0     order[""frozen_premium""] = 0.0     order[""last_msg""] = ""交易日结束，自动撤销当日有效的委托单（GFD）""     order[""status""] = ""FINISHED""     self._append_to_diffs(['orders', order[""order_id""]], order)   # account 原始字段   self._account[""pre_balance""] = self._account[""balance""] - self._account[""market_value""]   self._account[""close_profit""] = 0.0   self._account[""commission""] = 0.0   self._account[""premium""] = 0.0   self._account[""frozen_margin""] = 0.0   self._account[""frozen_premium""] = 0.0   # account 计算字段   self._account[""static_balance""] = self._account[""pre_balance""]   self._account[""position_profit""] = 0.0   self._account[""risk_ratio""] = self._account[""margin""] / self._account[""balance""]   self._account[""available""] = self._account[""static_balance""] - self._account[""margin""]   # 根据公式 账户权益 不需要计算 self._account[""balance""] = static_balance + market_value   self._append_to_diffs(['accounts', 'CNY'], self._account)   # 对于持仓的结算放在这里，没有放在 quote_handler 里的原因：   # 1. 异步发送的话，会造成如果此时 sim 未收到 pending_peek, 就没法把结算的账户信息发送出去，此时用户代码中 api.get_postion 得到的持仓和 sim 里面的持仓是不一致的   # set_target_pos 下单时就会产生错单。而且结算时一定是已经收到过行情的数据包，在同步代码的最后一步，会发送出去这个行情包 peeding_peek，   # quote_handler 处理 settle 的时候, 所以在结算的时候 pending_peek 一定是 False, 要 api 处理过之后，才会收到 peek_message   # 2. 同步发送的话，就可以和产生切换交易日的数据包同时发送出去   # 对 order 的处理发生在下一次回复 peek_message   for position in self._positions.values():    symbol = f""{position['exchange_id']}.{position['instrument_id']}""    # position 原始字段    position[""volume_long_frozen_today""] = 0    position[""volume_long_frozen_his""] = 0    position[""volume_short_frozen_today""] = 0    position[""volume_short_frozen_his""] = 0    position[""volume_long_today""] = 0    position[""volume_long_his""] = position[""volume_long""]    position[""volume_short_today""] = 0    position[""volume_short_his""] = position[""volume_short""]    # position 计算字段    position[""pos_long_his""] = position[""volume_long_his""]    position[""pos_long_today""] = 0    position[""pos_short_his""] = position[""volume_short_his""]    position[""pos_short_today""] = 0    position[""volume_long_frozen""] = 0    position[""volume_short_frozen""] = 0    position[""position_price_long""] = position[""last_price""]    position[""position_price_short""] = position[""last_price""]    quote, _ = self._get_quotes_by_symbol(symbol)    position[""position_cost_long""] = position[""last_price""] * position[""volume_long""] * quote[""volume_multiple""] # position 原始字段    position[""position_cost_short""] = position[""last_price""] * position[""volume_short""] * quote[""volume_multiple""] # position 原始字段    position[""position_profit_long""] = 0    position[""position_profit_short""] = 0    position[""position_profit""] = 0    self._append_to_diffs(['positions', symbol], position)  def _check_insert_order(self, order, symbol, position, quote, underlying_quote=None):   # 无法计入 orderbook, 各种账户都需要判断的   if (""commission"" not in quote or ""margin"" not in quote) and not quote[""ins_class""].endswith(""OPTION""):    order[""last_msg""] = ""不支持的合约类型，TqSim 目前不支持组合，股票，etf期权模拟交易""    order[""status""] = ""FINISHED""   if order[""status""] == ""ALIVE"" and not self._is_in_trading_time(quote):    order[""last_msg""] = ""下单失败, 不在可交易时间段内""    order[""status""] = ""FINISHED""   if order[""status""] == ""ALIVE"" and order[""offset""].startswith('CLOSE'):    if order[""exchange_id""] in [""SHFE"", ""INE""]:     if order[""offset""] == ""CLOSETODAY"":      if order[""direction""] == ""BUY"" and position[""volume_short_today""] - position[""volume_long_frozen_today""] < order[""volume_orign""]:       order[""last_msg""] = ""平今仓手数不足""      elif order[""direction""] == ""SELL"" and position[""volume_long_today""] - position[""volume_long_frozen_today""] < order[""volume_orign""]:       order[""last_msg""] = ""平今仓手数不足""     if order[""offset""] == ""CLOSE"":      if order[""direction""] == ""BUY"" and position[""volume_short_his""] - position[""volume_short_frozen_his""] < order[""volume_orign""]:       order[""last_msg""] = ""平昨仓手数不足""      elif order[""direction""] == ""SELL"" and position[""volume_long_his""] - position[""volume_long_frozen_his""] < order[""volume_orign""]:       order[""last_msg""] = ""平昨仓手数不足""    else:     if order[""direction""] == ""BUY"" and position[""volume_short""] - position[""volume_short_frozen""] < order[""volume_orign""]:      order[""last_msg""] = ""平仓手数不足""     elif order[""direction""] == ""SELL"" and position[""volume_long""] - position[""volume_long_frozen""] < order[""volume_orign""]:      order[""last_msg""] = ""平仓手数不足""    if order[""last_msg""].endswith(""手数不足""):     order[""status""] = ""FINISHED""   if order[""status""] == ""ALIVE"" and order[""offset""] == ""OPEN"":    # 计算冻结保证金，冻结权利金    if quote[""ins_class""].endswith(""OPTION""):     if order[""direction""] == ""SELL"": # 期权的SELL义务仓，开仓需要冻结保证金      order[""frozen_margin""] = order[""volume_orign""] * _get_option_margin(quote, quote[""last_price""], underlying_quote[""last_price""])     else: # 期权的BUY权利仓（市价单使用 last_price 计算需要冻结的权利金）      price = quote[""last_price""] if order[""price_type""] == ""ANY"" else order[""limit_price""]      order[""frozen_premium""] = order[""volume_orign""] * quote[""volume_multiple""] * price    else:     order[""frozen_margin""] = order[""volume_orign""] * _get_future_margin(quote)    if order[""frozen_margin""] + order[""frozen_premium""] > self._account[""available""]:     order[""frozen_margin""] = 0.0     order[""frozen_premium""] = 0.0     order[""last_msg""] = '开仓资金不足'     order[""status""] = ""FINISHED""   if order[""status""] == ""FINISHED"":    self._append_to_diffs(['orders', order[""order_id""]], order)  def _on_insert_order(self, order, symbol, position, quote, underlying_quote=None):   """"""判断 order 是否可以记录在 orderbook""""""   if order[""offset""] == ""OPEN"":    # 修改 account 计算字段    self._adjust_account_by_order(frozen_margin=order[""frozen_margin""], frozen_premium=order[""frozen_premium""])    self._append_to_diffs(['accounts', 'CNY'], self._account)   else:    # 修改 position 原始字段    if order[""exchange_id""] in [""SHFE"", ""INE""]:     if order[""direction""] == ""BUY"":      position[f""volume_short_frozen_{'today' if order['offset'] == 'CLOSETODAY' else 'his'}""] += order[""volume_orign""]     else:      position[f""volume_long_frozen_{'today' if order['offset'] == 'CLOSETODAY' else 'his'}""] += order[""volume_orign""]    elif order[""direction""] == ""BUY"":     volume_short_his_available = position[""volume_short_his""] - position[""volume_short_frozen_his""]     if volume_short_his_available < order[""volume_orign""]:      position[""volume_short_frozen_his""] += volume_short_his_available      position[""volume_short_frozen_today""] += order[""volume_orign""] - volume_short_his_available     else:      position[""volume_short_frozen_his""] += order[""volume_orign""]    else:     volume_long_his_available = position[""volume_long_his""] - position[""volume_long_frozen_his""]     if volume_long_his_available < order[""volume_orign""]:      position[""volume_long_frozen_his""] += volume_long_his_available      position[""volume_long_frozen_today""] += order[""volume_orign""] - volume_long_his_available     else:      position[""volume_long_frozen_his""] += order[""volume_orign""]    # 修改 position 计算字段    self._adjust_position_volume_frozen(position)    self._append_to_diffs(['positions', symbol], position)  def _on_order_traded(self, order, trade, symbol, position, quote, underlying_quote):   origin_frozen_margin = order[""frozen_margin""]   origin_frozen_premium = order[""frozen_premium""]   order[""frozen_margin""] = 0.0   order[""frozen_premium""] = 0.0   order[""volume_left""] = 0   order[""last_msg""] = ""全部成交""   order[""status""] = ""FINISHED""   self._append_to_diffs(['trades', trade[""trade_id""]], trade)   self._append_to_diffs(['orders', order[""order_id""]], order)   position = self._ensure_position(symbol, quote, underlying_quote)   if order[""offset""] == 'OPEN':    if order[""direction""] == ""BUY"":     # 修改 position 原始字段     position[""volume_long_today""] += order[""volume_orign""]     position[""open_cost_long""] += trade[""price""] * order[""volume_orign""] * quote[""volume_multiple""] # 多头开仓成本     position[""position_cost_long""] += trade[""price""] * order[""volume_orign""] * quote[""volume_multiple""] # 多头持仓成本    else:     # 修改 position 原始字段     position[""volume_short_today""] += order[""volume_orign""]     position[""open_cost_short""] += trade[""price""] * order[""volume_orign""] * quote[""volume_multiple""] # 空头开仓成本     position[""position_cost_short""] += trade[""price""] * order[""volume_orign""] * quote[""volume_multiple""] # 空头持仓成本    # 由 order 变化，account 需要更新的计算字段    self._adjust_account_by_order(frozen_margin=-origin_frozen_margin, frozen_premium=-origin_frozen_premium)    # 由 trade 引起的 account 原始字段变化，account 需要更新的计算字段    premium = _get_premium(trade, quote)    self._adjust_account_by_trade(commission=trade[""commission""], premium=premium)    # 由 position 字段变化，同时 account 需要更新的计算字段    buy_open = order[""volume_orign""] if order[""direction""] == ""BUY"" else 0    sell_open = 0 if order[""direction""] == ""BUY"" else order[""volume_orign""]    self._adjust_position_account(symbol, quote, underlying_quote,           pre_last_price=trade[""price""],           last_price=position[""last_price""],           pre_underlying_last_price=underlying_quote[""last_price""] if underlying_quote else float('nan'),           underlying_last_price=position[""underlying_last_price""],           buy_open=buy_open, sell_open=sell_open)   else: # order[""offset""].startswith('CLOSE')    # 修改 position 原始字段    if order[""exchange_id""] in [""SHFE"", ""INE""]:     if order[""offset""] == ""CLOSETODAY"":      if order[""direction""] == ""BUY"":       position[""volume_short_frozen_today""] -= order[""volume_orign""]       position[""volume_short_today""] -= order[""volume_orign""]      elif order[""direction""] == ""SELL"":       position[""volume_long_frozen_today""] -= order[""volume_orign""]       position[""volume_long_today""] -= order[""volume_orign""]     if order[""offset""] == ""CLOSE"":      if order[""direction""] == ""BUY"":       position[""volume_short_frozen_his""] -= order[""volume_orign""]       position[""volume_short_his""] -= order[""volume_orign""]      elif order[""direction""] == ""SELL"":       position[""volume_long_frozen_his""] -= order[""volume_orign""]       position[""volume_long_his""] -= order[""volume_orign""]    elif order[""direction""] == ""BUY"":     if position[""volume_short_frozen_his""] >= order[""volume_orign""]:      position[""volume_short_frozen_his""] -= order[""volume_orign""]      position[""volume_short_his""] -= order[""volume_orign""]     else:      position[""volume_short_frozen_today""] -= order[""volume_orign""] - position[""volume_short_frozen_his""]      position[""volume_short_today""] -= order[""volume_orign""] - position[""volume_short_frozen_his""]      position[""volume_short_his""] -= position[""volume_short_frozen_his""]      position[""volume_short_frozen_his""] = 0    else:     if position[""volume_long_frozen_his""] >= order[""volume_orign""]:      position[""volume_long_frozen_his""] -= order[""volume_orign""]      position[""volume_long_his""] -= order[""volume_orign""]     else:      position[""volume_long_frozen_today""] -= order[""volume_orign""] - position[""volume_long_frozen_his""]      position[""volume_long_today""] -= order[""volume_orign""] - position[""volume_long_frozen_his""]      position[""volume_long_his""] -= position[""volume_long_frozen_his""]      position[""volume_long_frozen_his""] = 0    # 修改 position 原始字段    if order[""direction""] == ""SELL"":     position[""open_cost_long""] -= position[""open_price_long""] * order[""volume_orign""] * quote[""volume_multiple""] # 多头开仓成本     position[""position_cost_long""] -= position[""position_price_long""] * order[""volume_orign""] * quote[""volume_multiple""] # 多头持仓成本    else:     position[""open_cost_short""] -= position[""open_price_short""] * order[""volume_orign""] * quote[""volume_multiple""] # 空头开仓成本     position[""position_cost_short""] -= position[""position_price_short""] * order[""volume_orign""] * quote[""volume_multiple""] # 空头持仓成本    # 由 trade 引起的 account 原始字段变化，account 需要更新的计算字段    premium = _get_premium(trade, quote)    close_profit = _get_close_profit(trade, quote, position)    self._adjust_account_by_trade(commission=trade[""commission""], premium=premium, close_profit=close_profit)    # 由 position 字段变化，同时 account 需要更新的计算字段    buy_close = order[""volume_orign""] if order[""direction""] == ""BUY"" else 0    sell_close = 0 if order[""direction""] == ""BUY"" else order[""volume_orign""]    self._adjust_position_account(symbol, quote, underlying_quote, pre_last_price=position[""last_price""],           last_price=0, pre_underlying_last_price=position[""underlying_last_price""],           underlying_last_price=0, buy_close=buy_close, sell_close=sell_close)   self._append_to_diffs(['positions', symbol], position)   self._append_to_diffs(['accounts', 'CNY'], self._account)  def _on_order_failed(self, symbol, order):   origin_frozen_margin = order[""frozen_margin""]   origin_frozen_premium = order[""frozen_premium""]   order[""frozen_margin""] = 0.0   order[""frozen_premium""] = 0.0   self._append_to_diffs(['orders', order[""order_id""]], order)   # 调整账户和持仓   if order[""offset""] == 'OPEN':    self._adjust_account_by_order(frozen_margin=-origin_frozen_margin, frozen_premium=-origin_frozen_premium)    self._append_to_diffs(['accounts', 'CNY'], self._account)   else:    position = self._positions[symbol]    if order[""exchange_id""] in [""SHFE"", ""INE""]:     if order[""offset""] == ""CLOSETODAY"":      if order[""direction""] == ""BUY"":       position[""volume_short_frozen_today""] -= order[""volume_orign""]      else:       position[""volume_long_frozen_today""] -= order[""volume_orign""]     if order[""offset""] == ""CLOSE"":      if order[""direction""] == ""BUY"":       position[""volume_short_frozen_his""] -= order[""volume_orign""]      else:       position[""volume_long_frozen_his""] -= order[""volume_orign""]    else:     if order[""direction""] == ""BUY"":      if position[""volume_short_frozen_today""] >= order[""volume_orign""]:       position[""volume_short_frozen_today""] -= order[""volume_orign""]      else:       position[""volume_short_frozen_his""] -= order[""volume_orign""] - position[""volume_short_frozen_today""]       position[""volume_short_frozen_today""] = 0     else:      if position[""volume_long_frozen_today""] >= order[""volume_orign""]:       position[""volume_long_frozen_today""] -= order[""volume_orign""]      else:       position[""volume_long_frozen_his""] -= order[""volume_orign""] - position[""volume_long_frozen_today""]       position[""volume_long_frozen_today""] = 0    self._adjust_position_volume_frozen(position)    self._append_to_diffs(['positions', symbol], position)  def _on_update_quotes(self, symbol, position, quote, underlying_quote):   # 调整持仓保证金和盈亏   position = self._positions.get(symbol)   underlying_last_price = underlying_quote[""last_price""] if underlying_quote else float('nan')   future_margin = _get_future_margin(quote)   if position[""volume_long""] > 0 or position[""volume_short""] > 0:    if position[""last_price""] != quote[""last_price""] \      or (math.isnan(future_margin) or future_margin != position[""future_margin""]) \      or (underlying_quote and (      math.isnan(underlying_last_price) or underlying_last_price != position[""underlying_last_price""])):     self._adjust_position_account(symbol, quote, underlying_quote,            pre_last_price=position[""last_price""],            last_price=quote[""last_price""],            pre_underlying_last_price=position[""underlying_last_price""],            underlying_last_price=underlying_last_price)     position[""future_margin""] = future_margin     position[""last_price""] = quote[""last_price""]     position[""underlying_last_price""] = underlying_last_price   else:    # 修改辅助变量    position[""future_margin""] = future_margin    position[""last_price""] = quote[""last_price""]    position[""underlying_last_price""] = underlying_last_price   self._append_to_diffs(['positions', symbol], position) # 一定要返回 position，下游会用到 future_margin 字段判断修改保证金是否成功   self._append_to_diffs(['accounts', 'CNY'], self._account)  def _adjust_position_account(self, symbol, quote, underlying_quote=None, pre_last_price=float('nan'), last_price=float('nan'),         pre_underlying_last_price=float('nan'), underlying_last_price=float('nan'),         buy_open=0, buy_close=0, sell_open=0, sell_close=0):   """"""   价格变化，使得 position 中的以下计算字段需要修改，这个函数计算出需要修改的差值部分，计算出差值部分修改 position、account   有两种情况下调用   1. 委托单 FINISHED，且全部成交，分为4种：buy_open, buy_close, sell_open, sell_close   2. 行情跳动   """"""   position = self._positions[symbol]   float_profit_long = 0 # 多头浮动盈亏   float_profit_short = 0 # 空头浮动盈亏   position_profit_long = 0 # 多头持仓盈亏，期权持仓盈亏为0   position_profit_short = 0 # 空头持仓盈亏，期权持仓盈亏为0   margin_long = 0 # 多头占用保证金   margin_short = 0 # 空头占用保证金   market_value_long = 0 # 期权权利方市值(始终 >= 0)   market_value_short = 0 # 期权义务方市值(始终 <= 0)   assert [buy_open, buy_close, sell_open, sell_close].count(0) >= 3 # 只有一个大于0, 或者都是0，表示价格变化导致的字段修改   if buy_open > 0:    # 买开，pre_last_price 应该是成交价格，last_price 应该是 position['last_price']    float_profit_long = (last_price - pre_last_price) * buy_open * quote[""volume_multiple""]    if quote[""ins_class""].endswith(""OPTION""):     market_value_long = last_price * buy_open * quote[""volume_multiple""]    else:     margin_long = buy_open * _get_future_margin(quote)     position_profit_long = (last_price - pre_last_price) * buy_open * quote[""volume_multiple""]   elif sell_close > 0:    # 卖平，pre_last_price 应该是 position['last_price']，last_price 应该是 0    float_profit_long = -position[""float_profit_long""] / position[""volume_long""] * sell_close    if quote[""ins_class""].endswith(""OPTION""):     market_value_long = -pre_last_price * sell_close * quote[""volume_multiple""]    else:     margin_long = -sell_close * _get_future_margin(quote)     position_profit_long = -position[""position_profit_long""] / position[""volume_long""] * sell_close   elif sell_open > 0:    # 卖开    float_profit_short = (pre_last_price - last_price) * sell_open * quote[""volume_multiple""]    if quote[""ins_class""].endswith(""OPTION""):     market_value_short = -last_price * sell_open * quote[""volume_multiple""]     margin_short = sell_open * _get_option_margin(quote, last_price, underlying_last_price)    else:     margin_short = sell_open * _get_future_margin(quote)     position_profit_short = (pre_last_price - last_price) * sell_open * quote[""volume_multiple""]   elif buy_close > 0:    # 买平    float_profit_short = -position[""float_profit_short""] / position[""volume_short""] * buy_close    if quote[""ins_class""].endswith(""OPTION""):     market_value_short = pre_last_price * buy_close * quote[""volume_multiple""]     margin_short = -buy_close * _get_option_margin(quote, pre_last_price, pre_underlying_last_price)    else:     margin_short = -buy_close * _get_future_margin(quote)     position_profit_short = -position[""position_profit_short""] / position[""volume_short""] * buy_close   else:    float_profit_long = (last_price - pre_last_price) * position[""volume_long""] * quote[""volume_multiple""] # 多头浮动盈亏    float_profit_short = (pre_last_price - last_price) * position[""volume_short""] * quote[""volume_multiple""] # 空头浮动盈亏    if quote[""ins_class""].endswith(""OPTION""):     margin_short = _get_option_margin(quote, last_price, underlying_last_price) * position[""volume_short""] - position[""margin_short""]     market_value_long = (last_price - pre_last_price) * position[""volume_long""] * quote[""volume_multiple""]     market_value_short = (pre_last_price - last_price) * position[""volume_short""] * quote[""volume_multiple""]    else:     # 期权持仓盈亏为 0     position_profit_long = float_profit_long # 多头持仓盈亏     position_profit_short = float_profit_short # 空头持仓盈亏     margin_long = _get_future_margin(quote) * position[""volume_long""] - position[""margin_long""]     margin_short = _get_future_margin(quote) * position[""volume_short""] - position[""margin_short""]   if any([buy_open, buy_close, sell_open, sell_close]):    # 修改 position volume 相关的计算字段    # 在上面 sell_close buy_close 两种情况，计算浮动盈亏时，用到了修改前的手数，所以需改手数字段的代码放在这个位置    self._adjust_position_volume(position)   self._adjust_position(quote, position, float_profit_long, float_profit_short, position_profit_long,        position_profit_short, margin_long, margin_short, market_value_long, market_value_short)   self._adjust_account_by_position(float_profit=float_profit_long + float_profit_short,           position_profit=position_profit_long + position_profit_short,           margin=margin_long + margin_short,           market_value=market_value_long + market_value_short)  # -------- 对于 position 的计算字段修改分为两类：  # 1. 针对手数相关的修改，在下单、成交时会修改  # 2. 针对盈亏、保证金、市值的修改，由于参考合约最新价，在成交、行情跳动时会修改  def _adjust_position_volume_frozen(self, position):   """"""position 原始字段修改后，只有冻结手数需要重新计算，有两种情况需要调用   1. 下平仓单 2. 平仓单 FINISHED, 但没有成交   """"""   position[""volume_long_frozen""] = position[""volume_long_frozen_today""] + position[""volume_long_frozen_his""]   position[""volume_short_frozen""] = position[""volume_short_frozen_today""] + position[""volume_short_frozen_his""]  def _adjust_position_volume(self, position):   """"""position 原始字段修改后，手数之后需要重新计算   1. 委托单 FINISHED，且全部成交   """"""   position[""pos_long_today""] = position[""volume_long_today""]   position[""pos_long_his""] = position[""volume_long_his""]   position[""pos_short_today""] = position[""volume_short_today""]   position[""pos_short_his""] = position[""volume_short_his""]   position[""volume_long""] = position[""volume_long_today""] + position[""volume_long_his""]   position[""volume_long_frozen""] = position[""volume_long_frozen_today""] + position[""volume_long_frozen_his""]   position[""volume_short""] = position[""volume_short_today""] + position[""volume_short_his""]   position[""volume_short_frozen""] = position[""volume_short_frozen_today""] + position[""volume_short_frozen_his""]  def _adjust_position(self, quote, position, float_profit_long=0, float_profit_short=0, position_profit_long=0,         position_profit_short=0, margin_long=0, margin_short=0, market_value_long=0,         market_value_short=0):   # 更新 position 计算字段，根据差值更新的字段   position[""float_profit_long""] += float_profit_long   position[""float_profit_short""] += float_profit_short   position[""position_profit_long""] += position_profit_long   position[""position_profit_short""] += position_profit_short   position[""margin_long""] += margin_long   position[""margin_short""] += margin_short   position[""market_value_long""] += market_value_long   position[""market_value_short""] += market_value_short   # 更新 position 计算字段，原地重新计算的字段   if position[""volume_long""] > 0:    position[""open_price_long""] = position[""open_cost_long""] / position[""volume_long""] / quote[""volume_multiple""]    position[""position_price_long""] = position[""position_cost_long""] / position[""volume_long""] / quote[""volume_multiple""]   else:    position[""open_price_long""] = float(""nan"")    position[""position_price_long""] = float(""nan"")   if position[""volume_short""] > 0:    position[""open_price_short""] = position[""open_cost_short""] / position[""volume_short""] / quote[""volume_multiple""]    position[""position_price_short""] = position[""position_cost_short""] / position[""volume_short""] / quote[""volume_multiple""]   else:    position[""open_price_short""] = float(""nan"")    position[""position_price_short""] = float(""nan"")   position[""float_profit""] = position[""float_profit_long""] + position[""float_profit_short""]   position[""position_profit""] = position[""position_profit_long""] + position[""position_profit_short""]   position[""margin""] = position[""margin_long""] + position[""margin_short""]   position[""market_value""] = position[""market_value_long""] + position[""market_value_short""]  # -------- 对于 account 的修改分为以下三类  def _adjust_account_by_trade(self, commission=0, close_profit=0, premium=0):   """"""由成交引起的 account 原始字段变化，account 需要更新的计算字段""""""   # account 原始字段   self._account[""close_profit""] += close_profit   self._account[""commission""] += commission   self._account[""premium""] += premium # premium变量的值有正负，正数表示收入的权利金，负数表示付出的权利金   # account 计算字段   self._account[""balance""] += close_profit - commission + premium   self._account[""available""] += close_profit - commission + premium   self._account[""risk_ratio""] = self._account[""margin""] / self._account[""balance""]  def _adjust_account_by_position(self, float_profit=0, position_profit=0, margin=0, market_value=0):   """"""由 position 变化，account 需要更新的计算字段""""""   # account 计算字段，持仓字段求和的字段   self._account[""float_profit""] += float_profit   self._account[""position_profit""] += position_profit   self._account[""margin""] += margin   self._account[""market_value""] += market_value   # account 计算字段   self._account[""balance""] += position_profit + market_value   self._account[""available""] += position_profit - margin   self._account[""risk_ratio""] = self._account[""margin""] / self._account[""balance""]  def _adjust_account_by_order(self, frozen_margin=0, frozen_premium=0):   """"""由 order 变化，account 需要更新的计算字段""""""   self._account[""frozen_margin""] += frozen_margin   self._account[""frozen_premium""] += frozen_premium   self._account[""available""] -= (frozen_margin + frozen_premium) "
176,n\tqsdk\sim\trade bas,"n\tqsdk\sim\trade bas. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' import math from abc import abstractmethod from datetime import datetime from typing import Callable from tqsdk.datetime import _is_in_trading_time from tqsdk.diff import _simple_merge_diff from tqsdk.sim.utils import _get_price_range class SimTradeBase(object):  """"""  本模块为 TqSim 交易部分的子模块的基类，纯同步计算，不涉及连接行情的动态信息，所以对于接口的调用有一些需要注意的要求  不同的账户类型继承本模块，并实现具体账户类型的计算  对外提供的接口:  + init_snapshot: 返回初始的账户截面信息  + insert_order -> (diffs, orders_events): 处理下单请求，调用 TqSimAccount.insert_order 之前应该调用过 update_quote，保证收到过合约的行情；期权还应该确保收到了标的的行情  + cancel_order -> (diffs, orders_events)：处理撤单请求  + update_quote -> (diffs, orders_events)：处理行情更新  + settle -> (diffs, _orders_events, trade_log)：处理结算请求  注意：  + diffs (list) : 每个元素都是符合 diff 协议中 trade 交易部分的数据包，且返回的都是完整字段的对象，比如：order成交时，返回的是order完整对象而不是有变化的字段  + orders_events (list) : 按照顺序记录 order 的更新，返回给调用方  + trade_log (dict) : 是结算前的账户日志信息  diffs 由子类负责调用 _append_to_diffs  orders_events 由父类统一处理在 order 状态变化时，在 list 中追加委托单实例  """"""  def __init__(self, account_key: str, init_balance: float = 10000000.0, get_trade_timestamp: Callable = None,     is_in_trading_time: Callable = None) -> None:   self._account_key = account_key   self._quotes = {} # 会记录所有的发来的行情   # 初始化账户结构   self._account = self._generate_account(init_balance)   self._positions = {} # {symbol: position, ...}   self._orders = {} # {symbol: {order_id: order}, ...}   self._trades = [] # list 类型，与重构之前代码保持一致，list 可以保留 trade 生产的顺序信息   self._diffs = []   self._orders_events = [] # 按照顺序记录 order 的更新，返回给调用方   self._max_datetime = """" # 所有 quotes 的最大行情更新时间   # 本模块在计算成交时间、判断是否在交易时间段内，默认使用所有 quotes 的最大行情更新时间当作当前时间，并且没有模拟到交易时的时间差   # 若外部调用模块需要更精确时间，则由外部模块提供函数支持   self._get_trade_timestamp = get_trade_timestamp if get_trade_timestamp else self._default_get_trade_timestamp   self._is_in_trading_time = is_in_trading_time if is_in_trading_time else self._default_is_in_trading_time  @abstractmethod  def _generate_account(self, init_balance: float) -> dict:   """"""返回 account 账户结构""""""   pass  @abstractmethod  def _generate_order(self, pack: dict) -> dict:   """"""返回 order 委托单结构""""""   pass  @abstractmethod  def _generate_trade(self, order, quote, price) -> dict:   """"""返回 trade 成交对象结构""""""   pass  @abstractmethod  def _generate_position(self, symbol, quote, underlying_quote) -> dict:   """"""返回 position 对象结构""""""   pass  @abstractmethod  def _check_insert_order(self, order, symbol, position, quote, underlying_quote):   """"""检查是否可以下单，在 order 原对象上修改属性""""""   pass  @abstractmethod  def _on_insert_order(self, order, symbol, position, quote, underlying_quote):   """"""将 order 记入 order_book 时调用""""""   pass  @abstractmethod  def _on_order_failed(self, symbol, order):   """"""处理 order 变为 FINISHED，且没有成交，撤单""""""   pass  @abstractmethod  def _on_order_traded(self, order, trade, symbol, position, quote, underlying_quote):   """"""处理 order 变为 FINISHED，且全部成交""""""   pass  @abstractmethod  def _on_update_quotes(self, symbol, position, quote, underlying_quote):   """"""更新合约行情后，更行对应的持仓及账户信息""""""   pass  @abstractmethod  def _on_settle(self):   """"""结算时，应该调整 委托单、持仓、账户""""""   pass  def init_snapshot(self):   """"""返回初始账户截面信息""""""   return {    ""trade"": {     self._account_key: {      ""accounts"": {""CNY"": self._account.copy()},      ""positions"": {},      ""orders"": {},      ""trades"": {}     }    }   }  def insert_order(self, symbol, pack):   quote, underlying_quote = self._get_quotes_by_symbol(symbol)   position = self._ensure_position(symbol, quote, underlying_quote)   order = self._generate_order(pack)   self._orders_events.append(order.copy())   self._check_insert_order(order, symbol, position, quote, underlying_quote)   if order[""status""] == ""FINISHED"":    self._orders_events.append(order.copy())   else:    orders = self._orders.setdefault(symbol, {})    orders[order[""order_id""]] = order # order 存入全局    self._on_insert_order(order, symbol, position, quote, underlying_quote)    self._match_order(order, symbol, position, quote, underlying_quote)   return self._return_results()  def cancel_order(self, symbol, pack):   order = self._orders.get(symbol, {}).get(pack[""order_id""], {})   if order.get(""status"") == ""ALIVE"":    order[""last_msg""] = ""已撤单""    order[""status""] = ""FINISHED""    self._on_order_failed(symbol, order)    self._orders_events.append(order)    del self._orders[symbol][order[""order_id""]] # 删除 order   return self._return_results()  def update_quotes(self, symbol, pack):   for q in pack.get(""quotes"", {}).values():    self._max_datetime = max(q.get(""datetime"", """"), self._max_datetime)   _simple_merge_diff(self._quotes, pack.get(""quotes"", {}), reduce_diff=False)   quote, underlying_quote = self._get_quotes_by_symbol(symbol)   # 某些非交易时间段，ticks 回测是 quote 的最新价有可能是 nan，无效的行情直接跳过   if math.isnan(quote[""last_price""]):    return [], []   # 撮合委托单   orders = self._orders.get(symbol, {})   position = self._ensure_position(symbol, quote, underlying_quote)   for order_id in list(orders.keys()): # match_order 过程中可能会删除 orders 下对象    self._match_order(orders[order_id], symbol, position, quote, underlying_quote)   self._on_update_quotes(symbol, position, quote, underlying_quote) # 调整持仓及账户信息   return self._return_results()  def _match_order(self, order, symbol, position, quote, underlying_quote=None):   assert order[""status""] == ""ALIVE""   status, last_msg, price = SimTradeBase.match_order(order, quote)   if status == ""FINISHED"":    if last_msg == ""全部成交"":     trade = self._generate_trade(order, quote, price)     self._trades.append(trade)     self._on_order_traded(order, trade, symbol, position, quote, underlying_quote)    else:     order[""last_msg""] = last_msg     order[""status""] = status     self._on_order_failed(symbol, order)    # 成交后记录 orders_event, 删除 order    self._orders_events.append(order)    del self._orders[symbol][order[""order_id""]]  def settle(self):   trade_log = {    ""trades"": self._trades,    ""account"": self._account.copy(),    ""positions"": {k: v.copy() for k, v in self._positions.items()}   }   # 为下一交易日调整账户   self._trades = []   self._on_settle()   for symbol in self._orders:    for order in self._orders[symbol].values():     self._orders_events.append(order)    self._orders[symbol] = {}   diffs, orders_events = self._return_results()   return diffs, orders_events, trade_log  def _ensure_position(self, symbol, quote, underlying_quote):   position = self._positions.get(symbol, None)   if position is None:    position = self._generate_position(symbol, quote, underlying_quote)    self._positions[symbol] = position   return position  def _get_quotes_by_symbol(self, symbol):   """"""返回指定合约及标的合约，在本模块执行过程中，应该保证一定有合约行情""""""   quote = self._quotes.get(symbol)   assert quote and quote.get(""datetime""), ""未收到指定合约行情""   underlying_quote = None   if quote[""ins_class""].endswith(""OPTION""):    underlying_quote = self._quotes.get(quote[""underlying_symbol""])    assert underlying_quote and underlying_quote.get(""datetime""), ""未收到指定合约的标的行情""   return quote, underlying_quote  def _append_to_diffs(self, path, obj):   target = {}   diff = {'trade': {self._account_key: target}}   while len(path) > 0:    k = path.pop(0)    target[k] = obj.copy() if len(path) == 0 else {}    target = target[k]   self._diffs.append(diff)  def _return_results(self):   """"""   返回两项内容：diffs: list, orders_events: list   diffs 是截面的变更   orders_events 是委托单变化   """"""   diffs, self._diffs = self._diffs, []   orders_events, self._orders_events = self._orders_events, []   return diffs, orders_events  def _default_get_trade_timestamp(self):   """"""获取交易时间的默认方法，为当前所有 quote 的最大行情时间""""""   return int(datetime.strptime(self._max_datetime, ""%Y-%m-%d %H:%M:%S.%f"").timestamp() * 1e6) * 1000  def _default_is_in_trading_time(self, quote):   """"""判断是否在交易时间段""""""   return _is_in_trading_time(quote, self._max_datetime, float(""nan""))  @staticmethod  def match_order(order, quote) -> (str, str, float):   """"""   撮合交易规则：   * 市价单使用对手盘价格成交, 如果没有对手盘(涨跌停)则自动撤单   * 限价单要求报单价格达到或超过对手盘价格才能成交, 成交价为报单价格, 如果没有对手盘(涨跌停)则无法成交   * 模拟交易只有全部成交   returns: status, last_msg, price   """"""   status, last_msg = ""ALIVE"", """"   ask_price, bid_price = _get_price_range(quote)   # order 预期成交价格   if order[""price_type""] in [""ANY"", ""BEST"", ""FIVELEVEL""]:    price = ask_price if order[""direction""] == ""BUY"" else bid_price   else:    price = order[""limit_price""]   if order[""price_type""] == ""ANY"" and math.isnan(price):    status, last_msg = ""FINISHED"", ""市价指令剩余撤销""   if order[""time_condition""] == ""IOC"": # IOC 立即成交，限价下单且不能成交的价格，直接撤单    if order[""direction""] == ""BUY"" and price < ask_price or order[""direction""] == ""SELL"" and price > bid_price:     status, last_msg = ""FINISHED"", ""已撤单报单已提交""   if order[""direction""] == ""BUY"" and price >= ask_price or order[""direction""] == ""SELL"" and price <= bid_price:    status, last_msg = ""FINISHED"", ""全部成交""   return status, last_msg, price "
177,n\tqsdk\sim\util,"n\tqsdk\sim\util. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' TRADING_DAYS_OF_YEAR = 250 def _get_price_range(quote):  """""" 返回合约对应的买一卖一盘口价格""""""  ask_price = quote[""ask_price1""]  bid_price = quote[""bid_price1""]  if quote[""ins_class""].endswith(""INDEX""):   # 在指数交易时，使用 tick 进行回测时，backtest 发的 quote 没有买一卖一价；或者在实时行情中，指数的 quote 也没有买一卖一价   if ask_price != ask_price:    ask_price = quote[""last_price""] + quote[""price_tick""]   if bid_price != bid_price:    bid_price = quote[""last_price""] - quote[""price_tick""]  return ask_price, bid_price def _get_option_margin(quote, last_price, underlying_last_price):  """"""返回每张期权占用保证金，只有空头持仓占用保证金""""""  # 期权保证金计算公式参考深交所文档 http://docs.static.szse.cn/www/disclosure/notice/general/W020191207433397366259.pdf  if quote[""option_class""] == ""CALL"":   # 认购期权义务仓开仓保证金＝[合约最新价 + Max（12% × 合约标的最新价 - 认购期权虚值， 7% × 合约标的最新价）] × 合约单位   # 认购期权虚值＝Max（行权价 - 合约标的最新价，0）   out_value = max(quote[""strike_price""] - underlying_last_price, 0)   return (last_price + max(0.12 * underlying_last_price - out_value,         0.07 * underlying_last_price)) * quote[""volume_multiple""]  else:   # 认沽期权义务仓开仓保证金＝Min[合约最新价+ Max（12% × 合约标的最新价 - 认沽期权虚值，7% × 行权价），行权价] × 合约单位   # 认沽期权虚值＝Max（合约标的最新价 - 行权价，0）   out_value = max(underlying_last_price - quote[""strike_price""], 0)   return min(quote[""last_price""] + max(0.12 * underlying_last_price - out_value,            0.07 * quote[""strike_price""]),     quote[""strike_price""]) * quote[""volume_multiple""] def _get_premium(trade, quote):  """"""返回成交导致的权利金变化""""""  if quote[""ins_class""].endswith(""OPTION""):   premium = trade[""price""] * trade[""volume""] * quote[""volume_multiple""]   return -premium if trade[""direction""] == ""BUY"" else premium  else:   return 0 def _get_close_profit(trade, quote, position):  """"""返回成交导致的平仓盈亏变化""""""  if quote[""ins_class""].endswith(""OPTION""):   # 期权没有持仓盈亏没有持仓价，其平仓的盈亏体现在市价变化中   return 0  # 期货及其他使用持仓价计算  elif trade[""direction""] == ""SELL"":   return (trade[""price""] - position[""position_price_long""]) * trade[""volume""] * quote[""volume_multiple""]  else:   return (position[""position_price_short""] - trade[""price""]) * trade[""volume""] * quote[""volume_multiple""] def _get_commission(quote={}):  """"""返回每手手续费""""""  if quote.get(""ins_class"", """").endswith(""OPTION""):   return quote.get(""user_commission"", 10) # 期权quote没有commission字段, 设为固定10元一张, 优先采用用户设置的参数  return quote.get(""user_commission"", quote.get('commission', float('nan'))) def _get_future_margin(quote={}):  """"""返回期货每手保证金""""""  if quote.get(""ins_class"", """").endswith(""OPTION""):   return float('nan')  return quote.get(""user_margin"", quote.get(""margin"", float('nan'))) "
178,n\tqsdk\sim\  init ,"n\tqsdk\sim\  init . #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' import asyncio import statistics import time from datetime import datetime from tqsdk.channel import TqChan from tqsdk.datetime import _get_trading_day_from_timestamp, _get_trading_day_end_time, _get_trade_timestamp, \  _is_in_trading_time, _format_from_timestamp_nano from tqsdk.diff import _get_obj, _register_update_chan, _merge_diff from tqsdk.entity import Entity from tqsdk.objs import Quote from tqsdk.report import TqReport from tqsdk.sim.trade import SimTrade from tqsdk.sim.utils import _get_future_margin, _get_commission from tqsdk.utils import _query_for_quote class TqSim(object):  """"""  天勤模拟交易类  该类实现了一个本地的模拟账户，并且在内部完成撮合交易，在回测和复盘模式下，只能使用 TqSim 账户来交易。  限价单要求报单价格达到或超过对手盘价格才能成交, 成交价为报单价格, 如果没有对手盘(涨跌停)则无法成交  市价单使用对手盘价格成交, 如果没有对手盘(涨跌停)则自动撤单  模拟交易不会有部分成交的情况, 要成交就是全部成交  """"""  def __init__(self, init_balance: float = 10000000.0, account_id: str = None) -> None:   """"""   Args:    init_balance (float): [可选]初始资金, 默认为一千万    account_id (str): [可选]帐号, 默认为 TQSIM   Example::    # 修改TqSim模拟帐号的初始资金为100000    from tqsdk import TqApi, TqSim, TqAuth    api = TqApi(TqSim(init_balance=100000), auth=TqAuth(""信易账户"", ""账户密码""))   """"""   self.trade_log = {} # 日期->交易记录及收盘时的权益及持仓   self.tqsdk_stat = {} # 回测结束后储存回测报告信息   self._account_id = ""TQSIM"" if account_id is None else account_id   self._account_type = ""FUTURE""   self._broker_id = ""TQSIM"" if self._account_type == ""FUTURE"" else ""TQSIM_STOCK""   self._account_key = str(id(self))   self._init_balance = float(init_balance)   if self._init_balance <= 0:    raise Exception(""初始资金(init_balance) %s 错误, 请检查 init_balance 是否填写正确"" % (init_balance))   self._current_datetime = ""1990-01-01 00:00:00.000000"" # 当前行情时间（最新的 quote 时间）   self._trading_day_end = ""1990-01-01 18:00:00.000000""   self._local_time_record = float(""nan"") # 记录获取最新行情时的本地时间   self._sim_trade = SimTrade(account_key=self._account_key, init_balance=self._init_balance,          get_trade_timestamp=self._get_trade_timestamp,          is_in_trading_time=self._is_in_trading_time)   self._data = Entity()   self._data._instance_entity([])   self._prototype = {    ""quotes"": {     ""#"": Quote(self), # 行情的数据原型    }   }   self._quote_tasks = {}  def set_commission(self, symbol: str, commission: float=float('nan')):   """"""   设置指定合约模拟交易的每手手续费。   Args:    symbol (str): 合约代码    commission (float): 每手手续费   Returns:    float: 设置的每手手续费   Example::    from tqsdk import TqSim, TqApi, TqAuth    sim = TqSim()    api = TqApi(sim, auth=TqAuth(""信易账户"", ""账户密码""))    sim.set_commission(""SHFE.cu2112"", 50)    print(sim.get_commission(""SHFE.cu2112""))   """"""   if commission != commission:    raise Exception(""合约手续费不可以设置为 float('nan')"")   quote = _get_obj(self._data, [""quotes"", symbol], Quote(self._api if hasattr(self, ""_api"") else None))   quote[""user_commission""] = commission   if self._quote_tasks.get(symbol):    self._quote_tasks[symbol][""quote_chan""].send_nowait({     ""quotes"": {symbol: {""user_commission"": commission}}    })   return commission  def set_margin(self, symbol: str, margin: float=float('nan')):   """"""   设置指定合约模拟交易的每手保证金。   Args:    symbol (str): 合约代码 (只支持期货合约)    margin (float): 每手保证金   Returns:    float: 设置的每手保证金   Example::    from tqsdk import TqSim, TqApi, TqAuth    sim = TqSim()    api = TqApi(sim, auth=TqAuth(""信易账户"", ""账户密码""))    sim.set_margin(""SHFE.cu2112"", 26000)    print(sim.get_margin(""SHFE.cu2112""))   """"""   if margin != margin:    raise Exception(""合约手续费不可以设置为 float('nan')"")   quote = _get_obj(self._data, [""quotes"", symbol], Quote(self._api if hasattr(self, ""_api"") else None))   quote[""user_margin""] = margin   if self._quote_tasks.get(symbol):    self._quote_tasks[symbol][""quote_chan""].send_nowait({     ""quotes"": {symbol: {""user_margin"": margin}}    })    # 当用户设置保证金时，用户应该得到的效果是：    # 在调用 sim.set_margin() 之后，立即调用 api.get_position(symbol)，得到的 margin 字段应该按照新设置的保证金调整过，而且中间没有收到过行情更新包    # 以下代码可以保证这个效果，说明：    # 1. 持仓已经调整过:    # sim_trade 中持仓的 future_margin 字段更新，margin 会同时调整，那么 api 中持仓的 future_margin 更新时，margin 一定也已经更新    # 2. 中间没有收到过行情更新包:    # 前提1：根据 diff 协议，sim 收到 peek_message 时，会将缓存的 diffs 发给用户，当缓存的 diffs 为空，会转发 peek_message；    # 前提2：api.wait_update() 会等到所有 task 都执行到 pending 状态，然后发送 peek_message 给 sim    # 当用户代码执行到 sim.set_margin()，立即向 quote_chan 中发送一个数据包，quote_task 就会到 ready 状态，此时调用 wait_update()，    # 到所有 task 执行到 pending 状态时，sim 的 diffs 中有数据了，此时收到 api 发来 peek_message 不会转发给上游，用户会先收到 sim 本身的账户数据，    # 在下一次 wait_update，sim 的 diffs 为空，才会收到行情数据    # 在回测时，以下代码应该只经历一次 wait_update    while margin != self._api.get_position(symbol).get(""future_margin""):     self._api.wait_update()   return margin  def get_margin(self, symbol: str):   """"""   获取指定合约模拟交易的每手保证金。   Args:    symbol (str): 合约代码   Returns:    float: 返回合约模拟交易的每手保证金   Example::    from tqsdk import TqSim, TqApi, TqAuth    sim = TqSim()    api = TqApi(sim, auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SHFE.cu2112"")    print(sim.get_margin(""SHFE.cu2112""))   """"""   return _get_future_margin(self._data.get(""quotes"", {}).get(symbol, {}))  def get_commission(self, symbol: str):   """"""   获取指定合约模拟交易的每手手续费   Args:    symbol (str): 合约代码   Returns:    float: 返回合约模拟交易的每手手续费   Example::    from tqsdk import TqSim, TqApi, TqAuth    sim = TqSim()    api = TqApi(sim, auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SHFE.cu2112"")    print(sim.get_commission(""SHFE.cu2112""))   """"""   return _get_commission(self._data.get(""quotes"", {}).get(symbol, {}))  async def _run(self, api, api_send_chan, api_recv_chan, md_send_chan, md_recv_chan):   """"""模拟交易task""""""   self._api = api   self._tqsdk_backtest = {} # 储存可能的回测信息   self._logger = api._logger.getChild(""TqSim"") # 调试信息输出   self._api_send_chan = api_send_chan   self._api_recv_chan = api_recv_chan   self._md_send_chan = md_send_chan   self._md_recv_chan = md_recv_chan   self._pending_peek = False   # True 下游发过 subscribe，但是没有转发给上游；False 表示下游发的 subscribe 都转发给上游   self._pending_subscribe_downstream = False   # True 发给上游 subscribe，但是没有收到过回复；False 如果行情不变，上游不会回任何包   self._pending_subscribe_upstream = False   self._diffs = []   self._all_subscribe = set() # 客户端+模拟交易模块订阅的合约集合   # 是否已经发送初始账户信息   self._has_send_init_account = False   md_task = self._api.create_task(self._md_handler()) # 将所有 md_recv_chan 上收到的包投递到 api_send_chan 上   try:    async for pack in self._api_send_chan:     if ""_md_recv"" in pack:      if pack[""aid""] == ""rtn_data"":       self._md_recv(pack) # md_recv 中会发送 wait_count 个 quotes 包给各个 quote_chan       await asyncio.gather(*[quote_task[""quote_chan""].join() for quote_task in self._quote_tasks.values()])       await self._send_diff()     elif pack[""aid""] == ""subscribe_quote"":      await self._subscribe_quote(set(pack[""ins_list""].split("","")))     elif pack[""aid""] == ""peek_message"":      self._pending_peek = True      await self._send_diff()      if self._pending_peek: # 控制""peek_message""发送: 当没有新的事件需要用户处理时才推进到下一个行情       await self._md_send_chan.send(pack)     elif pack[""aid""] == ""insert_order"":      # 非该账户的消息包发送至下一个账户      if pack[""account_key""] != self._account_key:       await self._md_send_chan.send(pack)      else:       symbol = pack[""exchange_id""] + ""."" + pack[""instrument_id""]       if symbol not in self._quote_tasks:        quote_chan = TqChan(self._api)        order_chan = TqChan(self._api)        self._quote_tasks[symbol] = {         ""quote_chan"": quote_chan,         ""order_chan"": order_chan,         ""task"": self._api.create_task(self._quote_handler(symbol, quote_chan, order_chan))        }       if ""account_key"" in pack:        pack.pop(""account_key"", None)       await self._quote_tasks[symbol][""order_chan""].send(pack)     elif pack[""aid""] == ""cancel_order"":      # 非该账户的消息包发送至下一个账户      if pack[""account_key""] != self._account_key:       await self._md_send_chan.send(pack)      else:       # 发送至服务器的包需要去除 account_key 信息       if ""account_key"" in pack:        pack.pop(""account_key"", None)       # pack 里只有 order_id 信息，发送到每一个合约的 order_chan, 交由 quote_task 判断是不是当前合约下的委托单       for symbol in self._quote_tasks:        await self._quote_tasks[symbol][""order_chan""].send(pack)     else:      await self._md_send_chan.send(pack)     if self._tqsdk_backtest != {} and self._tqsdk_backtest[""current_dt""] >= self._tqsdk_backtest[""end_dt""] \       and not self.tqsdk_stat:      # 回测情况下，把 _send_stat_report 在循环中回测结束时执行      await self._send_stat_report()   finally:    if not self.tqsdk_stat:     await self._send_stat_report()    md_task.cancel()    tasks = [md_task]    for symbol in self._quote_tasks:     self._quote_tasks[symbol][""task""].cancel()     tasks.append(self._quote_tasks[symbol][""task""])    await asyncio.gather(*tasks, return_exceptions=True)  async def _md_handler(self):   async for pack in self._md_recv_chan:    pack[""_md_recv""] = True    self._pending_subscribe_upstream = False    await self._api_send_chan.send(pack)  async def _send_diff(self):   if self._pending_peek:    if self._diffs:     rtn_data = {      ""aid"": ""rtn_data"",      ""data"": self._diffs,     }     self._diffs = []     self._pending_peek = False     await self._api_recv_chan.send(rtn_data)    if self._pending_subscribe_downstream:     self._pending_subscribe_upstream = True     self._pending_subscribe_downstream = False     await self._md_send_chan.send({      ""aid"": ""subscribe_quote"",      ""ins_list"": "","".join(self._all_subscribe)     })  async def _subscribe_quote(self, symbols: [set, str]):   """"""这里只会增加订阅合约，不会退订合约""""""   symbols = symbols if isinstance(symbols, set) else {symbols}   if symbols - self._all_subscribe:    self._all_subscribe |= symbols    if self._pending_peek and not self._pending_subscribe_upstream:     self._pending_subscribe_upstream = True     self._pending_subscribe_downstream = False     await self._md_send_chan.send({      ""aid"": ""subscribe_quote"",      ""ins_list"": "","".join(self._all_subscribe)     })    else:     self._pending_subscribe_downstream = True  async def _send_stat_report(self):   self._settle()   self._report()   await self._api_recv_chan.send({    ""aid"": ""rtn_data"",    ""data"": [{     ""trade"": {      self._account_key: {       ""accounts"": {        ""CNY"": {         ""_tqsdk_stat"": self.tqsdk_stat        }       }      }     }    }]   })  async def _ensure_quote_info(self, symbol, quote_chan):   """"""quote收到合约信息后返回""""""   quote = _get_obj(self._data, [""quotes"", symbol], Quote(self._api))   if quote.get(""price_tick"") == quote.get(""price_tick""):    return quote.copy()   if quote.get(""price_tick"") != quote.get(""price_tick""):    await self._md_send_chan.send(_query_for_quote(symbol))   async for _ in quote_chan:    quote_chan.task_done()    if quote.get(""price_tick"") == quote.get(""price_tick""):     return quote.copy()  async def _ensure_quote(self, symbol, quote_chan):   """"""quote收到行情以及合约信息后返回""""""   quote = _get_obj(self._data, [""quotes"", symbol], Quote(self._api))   _register_update_chan(quote, quote_chan)   if quote.get(""datetime"", """") and quote.get(""price_tick"") == quote.get(""price_tick""):    return quote.copy()   if quote.get(""price_tick"") != quote.get(""price_tick""):    # 对于没有合约信息的 quote，发送查询合约信息的请求    await self._md_send_chan.send(_query_for_quote(symbol))   async for _ in quote_chan:    quote_chan.task_done()    if quote.get(""datetime"", """") and quote.get(""price_tick"") == quote.get(""price_tick""):     return quote.copy()  async def _quote_handler(self, symbol, quote_chan, order_chan):   try:    await self._subscribe_quote(symbol)    quote = await self._ensure_quote(symbol, quote_chan)    if quote[""ins_class""].endswith(""INDEX"") and quote[""exchange_id""] == ""KQ"":     # 指数可以交易，需要补充 margin commission     if ""margin"" not in quote:      quote_m = await self._ensure_quote_info(symbol.replace(""KQ.i"", ""KQ.m""), quote_chan)      quote_underlying = await self._ensure_quote_info(quote_m[""underlying_symbol""], quote_chan)      self._data[""quotes""][symbol][""margin""] = quote_underlying[""margin""]      self._data[""quotes""][symbol][""commission""] = quote_underlying[""commission""]      quote.update(self._data[""quotes""][symbol])    underlying_quote = None    if quote[""ins_class""].endswith(""OPTION""):     # 如果是期权，订阅标的合约行情，确定收到期权标的合约行情     underlying_symbol = quote[""underlying_symbol""]     await self._subscribe_quote(underlying_symbol)     underlying_quote = await self._ensure_quote(underlying_symbol, quote_chan) # 订阅合约    # 在等待标的行情的过程中，quote_chan 可能有期权行情，把 quote_chan 清空，并用最新行情更新 quote    while not quote_chan.empty():     quote_chan.recv_nowait()     quote_chan.task_done()    # 用最新行情更新 quote    quote.update(self._data[""quotes""][symbol])    if underlying_quote:     underlying_quote.update(self._data[""quotes""][underlying_symbol])    task = self._api.create_task(self._forward_chan_handler(order_chan, quote_chan))    quotes = {symbol: quote}    if underlying_quote:     quotes[underlying_symbol] = underlying_quote    self._sim_trade.update_quotes(symbol, {""quotes"": quotes})    async for pack in quote_chan:     if ""aid"" not in pack:      diffs, orders_events = self._sim_trade.update_quotes(symbol, pack)      self._handle_diffs(diffs, orders_events, ""match order"")     elif pack[""aid""] == ""insert_order"":      diffs, orders_events = self._sim_trade.insert_order(symbol, pack)      self._handle_diffs(diffs, orders_events, ""insert order"")      await self._send_diff()     elif pack[""aid""] == ""cancel_order"":      diffs, orders_events = self._sim_trade.cancel_order(symbol, pack)      self._handle_diffs(diffs, orders_events, ""cancel order"")      await self._send_diff()     quote_chan.task_done()   finally:    await quote_chan.close()    await order_chan.close()    task.cancel()    await asyncio.gather(task, return_exceptions=True)  async def _forward_chan_handler(self, chan_from, chan_to):   async for pack in chan_from:    await chan_to.send(pack)  def _md_recv(self, pack):   for d in pack[""data""]:    self._diffs.append(d)    # 在第一次收到 mdhis_more_data 为 False 的时候，发送账户初始截面信息，这样回测模式下，往后的模块才有正确的时间顺序    if not self._has_send_init_account and not d.get(""mdhis_more_data"", True):     self._diffs.append(self._sim_trade.init_snapshot())     self._diffs.append({      ""trade"": {       self._account_key: {        ""trade_more_data"": False       }      }     })     self._has_send_init_account = True    _tqsdk_backtest = d.get(""_tqsdk_backtest"", {})    if _tqsdk_backtest:     # 回测时，用 _tqsdk_backtest 对象中 current_dt 作为 TqSim 的 _current_datetime     self._tqsdk_backtest.update(_tqsdk_backtest)     self._current_datetime = datetime.fromtimestamp(      self._tqsdk_backtest[""current_dt""] / 1e9).strftime(""%Y-%m-%d %H:%M:%S.%f"")     self._local_time_record = float(""nan"")     # 1. 回测时不使用时间差来模拟交易所时间的原因(_local_time_record始终为初始值nan)：     # 在sim收到行情后记录_local_time_record，然后下发行情到api进行merge_diff(),api需要处理完k线和quote才能结束wait_update(),     # 若处理时间过长，此时下单则在判断下单时间时与测试用例中的预期时间相差较大，导致测试用例无法通过。     # 2. 回测不使用时间差的方法来判断下单时间仍是可行的: 与使用了时间差的方法相比, 只对在每个交易时间段最后一笔行情时的下单时间判断有差异,     # 若不使用时间差, 则在最后一笔行情时下单仍判断为在可交易时间段内, 且可成交.    quotes_diff = d.get(""quotes"", {})    # 先根据 quotes_diff 里的 datetime, 确定出 _current_datetime，再 _merge_diff(同时会发送行情到 quote_chan)    for symbol, quote_diff in quotes_diff.items():     if quote_diff is None:      continue     # 若直接使用本地时间来判断下单时间是否在可交易时间段内 可能有较大误差,因此判断的方案为:(在接收到下单指令时判断 估计的交易所时间 是否在交易时间段内)     # 在更新最新行情时间(即self._current_datetime)时，记录当前本地时间(self._local_time_record)，     # 在这之后若收到下单指令，则获取当前本地时间,判 ""最新行情时间 + (当前本地时间 - 记录的本地时间)"" 是否在交易时间段内。     # 另外, 若在盘后下单且下单前未订阅此合约：     # 因为从_md_recv()中获取数据后立即判断下单时间则速度过快(两次time.time()的时间差小于最后一笔行情(14:59:9995)到15点的时间差),     # 则会立即成交,为处理此情况则将当前时间减去5毫秒（模拟发生5毫秒网络延迟，则两次time.time()的时间差增加了5毫秒）。     # todo: 按交易所来存储 _current_datetime(issue： #277)     if quote_diff.get(""datetime"", """") > self._current_datetime:      # 回测时，当前时间更新即可以由 quote 行情更新，也可以由 _tqsdk_backtest.current_dt 更新，      # 在最外层的循环里，_tqsdk_backtest.current_dt 是在 rtn_data.data 中数组位置中的最后一个，会在循环最后一个才更新 self.current_datetime      # 导致前面处理 order 时的 _current_datetime 还是旧的行情时间      self._current_datetime = quote_diff[""datetime""] # 最新行情时间      # 更新最新行情时间时的本地时间，回测时不使用时间差      self._local_time_record = (time.time() - 0.005) if not self._tqsdk_backtest else float(""nan"")     if self._current_datetime > self._trading_day_end: # 结算      self._settle()      # 若当前行情时间大于交易日的结束时间(切换交易日)，则根据此行情时间更新交易日及交易日结束时间      trading_day = _get_trading_day_from_timestamp(self._get_current_timestamp())      self._trading_day_end = datetime.fromtimestamp(       (_get_trading_day_end_time(trading_day) - 999) / 1e9).strftime(""%Y-%m-%d %H:%M:%S.%f"")    if quotes_diff:     _merge_diff(self._data, {""quotes"": quotes_diff}, self._prototype, False, True)  def _handle_diffs(self, diffs, orders_events, msg):   """"""   处理 sim_trade 返回的 diffs   orders_events 为持仓变更事件，依次屏幕输出信息，打印日志   """"""   self._diffs += diffs   for order in orders_events:    if order[""status""] == ""FINISHED"":     self._handle_on_finished(msg, order)    else:     assert order[""status""] == ""ALIVE""     self._handle_on_alive(msg, order)  def _handle_on_alive(self, msg, order):   """"""   在 order 状态变为 ALIVE 调用，屏幕输出信息，打印日志   """"""   symbol = f""{order['exchange_id']}.{order['instrument_id']}""   self._api._print(    f""模拟交易下单 {order['order_id']}: 时间: {_format_from_timestamp_nano(order['insert_date_time'])}, ""    f""合约: {symbol}, 开平: {order['offset']}, 方向: {order['direction']}, 手数: {order['volume_left']}, ""    f""价格: {order.get('limit_price', '市价')}"")   self._logger.debug(msg, order_id=order[""order_id""], datetime=order[""insert_date_time""],       symbol=symbol, offset=order[""offset""], direction=order[""direction""],       volume_left=order[""volume_left""], limit_price=order.get(""limit_price"", ""市价""))  def _handle_on_finished(self, msg, order):   """"""   在 order 状态变为 FINISHED 调用，屏幕输出信息，打印日志   """"""   self._api._print(f""模拟交易委托单 {order['order_id']}: {order['last_msg']}"")   self._logger.debug(msg, order_id=order[""order_id""], last_msg=order[""last_msg""], status=order[""status""],       volume_orign=order[""volume_orign""], volume_left=order[""volume_left""])  def _settle(self):   if self._trading_day_end[:10] == ""1990-01-01"":    return   # 结算并记录账户截面   diffs, orders_events, trade_log = self._sim_trade.settle()   self._handle_diffs(diffs, orders_events, ""settle"")   self.trade_log[self._trading_day_end[:10]] = trade_log  def _report(self):   if not self.trade_log:    return   date_keys = sorted(self.trade_log.keys())   self._api._print(""模拟交易成交记录"")   for d in date_keys:    for t in self.trade_log[d][""trades""]:     symbol = t[""exchange_id""] + ""."" + t[""instrument_id""]     self._api._print(f""时间: {_format_from_timestamp_nano(t['trade_date_time'])}, 合约: {symbol}, ""         f""开平: {t['offset']}, 方向: {t['direction']}, 手数: {t['volume']}, 价格: {t['price']:.3f},""         f""手续费: {t['commission']:.2f}"")   self._api._print(""模拟交易账户资金"")   for d in date_keys:    account = self.trade_log[d][""account""]    self._api._print(     f""日期: {d}, 账户权益: {account['balance']:.2f}, 可用资金: {account['available']:.2f}, ""     f""浮动盈亏: {account['float_profit']:.2f}, 持仓盈亏: {account['position_profit']:.2f}, ""     f""平仓盈亏: {account['close_profit']:.2f}, 市值: {account['market_value']:.2f}, ""     f""保证金: {account['margin']:.2f}, 手续费: {account['commission']:.2f}, ""     f""风险度: {account['risk_ratio'] * 100:.2f}%"")   # TqReport 模块计算交易统计信息   report = TqReport(report_id=self._account_id, trade_log=self.trade_log, quotes=self._data['quotes'])   self.tqsdk_stat = report.default_metrics   self._api._print(    f""胜率: {self.tqsdk_stat['winning_rate'] * 100:.2f}%, 盈亏额比例: {self.tqsdk_stat['profit_loss_ratio']:.2f}, ""    f""收益率: {self.tqsdk_stat['ror'] * 100:.2f}%, 年化收益率: {self.tqsdk_stat['annual_yield'] * 100:.2f}%, ""    f""最大回撤: {self.tqsdk_stat['max_drawdown'] * 100:.2f}%, 年化夏普率: {self.tqsdk_stat['sharpe_ratio']:.4f},""    f""年化索提诺比率: {self.tqsdk_stat['sortino_ratio']:.4f}"")   # 回测情况下，在计算报告之后，还会发送绘制图表请求，   # 这样处理，用户不要修改代码，就能够看到报告图表   if self._tqsdk_backtest:    self._api.draw_report(report.full())  def _get_current_timestamp(self):   return int(datetime.strptime(self._current_datetime, ""%Y-%m-%d %H:%M:%S.%f"").timestamp() * 1e6) * 1000  def _get_trade_timestamp(self):   return _get_trade_timestamp(self._current_datetime, self._local_time_record)  def _is_in_trading_time(self, quote):   return _is_in_trading_time(quote, self._current_datetime, self._local_time_record) "
179,n\tqsdk\tools\downloade,"n\tqsdk\tools\downloade. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'yangyang' import asyncio import csv import os from datetime import date, datetime from encodings.utf_8 import StreamWriter from typing import Union, List, Optional import lzma import pandas from tqsdk.api import TqApi from tqsdk.channel import TqChan from tqsdk.datetime import _get_trading_day_start_time, _get_trading_day_end_time, _datetime_to_timestamp_nano from tqsdk.diff import _get_obj from tqsdk.tafunc import get_dividend_df, get_dividend_factor from tqsdk.utils import _generate_uuid try:  file_path = os.path.split(os.path.abspath(__file__))[0]  with lzma.open(os.path.join(file_path, ""dead_ins.lzma""), ""rt"", encoding=""utf-8"") as dead_ins_file:   DEAD_INS = {l.strip() for l in dead_ins_file} except:  DEAD_INS = {} # 价格相关的字段，需要 format 数据格式 PRICE_KEYS = [""open"", ""high"", ""low"", ""close"", ""last_price"", ""highest"", ""lowest""] + [f""bid_price{i}"" for i in range(1, 6)] + [f""ask_price{i}"" for i in range(1, 6)] class DataDownloader:  """"""  数据下载工具是 TqSdk 专业版中的功能，能让用户下载目前 TqSdk 提供的全部期货、期权和股票类的历史数据，下载数据支持 tick 级别精度和任意 kline 周期  如果想使用数据下载工具，可以点击 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_ 申请使用或购买  历史数据下载器, 输出到csv文件  多合约按时间横向对齐  """"""  def __init__(self, api: TqApi, symbol_list: Union[str, List[str]], dur_sec: int, start_dt: Union[date, datetime],     end_dt: Union[date, datetime], csv_file_name: Union[str, asyncio.StreamWriter],     adj_type: Union[str, None] = None) -> None:   """"""   创建历史数据下载器实例   Args:    api (TqApi): TqApi实例，该下载器将使用指定的api下载数据    symbol_list (str/list of str): 需要下载数据的合约代码，当指定多个合约代码时将其他合约按第一个合约的交易时间对齐    dur_sec (int): 数据周期，以秒为单位。例如: 1分钟线为60,1小时线为3600,日线为86400,Tick数据为0    start_dt (date/datetime): 起始时间, 如果类型为 date 则指的是交易日, 如果为 datetime 则指的是具体时间点    end_dt (date/datetime): 结束时间, 如果类型为 date 则指的是交易日, 如果为 datetime 则指的是具体时间点    csv_file_name (str/StreamWriter): [必填]输出方式:     * str : 输出 csv 的文件名     * StreamWriter: 直接将内容输出到 StreamWriter    adj_type (str/None): 复权计算方式，默认值为 None。""F"" 为前复权；""B"" 为后复权；None 表示不复权。只对股票、基金合约有效。   Example::    from datetime import datetime, date    from contextlib import closing    from tqsdk import TqApi, TqAuth, TqSim    from tqsdk.tools import DataDownloader    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    download_tasks = {}    # 下载从 2018-01-01 到 2018-09-01 的 SR901 日线数据    download_tasks[""SR_daily""] = DataDownloader(api, symbol_list=""CZCE.SR901"", dur_sec=24*60*60,         start_dt=date(2018, 1, 1), end_dt=date(2018, 9, 1), csv_file_name=""SR901_daily.csv"")    # 下载从 2017-01-01 到 2018-09-01 的 rb主连 5分钟线数据    download_tasks[""rb_5min""] = DataDownloader(api, symbol_list=""KQ.m@SHFE.rb"", dur_sec=5*60,         start_dt=date(2017, 1, 1), end_dt=date(2018, 9, 1), csv_file_name=""rb_5min.csv"")    # 下载从 2018-01-01凌晨6点 到 2018-06-01下午4点 的 cu1805,cu1807,IC1803 分钟线数据，所有数据按 cu1805 的时间对齐    # 例如 cu1805 夜盘交易时段, IC1803 的各项数据为 N/A    # 例如 cu1805 13:00-13:30 不交易, 因此 IC1803 在 13:00-13:30 之间的K线数据会被跳过    download_tasks[""cu_min""] = DataDownloader(api, symbol_list=[""SHFE.cu1805"", ""SHFE.cu1807"", ""CFFEX.IC1803""], dur_sec=60,         start_dt=datetime(2018, 1, 1, 6, 0 ,0), end_dt=datetime(2018, 6, 1, 16, 0, 0), csv_file_name=""cu_min.csv"")    # 下载从 2018-05-01凌晨0点 到 2018-06-01凌晨0点 的 T1809 盘口Tick数据    download_tasks[""T_tick""] = DataDownloader(api, symbol_list=[""CFFEX.T1809""], dur_sec=0,         start_dt=datetime(2018, 5, 1), end_dt=datetime(2018, 6, 1), csv_file_name=""T1809_tick.csv"")    # 使用with closing机制确保下载完成后释放对应的资源    with closing(api):     while not all([v.is_finished() for v in download_tasks.values()]):      api.wait_update()      print(""progress: "", { k:(""%.2f%%"" % v.get_progress()) for k,v in download_tasks.items() })   """"""   self._api = api   if not self._api._auth._has_feature(""tq_dl""):    raise Exception(""您的账户不支持下载历史数据功能，需要购买专业版本后使用。升级网址：https://account.shinnytech.com"")   if isinstance(start_dt, datetime):    self._start_dt_nano = _datetime_to_timestamp_nano(start_dt)   else:    self._start_dt_nano = _get_trading_day_start_time(_datetime_to_timestamp_nano(datetime(start_dt.year, start_dt.month, start_dt.day)))   if isinstance(end_dt, datetime):    self._end_dt_nano = _datetime_to_timestamp_nano(end_dt)   else:    self._end_dt_nano = _get_trading_day_end_time(_datetime_to_timestamp_nano(datetime(end_dt.year, end_dt.month, end_dt.day)))   self._current_dt_nano = self._start_dt_nano   self._symbol_list = symbol_list if isinstance(symbol_list, list) else [symbol_list]   # 下载合约超时时间（默认 30s），已下市的没有交易的合约，超时时间可以设置短一点（2s），用户不希望自己的程序因为没有下载到数据而中断   self._timeout_seconds = 2 if any([symbol in DEAD_INS for symbol in self._symbol_list]) else 30   self._dur_nano = dur_sec * 1000000000   if self._dur_nano == 0 and len(self._symbol_list) != 1:    raise Exception(""Tick序列不支持多合约"")   if adj_type not in [None, ""F"", ""B"", ""FORWARD"", ""BACK""]:    raise Exception(""adj_type 参数只支持 None (不复权) ｜ 'F' (前复权) ｜ 'B' (后复权)"")   self._adj_type = adj_type[0] if adj_type else adj_type   if isinstance(csv_file_name, str) or isinstance(csv_file_name, asyncio.StreamWriter):    self._csv_file_name = csv_file_name   else:    raise Exception(""csv_file_name 参数只支持 str ｜ StreamWriter 类型"")   self._csv_header = self._get_headers()   # 缓存合约对应的复权系数矩阵，每个合约只计算一次   # 含义为截止 datetime 之前(不包含) 应使用 factor 复权   self._dividend_cache = {}   self._data_series = None   self._task = self._api.create_task(self._run())  def is_finished(self) -> bool:   """"""   判断是否下载完成   Returns:    bool: 如果数据下载完成则返回 True, 否则返回 False.   """"""   return self._task.done()  def get_progress(self) -> float:   """"""   获得下载进度百分比   Returns:    float: 下载进度,100表示下载完成   """"""   return 100.0 if self._task.done() else (self._current_dt_nano - self._start_dt_nano) / (     self._end_dt_nano - self._start_dt_nano) * 100  def _get_data_series(self) -> Optional[pandas.DataFrame]:   """"""   获取下载的 DataFrame 格式数据   todo: 在 utils 中增加工具函数，返回与 kline 一致的数据结构   Returns:    pandas.DataFrame/None: 下载的 klines 或者 ticks 数据，DataFrame 格式。下载完成前返回 None。   Example::    from datetime import datetime, date    rom tqsdk import TqApi, TqAuth    from contextlib import closing    from tqsdk.tools import DataDownloader    api = TqApi(auth=TqAuth(""信易账户"", ""账户密码""))    # 下载从 2018-06-01 到 2018-09-01 的 SR901 日线数据    download_task = DataDownloader(api, symbol_list=""CZCE.SR901"", dur_sec=24*60*60,         start_dt=date(2018, 6, 1), end_dt=date(2018, 9, 1), csv_file_name=""klines.csv"")    # 使用with closing机制确保下载完成后释放对应的资源    with closing(api):     while not download_task.is_finished():      api.wait_update()      print(f""progress: {download_task.get_progress():.2} %"")     print(download_task._get_data_series())   """"""   if not self._task.done():    return None   if isinstance(self._csv_file_name, str):    if not self._data_series:     self._data_series = pandas.read_csv(self._csv_file_name)    return self._data_series   else:    raise Exception('DataDownloader._get_data_series 接口仅支持 csv_file_name 參數为 str 时使用')  async def _ensure_dividend_factor(self, quote, timestamp):   if quote.instrument_id not in self._dividend_cache:    # 对每个除权除息矩阵增加 factor 序列，为当日的复权因子    df = get_dividend_df(quote.stock_dividend_ratio, quote.cash_dividend_ratio)    df = df[df[""datetime""].between(timestamp, self._end_dt_nano, inclusive=""right"")] # 只需要第一笔行情时间～结束时间之间的复权因子, 左开右闭    df[""pre_close""] = float('nan') # 初始化 pre_close 为 nan    for i in range(len(df)):     chart_info = {      ""aid"": ""set_chart"",      ""chart_id"": _generate_uuid(""PYSDK_downloader""),      ""ins_list"": quote.instrument_id,      ""duration"": 86400 * 1000000000,      ""view_width"": 2,      ""focus_datetime"": int(df[""datetime""].iloc[i]),      ""focus_position"": 1     }     await self._api._send_chan.send(chart_info)     chart = _get_obj(self._api._data, [""charts"", chart_info[""chart_id""]])     serial = _get_obj(self._api._data, [""klines"", quote.instrument_id, str(86400000000000)])     try:      async with self._api.register_update_notify() as update_chan:       async for _ in update_chan:        if not (chart_info.items() <= _get_obj(chart, [""state""]).items()):         continue # 当前请求还没收齐回应, 不应继续处理        left_id = chart.get(""left_id"", -1)        right_id = chart.get(""right_id"", -1)        if (left_id == -1 and right_id == -1) or self._api._data.get(""mdhis_more_data"", True) or serial.get(""last_id"", -1) == -1:         continue # 定位信息还没收到, 或数据序列还没收到, 合约的数据是否收到        last_item = serial[""data""].get(str(left_id), {})        # 复权时间点的昨收盘        df.loc[i, 'pre_close'] = last_item['close'] if last_item.get('close') else float('nan')        break     finally:      await self._api._send_chan.send({       ""aid"": ""set_chart"",       ""chart_id"": chart_info[""chart_id""],       ""ins_list"": """",       ""duration"": 86400000000000,       ""view_width"": 2      })    df[""factor""] = (df[""pre_close""] - df[""cash_dividend""]) / df[""pre_close""] / (1 + df[""stock_dividend""])    df[""factor""].fillna(1.0, inplace=True)    # 插入结束时间这条记录, 因为可能存在行情时间等于 _end_dt_nano 的行情，因此这里 +1    df = df.append({""datetime"": self._end_dt_nano+1, ""factor"": 1.0}, ignore_index=True)    if self._adj_type == ""F"":     df[""factor""] = df[""factor""].iloc[::-1].cumprod().iloc[::-1]    elif self._adj_type == ""B"":     # 后复权按定义上应该从第一笔行情之后产生的复权事件开始     # 第一笔行情时间一定小于 df[""datetime""].iloc[0], 因此复权是从 df[""datetime""].iloc[0] 开始     df[""factor""] = 1.0 / df[""factor""].cumprod()     # 至此 df 每行的含义为从 datetime 开始应使用 factor 复权     # 该格式并不好用，需要改为截止 datetime 之前(不包含) 应使用 factor 复权     df[""factor""] = df[""factor""].shift(1)     df[""factor""].iloc[0] = 1.0    self._dividend_cache[quote.instrument_id] = {     ""df"": df,     ""last_dt"": 0,     ""factor"": float(""nan""),    }  async def _run(self):   self._quote_list = await self._api.get_quote_list(self._symbol_list)   # 下载数据的 async generator   gen = self._download_data()   # cols 是复权需要重新计算的列名   index_datetime_nano = self._csv_header.index(""datetime_nano"")   if self._dur_nano != 0:    cols = [""open"", ""high"", ""low"", ""close""]   else:    cols = [""last_price"", ""highest"", ""lowest""]    cols.extend(f""{x}{i}"" for x in [""bid_price"", ""ask_price""] for i in range(1, 6))   try:    if isinstance(self._csv_file_name, asyncio.StreamWriter):     writer = StreamWriter(self._csv_file_name)    else:     writer = open(self._csv_file_name, 'w', newline='')    csv_writer = csv.writer(writer, dialect='excel')    csv_writer.writerow(self._csv_header)    async for item in gen:     for quote in self._quote_list:      symbol = quote.instrument_id      if self._adj_type and quote.ins_class in [""STOCK"", ""FUND""]:       # 如果存在 STOCK / FUND 并且 adj_type is not None, 这里需要提前准备下载时间段内的复权因子       # 前复权需要提前计算除权因子       await self._ensure_dividend_factor(quote, item[index_datetime_nano])       dividend_cache = self._dividend_cache[symbol]       # dividend_df 和 _data_chan 中取出的数据都是按时间升序排列的，因此可以使用归并算法       if dividend_cache[""last_dt""] <= item[index_datetime_nano]:        dividend_df = dividend_cache[""df""]        dividend_df = dividend_df[dividend_df[""datetime""].gt(item[index_datetime_nano])]        dividend_cache[""df""] = dividend_df        dividend_cache[""last_dt""] = dividend_df[""datetime""].iloc[0]        dividend_cache[""factor""] = dividend_df[""factor""].iloc[0]       if dividend_cache[""factor""] != 1:        item = item.copy()        for c in cols: # datetime_nano         index = self._csv_header.index(f""{symbol}.{c}"")         item[index] = item[index] * dividend_cache[""factor""]     csv_writer.writerow(item)     if isinstance(self._csv_file_name, asyncio.StreamWriter):      await self._csv_file_name.drain()   finally:    if isinstance(self._csv_file_name, asyncio.StreamWriter):     self._csv_file_name.write_eof()    else:     writer.close()    # 这里 `await gen.aclose()` 实际测试代码与文档描述不符，无论文件全部下载完正常退出还是写文件过程中抛出例外退出，都没有再抛出任何例外    # https://docs.python.org/3/reference/expressions.html#agen.aclose    await gen.aclose()  async def _timeout_handle(self, timeout, chart):   await asyncio.sleep(timeout)   if chart.get(""left_id"", -1) == -1 and chart.get(""right_id"", -1) == -1:    self._task.cancel()  async def _download_data(self):   """"""下载数据, 多合约横向按时间对齐""""""   chart_info = {    ""aid"": ""set_chart"",    ""chart_id"": _generate_uuid(""PYSDK_downloader""),    ""ins_list"": "","".join(self._symbol_list),    ""duration"": self._dur_nano,    ""view_width"": 2000,    ""focus_datetime"": self._start_dt_nano,    ""focus_position"": 0,   }   # 还没有发送过任何请求, 先请求定位左端点   await self._api._send_chan.send(chart_info)   chart = _get_obj(self._api._data, [""charts"", chart_info[""chart_id""]])   # 增加一个 task，在 30s 后检查 chart 是否返回了左右 id 范围，如果没有就 cancel self._task，防止程序一直卡在那里   timeout_task = self._api.create_task(self._timeout_handle(self._timeout_seconds, chart))   current_id = None # 当前数据指针   data_cols = self._get_data_cols()   serials = []   for symbol in self._symbol_list:    path = [""klines"", symbol, str(self._dur_nano)] if self._dur_nano != 0 else [""ticks"", symbol]    serial = _get_obj(self._api._data, path)    serials.append(serial)   try:    async with self._api.register_update_notify() as update_chan:     async for _ in update_chan:      if not (chart_info.items() <= _get_obj(chart, [""state""]).items()):       # 当前请求还没收齐回应, 不应继续处理       continue      left_id = chart.get(""left_id"", -1)      right_id = chart.get(""right_id"", -1)      if (left_id == -1 and right_id == -1) or chart.get(""more_data"", True):       # 定位信息还没收到, 或数据序列还没收到       continue      # 检查合约的数据是否收到      if any([serial.get(""last_id"", -1) == -1 for serial in serials]):       continue      if current_id is None:       current_id = max(left_id, 0)      while current_id <= right_id:       item = serials[0][""data""].get(str(current_id), {})       if item.get(""datetime"", 0) == 0 or item[""datetime""] > self._end_dt_nano:        # 当前 id 已超出 last_id 或k线数据的时间已经超过用户限定的右端        return       row = [self._nano_to_str(item[""datetime""]), item[""datetime""]]       for col in data_cols:        row.append(self._get_value(item, col, self._quote_list[0][""price_decs""]))       for i in range(1, len(self._symbol_list)):        symbol = self._symbol_list[i]        tid = serials[0].get(""binding"", {}).get(symbol, {}).get(str(current_id), -1)        k = {} if tid == -1 else serials[i][""data""].get(str(tid), {})        for col in data_cols:         row.append(self._get_value(k, col, self._quote_list[i][""price_decs""]))       yield row       current_id += 1       self._current_dt_nano = item[""datetime""]      # 当前 id 已超出订阅范围, 需重新订阅后续数据      chart_info.pop(""focus_datetime"", None)      chart_info.pop(""focus_position"", None)      chart_info[""left_kline_id""] = current_id      await self._api._send_chan.send(chart_info)   finally:    # 释放chart资源    await self._api._send_chan.send({     ""aid"": ""set_chart"",     ""chart_id"": chart_info[""chart_id""],     ""ins_list"": """",     ""duration"": self._dur_nano,     ""view_width"": 2000,    })    timeout_task.cancel()    await asyncio.gather(timeout_task, return_exceptions=True)  def _get_headers(self):   data_cols = self._get_data_cols()   return [""datetime"", ""datetime_nano""] + [f""{symbol}.{col}"" for symbol in self._symbol_list for col in data_cols]  def _get_data_cols(self):   if self._dur_nano != 0:    return [""open"", ""high"", ""low"", ""close"", ""volume"", ""open_oi"", ""close_oi""]   else:    cols = [""last_price"", ""highest"", ""lowest"", ""average"", ""volume"", ""amount"", ""open_interest""]    price_range = 1    for symbol in self._symbol_list:     if symbol.split('.')[0] in {""SHFE"", ""INE"", ""SSE"", ""SZSE""}:      price_range = 5      break    for i in range(price_range):     cols.extend(f""{x}{i+1}"" for x in [""bid_price"", ""bid_volume"", ""ask_price"", ""ask_volume""])    return cols  @staticmethod  def _get_value(obj, key, price_decs):   try:    if key in PRICE_KEYS:     return round(obj[key], price_decs)    else:     return obj[key]   except KeyError:    return ""#N/A""   except TypeError:    return float(""nan"")  @staticmethod  def _nano_to_str(nano):   dt = datetime.fromtimestamp(nano // 1000000000)   return ""%d-%02d-%02d %02d:%02d:%02d.%09d"" % (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, int(nano) % 1000000000) "
180,n\tqsdk\tools\  init ,n\tqsdk\tools\  init . #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'chengzhi' from tqsdk.tools.downloader import DataDownloader 
181,n\tqsdk\tradeable\interfac,"n\tqsdk\tradeable\interfac. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' from typing import Optional, Union from tqsdk.diff import _get_obj from tqsdk.entity import Entity from tqsdk.objs import Account, Order, Trade, Position, SecurityAccount, SecurityOrder, SecurityTrade, SecurityPosition def _get_api_instance(self):  if hasattr(self, '_api'):   return self._api  import inspect  raise Exception(f""未初始化 TqApi。请在 api 初始化后调用 {inspect.stack()[1].function}。"") class IFuture:  def get_account(self) -> Account:   """"""   获取用户账户资金信息   Returns:    :py:class:`~tqsdk.objs.Account`: 返回一个账户对象引用. 其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新   Example1::    # 获取当前浮动盈亏    from tqsdk import TqApi, TqAuth    tqacc = TqAccount(""N南华期货"", ""123456"", ""123456"")    api = TqApi(account=tqacc, auth=TqAuth(""信易账户"", ""账户密码""))    account = tqacc.get_account()    print(account.float_profit)    # 预计的输出是这样的:    2180.0    ...   Example2::    # 多账户模式下, 分别获取各账户浮动盈亏    from tqsdk import TqApi, TqAuth, TqMultiAccount, TqAccount, TqKq, TqSim    account = TqAccount(""N南华期货"", ""123456"", ""123456"")    tqkq = TqKq()    tqsim = TqSim()    api = TqApi(TqMultiAccount([account, tqkq, tqsim]), auth=TqAuth(""信易账户"", ""账户密码""))    account1 = account.get_account()    account2 = tqkq.get_account()    account3 = tqsim.get_account()    print(f""账户 1 浮动盈亏 {account1.float_profit}, 账户 2 浮动盈亏 {account2.float_profit}, 账户 3 浮动盈亏 {account3.float_profit}"")    api.close()   """"""   api = _get_api_instance(self)   return _get_obj(api._data, [""trade"", self._account_key, ""accounts"", ""CNY""], Account(api))  def get_position(self, symbol: Optional[str] = None) -> Union[Position, Entity]:   """"""   获取用户持仓信息   Args:    symbol (str): [可选]合约代码, 不填则返回所有持仓   Returns:    :py:class:`~tqsdk.objs.Position`: 当指定了 symbol 时, 返回一个持仓对象引用。    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新。    不填 symbol 参数调用本函数, 将返回包含用户所有持仓的一个 ``tqsdk.objs.Entity`` 对象引用, 使用方法与dict一致, \    其中每个元素的 key 为合约代码, value 为 :py:class:`~tqsdk.objs.Position`。    注意: 为保留一些可供用户查询的历史信息, 如 volume_long_yd(本交易日开盘前的多头持仓手数) 等字段, 因此服务器会返回当天已平仓合约( pos_long 和 pos_short 等字段为0)的持仓信息   Example1::    # 获取 DCE.m2109 当前浮动盈亏    from tqsdk import TqApi, TqAuth, TqAccount    tqacc = TqAccount(""N南华期货"", ""123456"", ""123456"")    api = TqApi(account=tqacc, auth=TqAuth(""信易账户"", ""账户密码""))    position = tqacc.get_position(""DCE.m2109"")    print(position.float_profit_long + position.float_profit_short)    while api.wait_update():     print(position.float_profit_long + position.float_profit_short)    # 预计的输出是这样的:    300.0    330.0    ...   Example2::    # 多账户模式下, 分别获取各账户浮动盈亏    from tqsdk import TqApi, TqAuth, TqMultiAccount, TqAccount, TqKq, TqSim    account = TqAccount(""N南华期货"", ""123456"", ""123456"")    tqkq = TqKq()    tqsim = TqSim()    api = TqApi(TqMultiAccount([account, tqkq, tqsim]), auth=TqAuth(""信易账户"", ""账户密码""))    position1 = account.get_position(""DCE.m2101"")    position2 = tqkq.get_position(""DCE.m2101"")    position3 = tqsim.get_position(""DCE.m2101"")    print(f""账户 1 'DCE.m2101' 浮动盈亏 {position1.float_profit_long + position1.float_profit_short}, "",     f""账户 2 'DCE.m2101' 浮动盈亏 {position2.float_profit_long + position2.float_profit_short}, "",     f""账户 3 'DCE.m2101' 浮动盈亏 {position3.float_profit_long + position3.float_profit_short}"")    api.close()   """"""   api = _get_api_instance(self)   if symbol:    return _get_obj(api._data, [""trade"", self._account_key, ""positions"", symbol], Position(api))   return _get_obj(api._data, [""trade"", self._account_key, ""positions""])  def get_order(self, order_id: Optional[str] = None) -> Union[Order, Entity]:   """"""   获取用户委托单信息   Args:    order_id (str): [可选]单号, 不填单号则返回所有委托单   Returns:    :py:class:`~tqsdk.objs.Order`: 当指定了 order_id 时, 返回一个委托单对象引用。 \    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新。    不填 order_id 参数调用本函数, 将返回包含用户所有委托单的一个 ``tqsdk.objs.Entity`` 对象引用, \    使用方法与dict一致, 其中每个元素的key为委托单号, value为 :py:class:`~tqsdk.objs.Order`    注意: 在刚下单后, tqsdk 还没有收到回单信息时, 此对象中各项内容为空   Example1::    # 获取当前总挂单手数    from tqsdk import TqApi, TqAuth    tqacc = TqAccount(""N南华期货"", ""123456"", ""123456"")    api = TqApi(account=tqacc, auth=TqAuth(""信易账户"", ""账户密码""))    orders = tqacc.get_order()    while True:     api.wait_update()     print(sum(order.volume_left for oid, order in orders.items() if order.status == ""ALIVE""))    # 预计的输出是这样的:    3    3    0    ...   Example2::    # 多账户模式下, 分别获取各账户挂单手数    from tqsdk import TqApi, TqAuth, TqMultiAccount, TqAccount, TqKq, TqSim    account = TqAccount(""N南华期货"", ""123456"", ""123456"")    tqkq = TqKq()    tqsim = TqSim()    api = TqApi(TqMultiAccount([account, tqkq, tqsim]), auth=TqAuth(""信易账户"", ""账户密码""))    orders1 = account.get_order()    orders2 = tqkq.get_order()    orders3 = tqsim.get_order()    print(f""账户 1 挂单手数 {sum(order.volume_left for order in orders1.values() if order.status == ""ALIVE"")}, "",     f""账户 2 挂单手数 {sum(order.volume_left for order in orders2.values() if order.status == ""ALIVE"")}, "",     f""账户 3 挂单手数 {sum(order.volume_left for order in orders3.values() if order.status == ""ALIVE"")}"")    order = account.get_order(order_id=""订单号"")    print(order)    api.close()   """"""   api = _get_api_instance(self)   if order_id:    return _get_obj(api._data, [""trade"", self._account_key, ""orders"", order_id], Order(api))   return _get_obj(api._data, [""trade"", self._account_key, ""orders""])  def get_trade(self, trade_id: Optional[str] = None) -> Union[Trade, Entity]:   """"""   获取用户成交信息   Args:    trade_id (str): [可选]成交号, 不填成交号则返回所有委托单   Returns:    :py:class:`~tqsdk.objs.Trade`: 当指定了trade_id时, 返回一个成交对象引用. \    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新.    不填trade_id参数调用本函数, 将返回包含用户当前交易日所有成交记录的一个tqsdk.objs.Entity对象引用, 使用方法与dict一致, \    其中每个元素的key为成交号, value为 :py:class:`~tqsdk.objs.Trade`    推荐优先使用 :py:meth:`~tqsdk.objs.Order.trade_records` 获取某个委托单的相应成交记录, 仅当确有需要时才使用本函数.   Example::    # 多账户模式下, 分别获取各账户的成交记录    from tqsdk import TqApi, TqAuth, TqMultiAccount    account = TqAccount(""N南华期货"", ""123456"", ""123456"")    tqkq = TqKq()    tqsim = TqSim()    api = TqApi(TqMultiAccount([account, tqkq, tqsim]), auth=TqAuth(""信易账户"", ""账户密码""))    trades1 = account.get_trade()    trades2 = tqkq.get_trade()    trades3 = tqsim.get_trade()    print(trades1)    print(trades2)    print(trades3)    api.close()   """"""   api = _get_api_instance(self)   if trade_id:    return _get_obj(api._data, [""trade"", self._account_key, ""trades"", trade_id], Trade(api))   return _get_obj(api._data, [""trade"", self._account_key, ""trades""]) class IStock:  def get_account(self) -> SecurityAccount:   """"""   获取用户账户资金信息   Returns:    :py:class:`~tqsdk.objs.SecurityAccount`: 返回一个账户对象引用. 其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新   Example1::    # 获取当前浮动盈亏    from tqsdk import TqApi, TqAuth    tqacc = TqAccount(""N南华期货"", ""123456"", ""123456"")    api = TqApi(account=tqacc, auth=TqAuth(""信易账户"", ""账户密码""))    account = tqacc.get_account()    print(account.float_profit)    # 预计的输出是这样的:    2180.0    ...   Example2::    # 多账户模式下, 分别获取各账户浮动盈亏    from tqsdk import TqApi, TqAuth, TqMultiAccount, TqAccount, TqKq, TqSim    account = TqAccount(""N南华期货"", ""123456"", ""123456"")    tqkq = TqKq()    tqsim = TqSim()    api = TqApi(TqMultiAccount([account, tqkq, tqsim]), auth=TqAuth(""信易账户"", ""账户密码""))    account1 = account.get_account()    account2 = tqkq.get_account()    account3 = tqsim.get_account()    print(f""账户 1 浮动盈亏 {account1.float_profit}, 账户 2 浮动盈亏 {account2.float_profit}, 账户 3 浮动盈亏 {account3.float_profit}"")    api.close()   """"""   api = _get_api_instance(self)   return _get_obj(api._data, [""trade"", self._account_key, ""accounts"", ""CNY""], SecurityAccount(api))  def get_position(self, symbol: Optional[str] = None) -> Union[SecurityPosition, Entity]:   """"""   获取用户持仓信息   Args:    symbol (str): [可选]合约代码, 不填则返回所有持仓   Returns:    :py:class:`~tqsdk.objs.SecurityPosition`: 当指定了 symbol 时, 返回一个持仓对象引用。    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新。    不填 symbol 参数调用本函数, 将返回包含用户所有持仓的一个 ``tqsdk.objs.Entity`` 对象引用, 使用方法与dict一致, \    其中每个元素的 key 为合约代码, value 为 :py:class:`~tqsdk.objs.SecurityPosition`。   Example::    from tqsdk import TqApi, TqAuth, TqKqStock    tqkqstock = TqKqStock()    api = TqApi(account=tqkqstock, auth=TqAuth(""信易账户"", ""账户密码""))    position = tqkqstock.get_position('SSE.10003624')    print(f""建仓日期 {position.create_date}, 持仓数量 {position.volume}"")    api.close()   """"""   api = _get_api_instance(self)   if symbol:    return _get_obj(api._data, [""trade"", self._account_key, ""positions"", symbol], Position(api))   return _get_obj(api._data, [""trade"", self._account_key, ""positions""])  def get_order(self, order_id: Optional[str] = None) -> Union[SecurityOrder, Entity]:   """"""   获取用户委托单信息   Args:    order_id (str): [可选]单号, 不填单号则返回所有委托单   Returns:    :py:class:`~tqsdk.objs.SecurityOrder`: 当指定了 order_id 时, 返回一个委托单对象引用。 \    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新。    不填 order_id 参数调用本函数, 将返回包含用户所有委托单的一个 ``tqsdk.objs.Entity`` 对象引用, \    使用方法与 dict 一致, 其中每个元素的 key 为委托单号, value为 :py:class:`~tqsdk.objs.SecurityOrder`    注意: 在刚下单后, tqsdk 还没有收到回单信息时, 此对象中各项内容为空   Example::    from tqsdk import TqApi, TqAuth, TqKqStock    tqkqstock = TqKqStock()    api = TqApi(account=tqkqstock, auth=TqAuth(""信易账户"", ""账户密码""))    order = tqkqstock.get_order('委托单Id')    print(f""委托股数 {order.volume_orign}, 剩余股数 {order.volume_left}"")    api.close()   """"""   api = _get_api_instance(self)   if order_id:    return _get_obj(api._data, [""trade"", self._account_key, ""orders"", order_id], SecurityOrder(api))   return _get_obj(api._data, [""trade"", self._account_key, ""orders""])  def get_trade(self, trade_id: Optional[str] = None) -> Union[SecurityTrade, Entity]:   """"""   获取用户成交信息   Args:    trade_id (str): [可选]成交号, 不填成交号则返回所有委托单   Returns:    :py:class:`~tqsdk.objs.SecurityTrade`: 当指定了trade_id时, 返回一个成交对象引用. \    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新.    不填trade_id参数调用本函数, 将返回包含用户当前交易日所有成交记录的一个 ``tqsdk.objs.Entity`` 对象引用, 使用方法与dict一致, \    其中每个元素的key为成交号, value为 :py:class:`~tqsdk.objs.SecurityTrade`    推荐优先使用 :py:meth:`~tqsdk.objs.SecurityOrder.trade_records` 获取某个委托单的相应成交记录, 仅当确有需要时才使用本函数.   Example::    from tqsdk import TqApi, TqAuth, TqKqStock    tqkqstock = TqKqStock()    api = TqApi(account=tqkqstock, auth=TqAuth(""信易账户"", ""账户密码""))    trades = tqkqstock.get_trade('委托单Id')    [print(trade.trade_id, f""成交股数 {trade.volume}, 成交价格 {trade.price}"") for trade in trades]    api.close()   """"""   api = _get_api_instance(self)   if trade_id:    return _get_obj(api._data, [""trade"", self._account_key, ""trades"", trade_id], SecurityTrade(api))   return _get_obj(api._data, [""trade"", self._account_key, ""trades""]) "
182,n\tqsdk\tradeable\mixi,"n\tqsdk\tradeable\mixi. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' from typing import Optional, Union from tqsdk.diff import _get_obj from tqsdk.entity import Entity from tqsdk.objs import Account, Order, Trade, Position, SecurityAccount, SecurityOrder, SecurityTrade, SecurityPosition def _get_api_instance(self):  if hasattr(self, '_api'):   return self._api  import inspect  raise Exception(f""未初始化 TqApi。请在 api 初始化后调用 {inspect.stack()[1].function}。"") class FutureMixin:  _account_type = ""FUTURE""  def get_account(self) -> Account:   """"""   获取用户账户资金信息   Returns:    :py:class:`~tqsdk.objs.Account`: 返回一个账户对象引用. 其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新   Example1::    # 获取当前浮动盈亏    from tqsdk import TqApi, TqAuth    tqacc = TqAccount(""N南华期货"", ""123456"", ""123456"")    api = TqApi(account=tqacc, auth=TqAuth(""信易账户"", ""账户密码""))    account = tqacc.get_account()    print(account.float_profit)    # 预计的输出是这样的:    2180.0    ...   Example2::    # 多账户模式下, 分别获取各账户浮动盈亏    from tqsdk import TqApi, TqAuth, TqMultiAccount, TqAccount, TqKq, TqSim    account = TqAccount(""N南华期货"", ""123456"", ""123456"")    tqkq = TqKq()    tqsim = TqSim()    api = TqApi(TqMultiAccount([account, tqkq, tqsim]), auth=TqAuth(""信易账户"", ""账户密码""))    account1 = account.get_account()    account2 = tqkq.get_account()    account3 = tqsim.get_account()    print(f""账户 1 浮动盈亏 {account1.float_profit}, 账户 2 浮动盈亏 {account2.float_profit}, 账户 3 浮动盈亏 {account3.float_profit}"")    api.close()   """"""   api = _get_api_instance(self)   return _get_obj(api._data, [""trade"", self._account_key, ""accounts"", ""CNY""], Account(api))  def get_position(self, symbol: Optional[str] = None) -> Union[Position, Entity]:   """"""   获取用户持仓信息   Args:    symbol (str): [可选]合约代码, 不填则返回所有持仓   Returns:    :py:class:`~tqsdk.objs.Position`: 当指定了 symbol 时, 返回一个持仓对象引用。    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新。    不填 symbol 参数调用本函数, 将返回包含用户所有持仓的一个 ``tqsdk.objs.Entity`` 对象引用, 使用方法与dict一致, \    其中每个元素的 key 为合约代码, value 为 :py:class:`~tqsdk.objs.Position`。    注意: 为保留一些可供用户查询的历史信息, 如 volume_long_yd(本交易日开盘前的多头持仓手数) 等字段, 因此服务器会返回当天已平仓合约( pos_long 和 pos_short 等字段为0)的持仓信息   Example1::    # 获取 DCE.m2109 当前浮动盈亏    from tqsdk import TqApi, TqAuth, TqAccount    tqacc = TqAccount(""N南华期货"", ""123456"", ""123456"")    api = TqApi(account=tqacc, auth=TqAuth(""信易账户"", ""账户密码""))    position = tqacc.get_position(""DCE.m2109"")    print(position.float_profit_long + position.float_profit_short)    while api.wait_update():     print(position.float_profit_long + position.float_profit_short)    # 预计的输出是这样的:    300.0    330.0    ...   Example2::    # 多账户模式下, 分别获取各账户浮动盈亏    from tqsdk import TqApi, TqAuth, TqMultiAccount, TqAccount, TqKq, TqSim    account = TqAccount(""N南华期货"", ""123456"", ""123456"")    tqkq = TqKq()    tqsim = TqSim()    api = TqApi(TqMultiAccount([account, tqkq, tqsim]), auth=TqAuth(""信易账户"", ""账户密码""))    position1 = account.get_position(""DCE.m2101"")    position2 = tqkq.get_position(""DCE.m2101"")    position3 = tqsim.get_position(""DCE.m2101"")    print(f""账户 1 'DCE.m2101' 浮动盈亏 {position1.float_profit_long + position1.float_profit_short}, "",     f""账户 2 'DCE.m2101' 浮动盈亏 {position2.float_profit_long + position2.float_profit_short}, "",     f""账户 3 'DCE.m2101' 浮动盈亏 {position3.float_profit_long + position3.float_profit_short}"")    api.close()   """"""   api = _get_api_instance(self)   if symbol:    return _get_obj(api._data, [""trade"", self._account_key, ""positions"", symbol], Position(api))   return _get_obj(api._data, [""trade"", self._account_key, ""positions""])  def get_order(self, order_id: Optional[str] = None) -> Union[Order, Entity]:   """"""   获取用户委托单信息   Args:    order_id (str): [可选]单号, 不填单号则返回所有委托单   Returns:    :py:class:`~tqsdk.objs.Order`: 当指定了 order_id 时, 返回一个委托单对象引用。 \    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新。    不填 order_id 参数调用本函数, 将返回包含用户所有委托单的一个 ``tqsdk.objs.Entity`` 对象引用, \    使用方法与dict一致, 其中每个元素的key为委托单号, value为 :py:class:`~tqsdk.objs.Order`    注意: 在刚下单后, tqsdk 还没有收到回单信息时, 此对象中各项内容为空   Example1::    # 获取当前总挂单手数    from tqsdk import TqApi, TqAuth    tqacc = TqAccount(""N南华期货"", ""123456"", ""123456"")    api = TqApi(account=tqacc, auth=TqAuth(""信易账户"", ""账户密码""))    orders = tqacc.get_order()    while True:     api.wait_update()     print(sum(order.volume_left for oid, order in orders.items() if order.status == ""ALIVE""))    # 预计的输出是这样的:    3    3    0    ...   Example2::    # 多账户模式下, 分别获取各账户挂单手数    from tqsdk import TqApi, TqAuth, TqMultiAccount, TqAccount, TqKq, TqSim    account = TqAccount(""N南华期货"", ""123456"", ""123456"")    tqkq = TqKq()    tqsim = TqSim()    api = TqApi(TqMultiAccount([account, tqkq, tqsim]), auth=TqAuth(""信易账户"", ""账户密码""))    orders1 = account.get_order()    orders2 = tqkq.get_order()    orders3 = tqsim.get_order()    print(f""账户 1 挂单手数 {sum(order.volume_left for order in orders1.values() if order.status == ""ALIVE"")}, "",     f""账户 2 挂单手数 {sum(order.volume_left for order in orders2.values() if order.status == ""ALIVE"")}, "",     f""账户 3 挂单手数 {sum(order.volume_left for order in orders3.values() if order.status == ""ALIVE"")}"")    order = account.get_order(order_id=""订单号"")    print(order)    api.close()   """"""   api = _get_api_instance(self)   if order_id:    return _get_obj(api._data, [""trade"", self._account_key, ""orders"", order_id], Order(api))   return _get_obj(api._data, [""trade"", self._account_key, ""orders""])  def get_trade(self, trade_id: Optional[str] = None) -> Union[Trade, Entity]:   """"""   获取用户成交信息   Args:    trade_id (str): [可选]成交号, 不填成交号则返回所有委托单   Returns:    :py:class:`~tqsdk.objs.Trade`: 当指定了trade_id时, 返回一个成交对象引用. \    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新.    不填trade_id参数调用本函数, 将返回包含用户当前交易日所有成交记录的一个tqsdk.objs.Entity对象引用, 使用方法与dict一致, \    其中每个元素的key为成交号, value为 :py:class:`~tqsdk.objs.Trade`    推荐优先使用 :py:meth:`~tqsdk.objs.Order.trade_records` 获取某个委托单的相应成交记录, 仅当确有需要时才使用本函数.   Example::    # 多账户模式下, 分别获取各账户的成交记录    from tqsdk import TqApi, TqAuth, TqMultiAccount    account = TqAccount(""N南华期货"", ""123456"", ""123456"")    tqkq = TqKq()    tqsim = TqSim()    api = TqApi(TqMultiAccount([account, tqkq, tqsim]), auth=TqAuth(""信易账户"", ""账户密码""))    trades1 = account.get_trade()    trades2 = tqkq.get_trade()    trades3 = tqsim.get_trade()    print(trades1)    print(trades2)    print(trades3)    api.close()   """"""   api = _get_api_instance(self)   if trade_id:    return _get_obj(api._data, [""trade"", self._account_key, ""trades"", trade_id], Trade(api))   return _get_obj(api._data, [""trade"", self._account_key, ""trades""]) class StockMixin:  _account_type = ""STOCK""  def get_account(self) -> SecurityAccount:   """"""   获取用户账户资金信息   Returns:    :py:class:`~tqsdk.objs.SecurityAccount`: 返回一个账户对象引用. 其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新   Example1::    # 获取当前浮动盈亏    from tqsdk import TqApi, TqAuth    tqacc = TqAccount(""N南华期货"", ""123456"", ""123456"")    api = TqApi(account=tqacc, auth=TqAuth(""信易账户"", ""账户密码""))    account = tqacc.get_account()    print(account.float_profit)    # 预计的输出是这样的:    2180.0    ...   Example2::    # 多账户模式下, 分别获取各账户浮动盈亏    from tqsdk import TqApi, TqAuth, TqMultiAccount, TqAccount, TqKq, TqSim    account = TqAccount(""N南华期货"", ""123456"", ""123456"")    tqkq = TqKq()    tqsim = TqSim()    api = TqApi(TqMultiAccount([account, tqkq, tqsim]), auth=TqAuth(""信易账户"", ""账户密码""))    account1 = account.get_account()    account2 = tqkq.get_account()    account3 = tqsim.get_account()    print(f""账户 1 浮动盈亏 {account1.float_profit}, 账户 2 浮动盈亏 {account2.float_profit}, 账户 3 浮动盈亏 {account3.float_profit}"")    api.close()   """"""   api = _get_api_instance(self)   return _get_obj(api._data, [""trade"", self._account_key, ""accounts"", ""CNY""], SecurityAccount(api))  def get_position(self, symbol: Optional[str] = None) -> Union[SecurityPosition, Entity]:   """"""   获取用户持仓信息   Args:    symbol (str): [可选]合约代码, 不填则返回所有持仓   Returns:    :py:class:`~tqsdk.objs.SecurityPosition`: 当指定了 symbol 时, 返回一个持仓对象引用。    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新。    不填 symbol 参数调用本函数, 将返回包含用户所有持仓的一个 ``tqsdk.objs.Entity`` 对象引用, 使用方法与dict一致, \    其中每个元素的 key 为合约代码, value 为 :py:class:`~tqsdk.objs.SecurityPosition`。   Example::    from tqsdk import TqApi, TqAuth, TqKqStock    tqkqstock = TqKqStock()    api = TqApi(account=tqkqstock, auth=TqAuth(""信易账户"", ""账户密码""))    position = tqkqstock.get_position('SSE.10003624')    print(f""建仓日期 {position.create_date}, 持仓数量 {position.volume}"")    api.close()   """"""   api = _get_api_instance(self)   if symbol:    return _get_obj(api._data, [""trade"", self._account_key, ""positions"", symbol], SecurityPosition(api))   return _get_obj(api._data, [""trade"", self._account_key, ""positions""])  def get_order(self, order_id: Optional[str] = None) -> Union[SecurityOrder, Entity]:   """"""   获取用户委托单信息   Args:    order_id (str): [可选]单号, 不填单号则返回所有委托单   Returns:    :py:class:`~tqsdk.objs.SecurityOrder`: 当指定了 order_id 时, 返回一个委托单对象引用。 \    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新。    不填 order_id 参数调用本函数, 将返回包含用户所有委托单的一个 ``tqsdk.objs.Entity`` 对象引用, \    使用方法与 dict 一致, 其中每个元素的 key 为委托单号, value为 :py:class:`~tqsdk.objs.SecurityOrder`    注意: 在刚下单后, tqsdk 还没有收到回单信息时, 此对象中各项内容为空   Example::    from tqsdk import TqApi, TqAuth, TqKqStock    tqkqstock = TqKqStock()    api = TqApi(account=tqkqstock, auth=TqAuth(""信易账户"", ""账户密码""))    order = tqkqstock.get_order('委托单Id')    print(f""委托股数 {order.volume_orign}, 剩余股数 {order.volume_left}"")    api.close()   """"""   api = _get_api_instance(self)   if order_id:    return _get_obj(api._data, [""trade"", self._account_key, ""orders"", order_id], SecurityOrder(api))   return _get_obj(api._data, [""trade"", self._account_key, ""orders""])  def get_trade(self, trade_id: Optional[str] = None) -> Union[SecurityTrade, Entity]:   """"""   获取用户成交信息   Args:    trade_id (str): [可选]成交号, 不填成交号则返回所有委托单   Returns:    :py:class:`~tqsdk.objs.SecurityTrade`: 当指定了trade_id时, 返回一个成交对象引用. \    其内容将在 :py:meth:`~tqsdk.api.TqApi.wait_update` 时更新.    不填trade_id参数调用本函数, 将返回包含用户当前交易日所有成交记录的一个 ``tqsdk.objs.Entity`` 对象引用, 使用方法与dict一致, \    其中每个元素的key为成交号, value为 :py:class:`~tqsdk.objs.SecurityTrade`    推荐优先使用 :py:meth:`~tqsdk.objs.SecurityOrder.trade_records` 获取某个委托单的相应成交记录, 仅当确有需要时才使用本函数.   Example::    from tqsdk import TqApi, TqAuth, TqKqStock    tqkqstock = TqKqStock()    api = TqApi(account=tqkqstock, auth=TqAuth(""信易账户"", ""账户密码""))    trades = tqkqstock.get_trade('委托单Id')    [print(trade.trade_id, f""成交股数 {trade.volume}, 成交价格 {trade.price}"") for trade in trades]    api.close()   """"""   api = _get_api_instance(self)   if trade_id:    return _get_obj(api._data, [""trade"", self._account_key, ""trades"", trade_id], SecurityTrade(api))   return _get_obj(api._data, [""trade"", self._account_key, ""trades""]) "
183,n\tqsdk\tradeable\tradeabl,"n\tqsdk\tradeable\tradeabl. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' from abc import ABC, abstractmethod from tqsdk.baseModule import TqModule class Tradeable(ABC, TqModule):  def __init__(self):   self._account_key = self._get_account_key() # 每个账户的唯一标识，在账户初始化时就确定下来，后续只读不写  def _get_account_key(self):   return str(id(self))  @property  @abstractmethod  def _account_name(self):   # 用于界面展示的用户信息   raise NotImplementedError  @property  def _account_info(self):   # 用于 web_helper 获取初始账户信息   return {    ""account_key"": self._account_key,    ""account_name"": self._account_name   }  def _is_self_trade_pack(self, pack):   """"""是否是当前交易实例应该处理的交易包""""""   if pack[""aid""] in [""insert_order"", ""cancel_order"", ""set_risk_management_rule""]:    assert ""account_key"" in pack, ""发给交易请求的包必须包含 account_key""    if pack[""account_key""] != self._account_key:     return False    else:     pack.pop(""account_key"", None)     return True   return False "
184,n\tqsdk\tradeable\  init ,"n\tqsdk\tradeable\  init . #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' from tqsdk.tradeable.otg.base_otg import BaseOtg from tqsdk.tradeable.otg import TqAccount, TqKq, TqKqStock from tqsdk.tradeable.sim.basesim import BaseSim from tqsdk.tradeable.sim import TqSim, TqSimStock "
185,n\tqsdk\tradeable\otg\base ot,"n\tqsdk\tradeable\otg\base ot. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' import hashlib from typing import Optional from tqsdk.tradeable.mixin import FutureMixin, StockMixin from tqsdk.tradeable.tradeable import Tradeable class BaseOtg(Tradeable):  def __init__(self, broker_id: str, account_id: str, password: str, td_url: Optional[str] = None) -> None:   if not isinstance(broker_id, str):    raise Exception(""broker_id 参数类型应该是 str"")   if not isinstance(account_id, str):    raise Exception(""account_id 参数类型应该是 str"")   if not isinstance(password, str):    raise Exception(""password 参数类型应该是 str"")   self._broker_id = broker_id.strip() # 期货公司（用户登录 rsp_login 填的）   self._account_id = account_id.strip() # 期货账户 （用户登录 rsp_login 填的）   self._password = password   self._td_url = td_url   super(BaseOtg, self).__init__()  def _get_account_key(self):   s = self._broker_id + self._account_id   return hashlib.md5(s.encode('utf-8')).hexdigest()  @property  def _account_name(self):   return self._account_id  @property  def _account_info(self):   info = super(BaseOtg, self)._account_info   info.update({    ""broker_id"": self._broker_id,    ""account_id"": self._account_id   })   return info  async def _send_login_pack(self):   """"""发送登录请求""""""   req = {    ""aid"": ""req_login"",    ""bid"": self._broker_id,    ""user_name"": self._account_id,    ""password"": self._password   }   await self._td_send_chan.send(req)  def _update_otg_info(self, api):   """"""更新 otg 登录需要的基本信息""""""   if self._td_url:    return   if api._td_url:    self._td_url = api._td_url   else:    self._td_url, account_type = api._auth._get_td_url(self._broker_id, self._account_id)    if account_type == ""FUTURE"":     assert isinstance(self, FutureMixin)    else:     assert isinstance(self, StockMixin)  async def _run(self, api, api_send_chan, api_recv_chan, md_send_chan, md_recv_chan, td_send_chan, td_recv_chan):   self._api = api   self._api_send_chan = api_send_chan   self._api_recv_chan = api_recv_chan   self._md_send_chan = md_send_chan   self._md_recv_chan = md_recv_chan   self._td_send_chan = td_send_chan   self._td_recv_chan = td_recv_chan   await self._send_login_pack()   await super(BaseOtg, self)._run(api, api_send_chan, api_recv_chan, md_send_chan, md_recv_chan, td_send_chan,            td_recv_chan)  async def _handle_recv_data(self, pack, chan):   """"""   处理所有上游收到的数据包   """"""   if chan == self._md_recv_chan: # 从行情收到的数据包    if pack[""aid""] == ""rtn_data"":     self._diffs.extend(pack.get('data', []))    else:     await self._api_recv_chan.send(pack) # 有可能是另一个 account 的 rsp_login   elif chan == self._td_recv_chan: # 从交易收到的数据包    # 收到通知时，在通知里加上 account_name 信息    if pack[""aid""] == ""rtn_data"":     for data in pack.get('data', []):      for notify_id, notify in data.get('notify', {}).items():       notify['_account_name'] = self._account_name    self._td_handler(pack)  async def _handle_req_data(self, pack):   if self._is_self_trade_pack(pack):    await self._td_send_chan.send(pack)   else:    await self._md_send_chan.send(pack)  def _td_handler(self, pack):   # OTG 返回业务信息截面 trade 中 account_key 为 user_id, 该值需要替换为 account_key   if pack[""aid""] == ""rtn_data"":    pack_data = pack.get('data', [])    for item in pack_data:     if ""trade"" in item:      item[""trade""][self._account_key] = item[""trade""].pop(self._account_id)    self._diffs.extend(pack_data) "
186,n\tqsdk\tradeable\otg\tqaccoun,"n\tqsdk\tradeable\otg\tqaccoun. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' import base64 import ctypes import hashlib import logging import os from pathlib import Path import sys import uuid from typing import Optional from tqsdk.tradeable.otg.base_otg import BaseOtg from tqsdk.tradeable.mixin import FutureMixin class TqAccount(BaseOtg, FutureMixin):  """"""天勤实盘账户类""""""  def __init__(self, broker_id: str, account_id: str, password: str, front_broker: Optional[str] = None,     front_url: Optional[str] = None, td_url: Optional[str] = None, **kwargs) -> None:   """"""   创建天勤实盘账户实例   Args:    broker_id (str): 期货公司，支持的期货公司列表 https://www.shinnytech.com/blog/tq-support-broker/    account_id (str): 帐号    password (str): 密码    td_url(str): [可选]用于指定账户连接的交易服务器地址, eg: ""tcp://1.2.3.4:1234/""   """"""   if bool(front_broker) != bool(front_url):    raise Exception(""front_broker 和 front_url 参数需同时填写"")   self._front_broker = front_broker   self._front_url = front_url   self._app_id = ""SHINNY_TQ_1.0""   account_type = kwargs[""account_type""] if ""account_type"" in kwargs else ""FUTURE""   if account_type == ""SPOT"":    raise Exception(""account_type 账户类型指定错误，目前只支持 FUTURE"")   kwargs.pop(""account_type"", None)   if len(kwargs) > 0:    raise TypeError(f""不支持以下参数 {[kwargs.keys()]}"")   super(TqAccount, self).__init__(broker_id, account_id, password, td_url)  def _get_account_key(self):   s = self._broker_id + self._account_id   s += self._front_broker if self._front_broker else """"   s += self._front_url if self._front_url else """"   s += self._td_url if self._td_url else """"   return hashlib.md5(s.encode('utf-8')).hexdigest()  @property  def _account_info(self):   info = super(TqAccount, self)._account_info   info.update({    ""account_type"": self._account_type   })   return info  def _get_system_info(self):   try:    l = ctypes.c_int(344)    buf = ctypes.create_string_buffer(l.value)    path = Path(__file__, '../../../ctpse')    lib_path = path.resolve() # Make the path absolute, resolving any symlinks. A new path object is returned    if sys.platform.startswith(""win"") or sys.platform.startswith(""linux""):     if sys.platform.startswith(""win""):      if ctypes.sizeof(ctypes.c_voidp) == 4:       selib = ctypes.cdll.LoadLibrary(os.path.join(lib_path, ""WinDataCollect32.dll""))       ret = getattr(selib, ""?CTP_GetSystemInfo@@YAHPADAAH@Z"")(buf, ctypes.byref(l))      else:       selib = ctypes.cdll.LoadLibrary(os.path.join(lib_path, ""WinDataCollect64.dll""))       ret = getattr(selib, ""?CTP_GetSystemInfo@@YAHPEADAEAH@Z"")(buf, ctypes.byref(l))     else:      selib = ctypes.cdll.LoadLibrary(os.path.join(lib_path, ""LinuxDataCollect64.so""))      ret = selib._Z17CTP_GetSystemInfoPcRi(buf, ctypes.byref(l))     if ret == 0:      return base64.b64encode(buf.raw[:l.value]).decode(""utf-8"")     else:      raise Exception(""错误码: %d"" % ret)    else:     logging.getLogger(""TqApi.TqAccount"").debug(""ctpse error"", error=""不支持该平台"")   except Exception as e:    self._api._print(f""采集穿透式监管客户端信息失败: {e}"", level=""ERROR"")    logging.getLogger(""TqApi.TqAccount"").error(""ctpse error"", error=e)   return """"  async def _send_login_pack(self):   req = {    ""aid"": ""req_login"",    ""bid"": self._broker_id,    ""user_name"": self._account_id,    ""password"": self._password,   }   mac = f""{uuid.getnode():012X}""   req[""client_mac_address""] = ""-"".join([mac[e:e + 2] for e in range(0, 11, 2)])   system_info = self._get_system_info()   if system_info:    req[""client_app_id""] = self._app_id    req[""client_system_info""] = system_info   if self._front_broker:    req[""broker_id""] = self._front_broker    req[""front""] = self._front_url   await self._td_send_chan.send(req)   await self._td_send_chan.send({    ""aid"": ""confirm_settlement""   }) # 自动发送确认结算单 "
187,n\tqsdk\tradeable\otg\tqk,"n\tqsdk\tradeable\otg\tqk. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'yanqiong' from typing import Optional from tqsdk.tradeable.otg.base_otg import BaseOtg from tqsdk.tradeable.mixin import FutureMixin, StockMixin class TqKq(BaseOtg, FutureMixin):  """"""天勤快期模拟账户类""""""  def __init__(self, td_url: Optional[str] = None):   """"""   创建快期模拟账户实例   快期模拟的账户和交易信息可以在快期专业版查看，可以点击 `快期专业版 <https://www.shinnytech.com/qpro/>`_ 进行下载   Example::    from tqsdk import TqApi, TqAuth, TqKq    tq_kq = TqKq()    api = TqApi(account=tq_kq, auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SHFE.cu2206"")    print(quote)    # 下单限价单    order = api.insert_order(symbol=""SHFE.cu2206"", direction='BUY', offset='OPEN', limit_price=quote.last_price, volume=1)    while order.status == 'ALIVE':     api.wait_update()     print(order) # 打印委托单信息    print(tq_kq.get_account()) # 打印快期模拟账户信息    print(tq_kq.get_position(""SHFE.cu2206"")) # 打印持仓信息    for trade in order.trade_records.values():     print(trade) # 打印委托单对应的成交信息    api.close()   """"""   super().__init__(""快期模拟"", """", """", td_url=td_url)  @property  def _account_name(self):   # 用于界面展示的用户信息   return self._api._auth._user_name  @property  def _account_info(self):   info = super(TqKq, self)._account_info   info.update({    ""account_type"": self._account_type   })   return info  def _update_otg_info(self, api):   self._account_id = api._auth._auth_id   self._password = api._auth._auth_id   super(TqKq, self)._update_otg_info(api) class TqKqStock(BaseOtg, StockMixin):  """"""天勤实盘类""""""  def __init__(self, td_url: Optional[str] = None):   """"""   创建快期股票模拟账户实例   快期股票模拟为专业版功能，可以点击 `天勤量化专业版 <https://www.shinnytech.com/tqsdk_professional/>`_ 申请试用或购买   Example::    from tqsdk import TqApi, TqAuth, TqKqStock, TqChan    tq_kq_stock = TqKqStock()    api = TqApi(account=tq_kq_stock, auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SSE.688529"")    print(quote)    # 下单限价单    order = api.insert_order(""SSE.688529"", volume=200, direction=""BUY"", limit_price=quote.ask_price1)    while order.status == 'ALIVE':     api.wait_update()     print(order) # 打印委托单信息    print(tq_kq_stock.get_account()) # 打印快期股票模拟账户信息    print(tq_kq_stock.get_position(""SSE.688529"")) # 打印持仓信息    for trade in order.trade_records.values():     print(trade) # 打印委托单对应的成交信息    api.close()   """"""   super().__init__(""快期股票模拟"", """", """", td_url=td_url)  @property  def _account_name(self):   # 用于界面展示的用户信息   return self._api._auth._user_name + ""_stock""  @property  def _account_info(self):   info = super(TqKqStock, self)._account_info   info.update({    ""account_type"": self._account_type   })   return info  def _update_otg_info(self, api):   self._account_id = api._auth._auth_id + ""-sim-securities""   self._password = api._auth._auth_id   super(TqKqStock, self)._update_otg_info(api) "
188,n\tqsdk\tradeable\otg\  init ,"n\tqsdk\tradeable\otg\  init . #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' from tqsdk.tradeable.otg.tqaccount import TqAccount from tqsdk.tradeable.otg.tqkq import TqKq, TqKqStock "
189,n\tqsdk\tradeable\sim\basesi,"n\tqsdk\tradeable\sim\basesi. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' import asyncio import time from abc import abstractmethod from typing import Type, Union from tqsdk.channel import TqChan from tqsdk.datetime import _get_trading_day_from_timestamp, _get_trading_day_end_time, _get_trade_timestamp, \  _is_in_trading_time, _timestamp_nano_to_str, _str_to_timestamp_nano from tqsdk.diff import _get_obj, _register_update_chan, _merge_diff from tqsdk.entity import Entity from tqsdk.objs import Quote from tqsdk.tradeable.tradeable import Tradeable from tqsdk.tradeable.sim.trade_future import SimTrade from tqsdk.tradeable.sim.trade_stock import SimTradeStock from tqsdk.utils import _query_for_quote class BaseSim(Tradeable):  def __init__(self, account_id, init_balance, trade_class: Union[Type[SimTrade], Type[SimTradeStock]]) -> None:   self._account_id = account_id   super(BaseSim, self).__init__()   self.trade_log = {} # 日期->交易记录及收盘时的权益及持仓   self.tqsdk_stat = {} # 回测结束后储存回测报告信息   self._init_balance = init_balance   self._current_datetime = ""1990-01-01 00:00:00.000000"" # 当前行情时间（最新的 quote 时间）   self._trading_day_end = ""1990-01-01 18:00:00.000000""   self._local_time_record = float(""nan"") # 记录获取最新行情时的本地时间   self._sim_trade = trade_class(account_key=self._account_key,          account_id=self._account_id,          init_balance=self._init_balance,          get_trade_timestamp=self._get_trade_timestamp,          is_in_trading_time=self._is_in_trading_time)   self._data = Entity()   self._data._instance_entity([])   self._prototype = {    ""quotes"": {     ""#"": Quote(self), # 行情的数据原型    }   }   self._quote_tasks = {}  @property  def _account_name(self):   return self._account_id  @property  def _account_info(self):   info = super(BaseSim, self)._account_info   info.update({    ""account_id"": self._account_id   })   return info  async def _run(self, api, api_send_chan, api_recv_chan, md_send_chan, md_recv_chan):   """"""模拟交易task""""""   self._api = api   self._tqsdk_backtest = {} # 储存可能的回测信息   self._logger = api._logger.getChild(""TqSim"") # 调试信息输出   self._api_send_chan = api_send_chan   self._api_recv_chan = api_recv_chan   self._md_send_chan = md_send_chan   self._md_recv_chan = md_recv_chan   # True 下游发过 subscribe，但是没有转发给上游；False 表示下游发的 subscribe 都转发给上游   self._pending_subscribe_downstream = False   # True 发给上游 subscribe，但是没有收到过回复；False 如果行情不变，上游不会回任何包   self._pending_subscribe_upstream = False   self._all_subscribe = set() # 客户端+模拟交易模块订阅的合约集合   # 是否已经发送初始账户信息   self._has_send_init_account = False   try:    await super(BaseSim, self)._run(api, api_send_chan, api_recv_chan, md_send_chan, md_recv_chan)   finally:    self._handle_stat_report()    for s in self._quote_tasks:     self._quote_tasks[s][""task""].cancel()    await asyncio.gather(*[self._quote_tasks[s][""task""] for s in self._quote_tasks], return_exceptions=True)  async def _handle_recv_data(self, pack, chan):   """"""   处理所有上游收到的数据包，这里应该将需要发送给下游的数据 append 到 self._diffs   pack: 收到的数据包   chan: 收到此数据包的 channel   """"""   self._pending_subscribe_upstream = False   if pack[""aid""] == ""rtn_data"":    self._md_recv(pack) # md_recv 中会发送 wait_count 个 quotes 包给各个 quote_chan    await asyncio.gather(*[quote_task[""quote_chan""].join() for quote_task in self._quote_tasks.values()])   if self._tqsdk_backtest != {} and self._tqsdk_backtest[""current_dt""] >= self._tqsdk_backtest[""end_dt""]:    # 回测情况下，把 _handle_stat_report 在循环中回测结束时执行    self._handle_stat_report()  async def _handle_req_data(self, pack):   """"""   处理所有下游发送的非 peek_message 数据包   这里应该将发送的请求转发到指定的某个上游 channel   """"""   if self._is_self_trade_pack(pack):    if pack[""aid""] == ""insert_order"":     symbol = pack[""exchange_id""] + ""."" + pack[""instrument_id""]     if symbol not in self._quote_tasks:      quote_chan = TqChan(self._api)      order_chan = TqChan(self._api)      self._quote_tasks[symbol] = {       ""quote_chan"": quote_chan,       ""order_chan"": order_chan,       ""task"": self._api.create_task(self._quote_handler(symbol, quote_chan, order_chan))      }     await self._quote_tasks[symbol][""order_chan""].send(pack)    else:     # pack 里只有 order_id 信息，发送到每一个合约的 order_chan, 交由 quote_task 判断是不是当前合约下的委托单     for symbol in self._quote_tasks:      await self._quote_tasks[symbol][""order_chan""].send(pack)   elif pack[""aid""] == ""subscribe_quote"":    # 这里只会增加订阅合约，不会退订合约    await self._subscribe_quote(set(pack[""ins_list""].split("","")))   else:    await self._md_send_chan.send(pack)  async def _on_send_diff(self, pending_peek):   if pending_peek and self._pending_subscribe_downstream:    await self._send_subscribe_quote()  async def _subscribe_quote(self, symbols: [set, str]):   """"""   这里只会增加订阅合约，不会退订合约   todo: 这里用到了 self._pending_peek ，父类的内部变量   """"""   symbols = symbols if isinstance(symbols, set) else {symbols}   if symbols - self._all_subscribe:    self._all_subscribe |= symbols    if self._pending_peek and not self._pending_subscribe_upstream:     await self._send_subscribe_quote()    else:     self._pending_subscribe_downstream = True  async def _send_subscribe_quote(self):   self._pending_subscribe_upstream = True   self._pending_subscribe_downstream = False   await self._md_send_chan.send({    ""aid"": ""subscribe_quote"",    ""ins_list"": "","".join(self._all_subscribe)   })  def _handle_stat_report(self):   if self.tqsdk_stat:    return   self._settle()   self._report()   self._diffs.append({    ""trade"": {     self._account_key: {      ""accounts"": {       ""CNY"": {        ""_tqsdk_stat"": self.tqsdk_stat       }      }     }    }   })  async def _ensure_quote_info(self, symbol, quote_chan):   """"""quote收到合约信息后返回""""""   quote = _get_obj(self._data, [""quotes"", symbol], Quote(self._api))   if quote.get(""price_tick"") == quote.get(""price_tick""):    return quote.copy()   if quote.get(""price_tick"") != quote.get(""price_tick""):    await self._md_send_chan.send(_query_for_quote(symbol))   async for _ in quote_chan:    quote_chan.task_done()    if quote.get(""price_tick"") == quote.get(""price_tick""):     return quote.copy()  async def _ensure_quote(self, symbol, quote_chan):   """"""quote收到行情以及合约信息后返回""""""   quote = _get_obj(self._data, [""quotes"", symbol], Quote(self._api))   _register_update_chan(quote, quote_chan)   if quote.get(""datetime"", """") and quote.get(""price_tick"") == quote.get(""price_tick""):    return quote.copy()   if quote.get(""price_tick"") != quote.get(""price_tick""):    # 对于没有合约信息的 quote，发送查询合约信息的请求    await self._md_send_chan.send(_query_for_quote(symbol))   async for _ in quote_chan:    quote_chan.task_done()    if quote.get(""datetime"", """") and quote.get(""price_tick"") == quote.get(""price_tick""):     return quote.copy()  async def _quote_handler(self, symbol, quote_chan, order_chan):   try:    await self._subscribe_quote(symbol)    quote = await self._ensure_quote(symbol, quote_chan)    if quote[""ins_class""].endswith(""INDEX"") and quote[""exchange_id""] == ""KQ"":     # 指数可以交易，需要补充 margin commission     if ""margin"" not in quote:      quote_m = await self._ensure_quote_info(symbol.replace(""KQ.i"", ""KQ.m""), quote_chan)      quote_underlying = await self._ensure_quote_info(quote_m[""underlying_symbol""], quote_chan)      self._data[""quotes""][symbol][""margin""] = quote_underlying[""margin""]      self._data[""quotes""][symbol][""commission""] = quote_underlying[""commission""]      quote.update(self._data[""quotes""][symbol])    underlying_quote = None    if quote[""ins_class""].endswith(""OPTION""):     # 如果是期权，订阅标的合约行情，确定收到期权标的合约行情     underlying_symbol = quote[""underlying_symbol""]     await self._subscribe_quote(underlying_symbol)     underlying_quote = await self._ensure_quote(underlying_symbol, quote_chan) # 订阅合约    # 在等待标的行情的过程中，quote_chan 可能有期权行情，把 quote_chan 清空，并用最新行情更新 quote    while not quote_chan.empty():     quote_chan.recv_nowait()     quote_chan.task_done()    # 用最新行情更新 quote    quote.update(self._data[""quotes""][symbol])    if underlying_quote:     underlying_quote.update(self._data[""quotes""][underlying_symbol])    task = self._api.create_task(self._forward_chan_handler(order_chan, quote_chan))    quotes = {symbol: quote}    if underlying_quote:     quotes[underlying_symbol] = underlying_quote    self._sim_trade.update_quotes(symbol, {""quotes"": quotes})    async for pack in quote_chan:     if ""aid"" not in pack:      diffs, orders_events = self._sim_trade.update_quotes(symbol, pack)      self._handle_diffs(diffs, orders_events, ""match order"")     elif pack[""aid""] == ""insert_order"":      diffs, orders_events = self._sim_trade.insert_order(symbol, pack)      self._handle_diffs(diffs, orders_events, ""insert order"")     elif pack[""aid""] == ""cancel_order"":      diffs, orders_events = self._sim_trade.cancel_order(symbol, pack)      self._handle_diffs(diffs, orders_events, ""cancel order"")     quote_chan.task_done()   finally:    await quote_chan.close()    await order_chan.close()    task.cancel()    await asyncio.gather(task, return_exceptions=True)  async def _forward_chan_handler(self, chan_from, chan_to):   async for pack in chan_from:    await chan_to.send(pack)  def _md_recv(self, pack):   for d in pack[""data""]:    self._diffs.append(d)    # 在第一次收到 mdhis_more_data 为 False 的时候，发送账户初始截面信息，这样回测模式下，往后的模块才有正确的时间顺序    if not self._has_send_init_account and not d.get(""mdhis_more_data"", True):     self._diffs.append(self._sim_trade.init_snapshot())     self._diffs.append({      ""trade"": {       self._account_key: {        ""trade_more_data"": False       }      }     })     self._has_send_init_account = True    _tqsdk_backtest = d.get(""_tqsdk_backtest"", {})    if _tqsdk_backtest:     # 回测时，用 _tqsdk_backtest 对象中 current_dt 作为 TqSim 的 _current_datetime     self._tqsdk_backtest.update(_tqsdk_backtest)     self._current_datetime = _timestamp_nano_to_str(self._tqsdk_backtest[""current_dt""])     self._local_time_record = float(""nan"")     # 1. 回测时不使用时间差来模拟交易所时间的原因(_local_time_record始终为初始值nan)：     # 在sim收到行情后记录_local_time_record，然后下发行情到api进行merge_diff(),api需要处理完k线和quote才能结束wait_update(),     # 若处理时间过长，此时下单则在判断下单时间时与测试用例中的预期时间相差较大，导致测试用例无法通过。     # 2. 回测不使用时间差的方法来判断下单时间仍是可行的: 与使用了时间差的方法相比, 只对在每个交易时间段最后一笔行情时的下单时间判断有差异,     # 若不使用时间差, 则在最后一笔行情时下单仍判断为在可交易时间段内, 且可成交.    quotes_diff = d.get(""quotes"", {})    # 先根据 quotes_diff 里的 datetime, 确定出 _current_datetime，再 _merge_diff(同时会发送行情到 quote_chan)    for symbol, quote_diff in quotes_diff.items():     if quote_diff is None:      continue     # 若直接使用本地时间来判断下单时间是否在可交易时间段内 可能有较大误差,因此判断的方案为:(在接收到下单指令时判断 估计的交易所时间 是否在交易时间段内)     # 在更新最新行情时间(即self._current_datetime)时，记录当前本地时间(self._local_time_record)，     # 在这之后若收到下单指令，则获取当前本地时间,判 ""最新行情时间 + (当前本地时间 - 记录的本地时间)"" 是否在交易时间段内。     # 另外, 若在盘后下单且下单前未订阅此合约：     # 因为从_md_recv()中获取数据后立即判断下单时间则速度过快(两次time.time()的时间差小于最后一笔行情(14:59:9995)到15点的时间差),     # 则会立即成交,为处理此情况则将当前时间减去5毫秒（模拟发生5毫秒网络延迟，则两次time.time()的时间差增加了5毫秒）。     # todo: 按交易所来存储 _current_datetime(issue： #277)     if quote_diff.get(""datetime"", """") > self._current_datetime:      # 回测时，当前时间更新即可以由 quote 行情更新，也可以由 _tqsdk_backtest.current_dt 更新，      # 在最外层的循环里，_tqsdk_backtest.current_dt 是在 rtn_data.data 中数组位置中的最后一个，会在循环最后一个才更新 self.current_datetime      # 导致前面处理 order 时的 _current_datetime 还是旧的行情时间      self._current_datetime = quote_diff[""datetime""] # 最新行情时间      # 更新最新行情时间时的本地时间，回测时不使用时间差      self._local_time_record = (time.time() - 0.005) if not self._tqsdk_backtest else float(""nan"")     if self._current_datetime > self._trading_day_end: # 结算      self._settle()      # 若当前行情时间大于交易日的结束时间(切换交易日)，则根据此行情时间更新交易日及交易日结束时间      trading_day = _get_trading_day_from_timestamp(self._get_current_timestamp())      self._trading_day_end = _timestamp_nano_to_str(_get_trading_day_end_time(trading_day) - 999)    if quotes_diff:     _merge_diff(self._data, {""quotes"": quotes_diff}, self._prototype, persist=False, reduce_diff=False, notify_update_diff=True)  def _handle_diffs(self, diffs, orders_events, msg):   """"""   处理 sim_trade 返回的 diffs   orders_events 为持仓变更事件，依次屏幕输出信息，打印日志   """"""   self._diffs += diffs   for order in orders_events:    if order[""status""] == ""FINISHED"":     self._handle_on_finished(msg, order)    else:     assert order[""status""] == ""ALIVE""     self._handle_on_alive(msg, order)  def _settle(self):   if self._trading_day_end[:10] == ""1990-01-01"":    return   # 结算并记录账户截面   diffs, orders_events, trade_log = self._sim_trade.settle()   self._handle_diffs(diffs, orders_events, ""settle"")   self.trade_log[self._trading_day_end[:10]] = trade_log  @abstractmethod  def _handle_on_alive(self, msg, order):   """"""   在 order 状态变为 ALIVE 调用，屏幕输出信息，打印日志   """"""   pass  @abstractmethod  def _handle_on_finished(self, msg, order):   """"""   在 order 状态变为 FINISHED 调用，屏幕输出信息，打印日志   """"""   pass  @abstractmethod  def _report(self):   pass  def _get_current_timestamp(self):   return _str_to_timestamp_nano(self._current_datetime)  def _get_trade_timestamp(self):   return _get_trade_timestamp(self._current_datetime, self._local_time_record)  def _is_in_trading_time(self, quote):   return _is_in_trading_time(quote, self._current_datetime, self._local_time_record) "
190,n\tqsdk\tradeable\sim\tqsi,"n\tqsdk\tradeable\sim\tqsi. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' from tqsdk.tradeable.mixin import FutureMixin from tqsdk.datetime import _timestamp_nano_to_str from tqsdk.diff import _get_obj from tqsdk.objs import Quote from tqsdk.report import TqReport from tqsdk.tradeable.sim.basesim import BaseSim from tqsdk.tradeable.sim.trade_future import SimTrade from tqsdk.tradeable.sim.utils import _get_future_margin, _get_commission class TqSim(BaseSim, FutureMixin):  """"""  天勤模拟交易类  该类实现了一个本地的模拟账户，并且在内部完成撮合交易，在回测和复盘模式下，只能使用 TqSim 账户来交易。  限价单要求报单价格达到或超过对手盘价格才能成交, 成交价为报单价格, 如果没有对手盘(涨跌停)则无法成交  市价单使用对手盘价格成交, 如果没有对手盘(涨跌停)则自动撤单  模拟交易不会有部分成交的情况, 要成交就是全部成交  """"""  def __init__(self, init_balance: float = 10000000.0, account_id: str = None) -> None:   """"""   Args:    init_balance (float): [可选]初始资金, 默认为一千万    account_id (str): [可选]帐号, 默认为 TQSIM   Example::    # 修改TqSim模拟帐号的初始资金为100000    from tqsdk import TqApi, TqSim, TqAuth    api = TqApi(TqSim(init_balance=100000), auth=TqAuth(""信易账户"", ""账户密码""))   """"""   if float(init_balance) <= 0:    raise Exception(""初始资金(init_balance) %s 错误, 请检查 init_balance 是否填写正确"" % (init_balance))   super(TqSim, self).__init__(account_id=""TQSIM"" if account_id is None else account_id,          init_balance=float(init_balance),          trade_class=SimTrade)  @property  def _account_info(self):   info = super(TqSim, self)._account_info   info.update({    ""account_type"": self._account_type   })   return info  def set_commission(self, symbol: str, commission: float=float('nan')):   """"""   设置指定合约模拟交易的每手手续费。   Args:    symbol (str): 合约代码    commission (float): 每手手续费   Returns:    float: 设置的每手手续费   Example::    from tqsdk import TqSim, TqApi, TqAuth    sim = TqSim()    api = TqApi(sim, auth=TqAuth(""信易账户"", ""账户密码""))    sim.set_commission(""SHFE.cu2112"", 50)    print(sim.get_commission(""SHFE.cu2112""))   """"""   if commission != commission:    raise Exception(""合约手续费不可以设置为 float('nan')"")   quote = _get_obj(self._data, [""quotes"", symbol], Quote(self._api if hasattr(self, ""_api"") else None))   quote[""user_commission""] = commission   if self._quote_tasks.get(symbol):    self._quote_tasks[symbol][""quote_chan""].send_nowait({     ""quotes"": {symbol: {""user_commission"": commission}}    })   return commission  def set_margin(self, symbol: str, margin: float=float('nan')):   """"""   设置指定合约模拟交易的每手保证金。   Args:    symbol (str): 合约代码 (只支持期货合约)    margin (float): 每手保证金   Returns:    float: 设置的每手保证金   Example::    from tqsdk import TqSim, TqApi, TqAuth    sim = TqSim()    api = TqApi(sim, auth=TqAuth(""信易账户"", ""账户密码""))    sim.set_margin(""SHFE.cu2112"", 26000)    print(sim.get_margin(""SHFE.cu2112""))   """"""   if margin != margin:    raise Exception(""合约手续费不可以设置为 float('nan')"")   quote = _get_obj(self._data, [""quotes"", symbol], Quote(self._api if hasattr(self, ""_api"") else None))   quote[""user_margin""] = margin   if self._quote_tasks.get(symbol):    self._quote_tasks[symbol][""quote_chan""].send_nowait({     ""quotes"": {symbol: {""user_margin"": margin}}    })    # 当用户设置保证金时，用户应该得到的效果是：    # 在调用 sim.set_margin() 之后，立即调用 api.get_position(symbol)，得到的 margin 字段应该按照新设置的保证金调整过，而且中间没有收到过行情更新包    # 以下代码可以保证这个效果，说明：    # 1. 持仓已经调整过:    # sim_trade 中持仓的 future_margin 字段更新，margin 会同时调整，那么 api 中持仓的 future_margin 更新时，margin 一定也已经更新    # 2. 中间没有收到过行情更新包:    # 前提1：根据 diff 协议，sim 收到 peek_message 时，会将缓存的 diffs 发给用户，当缓存的 diffs 为空，会转发 peek_message；    # 前提2：api.wait_update() 会等到所有 task 都执行到 pending 状态，然后发送 peek_message 给 sim    # 当用户代码执行到 sim.set_margin()，立即向 quote_chan 中发送一个数据包，quote_task 就会到 ready 状态，此时调用 wait_update()，    # 到所有 task 执行到 pending 状态时，sim 的 diffs 中有数据了，此时收到 api 发来 peek_message 不会转发给上游，用户会先收到 sim 本身的账户数据，    # 在下一次 wait_update，sim 的 diffs 为空，才会收到行情数据    # 在回测时，以下代码应该只经历一次 wait_update    while margin != self.get_position(symbol).get(""future_margin""):     self._api.wait_update()   return margin  def get_margin(self, symbol: str):   """"""   获取指定合约模拟交易的每手保证金。   Args:    symbol (str): 合约代码   Returns:    float: 返回合约模拟交易的每手保证金   Example::    from tqsdk import TqSim, TqApi, TqAuth    sim = TqSim()    api = TqApi(sim, auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SHFE.cu2112"")    print(sim.get_margin(""SHFE.cu2112""))   """"""   return _get_future_margin(self._data.get(""quotes"", {}).get(symbol, {}))  def get_commission(self, symbol: str):   """"""   获取指定合约模拟交易的每手手续费   Args:    symbol (str): 合约代码   Returns:    float: 返回合约模拟交易的每手手续费   Example::    from tqsdk import TqSim, TqApi, TqAuth    sim = TqSim()    api = TqApi(sim, auth=TqAuth(""信易账户"", ""账户密码""))    quote = api.get_quote(""SHFE.cu2112"")    print(sim.get_commission(""SHFE.cu2112""))   """"""   return _get_commission(self._data.get(""quotes"", {}).get(symbol, {}))  def _handle_on_alive(self, msg, order):   """"""   在 order 状态变为 ALIVE 调用，屏幕输出信息，打印日志   """"""   symbol = f""{order['exchange_id']}.{order['instrument_id']}""   self._api._print(    f""模拟交易下单 {self._account_name}, {order['order_id']}: 时间: {_timestamp_nano_to_str(order['insert_date_time'])}, ""    f""合约: {symbol}, 开平: {order['offset']}, 方向: {order['direction']}, 手数: {order['volume_left']}, ""    f""价格: {order.get('limit_price', '市价')}"")   self._logger.debug(msg, order_id=order[""order_id""], datetime=order[""insert_date_time""],       symbol=symbol, offset=order[""offset""], direction=order[""direction""],       volume_left=order[""volume_left""], limit_price=order.get(""limit_price"", ""市价""))  def _handle_on_finished(self, msg, order):   """"""   在 order 状态变为 FINISHED 调用，屏幕输出信息，打印日志   """"""   self._api._print(f""模拟交易委托单 {self._account_name}, {order['order_id']}: {order['last_msg']}"")   self._logger.debug(msg, order_id=order[""order_id""], last_msg=order[""last_msg""], status=order[""status""],       volume_orign=order[""volume_orign""], volume_left=order[""volume_left""])  def _report(self):   if not self.trade_log:    return   date_keys = sorted(self.trade_log.keys())   self._api._print(f""模拟交易成交记录, 账户: {self._account_name}"")   for d in date_keys:    for t in self.trade_log[d][""trades""]:     symbol = t[""exchange_id""] + ""."" + t[""instrument_id""]     self._api._print(f""时间: {_timestamp_nano_to_str(t['trade_date_time'])}, 合约: {symbol}, ""         f""开平: {t['offset']}, 方向: {t['direction']}, 手数: {t['volume']}, 价格: {t['price']:.3f},""         f""手续费: {t['commission']:.2f}"")   self._api._print(f""模拟交易账户资金, 账户: {self._account_name}"")   for d in date_keys:    account = self.trade_log[d][""account""]    self._api._print(     f""日期: {d}, 账户权益: {account['balance']:.2f}, 可用资金: {account['available']:.2f}, ""     f""浮动盈亏: {account['float_profit']:.2f}, 持仓盈亏: {account['position_profit']:.2f}, ""     f""平仓盈亏: {account['close_profit']:.2f}, 市值: {account['market_value']:.2f}, ""     f""保证金: {account['margin']:.2f}, 手续费: {account['commission']:.2f}, ""     f""风险度: {account['risk_ratio'] * 100:.2f}%"")   # TqReport 模块计算交易统计信息   report = TqReport(report_id=self._account_id, trade_log=self.trade_log, quotes=self._data['quotes'])   self.tqsdk_stat = report.default_metrics   self._api._print(    f""胜率: {self.tqsdk_stat['winning_rate'] * 100:.2f}%, 盈亏额比例: {self.tqsdk_stat['profit_loss_ratio']:.2f}, ""    f""收益率: {self.tqsdk_stat['ror'] * 100:.2f}%, 年化收益率: {self.tqsdk_stat['annual_yield'] * 100:.2f}%, ""    f""最大回撤: {self.tqsdk_stat['max_drawdown'] * 100:.2f}%, 年化夏普率: {self.tqsdk_stat['sharpe_ratio']:.4f},""    f""年化索提诺比率: {self.tqsdk_stat['sortino_ratio']:.4f}"")   # 回测情况下，在计算报告之后，还会发送绘制图表请求，   # 这样处理，用户不要修改代码，就能够看到报告图表   if self._tqsdk_backtest:    self._api.draw_report(report.full()) "
191,n\tqsdk\tradeable\sim\tqsim stoc,"n\tqsdk\tradeable\sim\tqsim stoc. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' from tqsdk.tradeable.mixin import StockMixin from tqsdk.datetime import _timestamp_nano_to_str from tqsdk.report import TqReport from tqsdk.tradeable.sim.basesim import BaseSim from tqsdk.tradeable.sim.trade_stock import SimTradeStock class TqSimStock(BaseSim, StockMixin):  """"""  天勤股票模拟交易类  该类实现了一个本地的股票模拟交易账户，并且在内部完成撮合交易，在回测模式下，只能使用 TqSimStock 账户来交易股票合约。  股票模拟交易只支持 ins_class 字段为 'STOCK' 的合约，且不支持 T+0 交易。  限价单要求报单价格达到或超过对手盘价格才能成交, 成交价为报单价格, 如果没有对手盘(涨跌停)则无法成交  市价单使用对手盘价格成交, 如果没有对手盘(涨跌停)则自动撤单  模拟交易不会有部分成交的情况, 要成交就是全部成交  TqSimStock 暂不支持设置手续费  """"""  def __init__(self, init_balance: float = 10000000.0, account_id: str = None) -> None:   """"""   Args:    init_balance (float): [可选]初始资金, 默认为一千万    account_id (str): [可选]帐号, 默认为 TQSIM_STOCK   Example1::    # 修改TqSim模拟帐号的初始资金为100000    from tqsdk import TqApi, TqSimStock, TqAuth    api = TqApi(TqSimStock(init_balance=100000), auth=TqAuth(""信易账户"", ""账户密码""))   Example2::    # 同时使用 TqSim 交易期货，TqSimStock 交易股票    from tqsdk import TqApi, TqAuth, TqMultiAccount, TqSim, TqSimStock    tqsim_future = TqSim()    tqsim_stock = TqSimStock()    api = TqApi(account=TqMultiAccount([tqsim_future, tqsim_stock]), auth=TqAuth(""信易账户"", ""账户密码""))    # 多账户下单，需要指定下单账户    order1 = api.insert_order(symbol=""SHFE.cu2112"", direction=""BUY"", offset=""OPEN"", volume=10, limit_price=72250.0, account=tqsim_future)    order2 = api.insert_order(symbol=""SSE.603666"", direction=""BUY"", volume=300, account=tqsim_stock)    while order1.status != 'FINISHED' or order2.status != 'FINISHED':     api.wait_update()    # 打印账户可用资金    future_account = tqsim_future.get_account()    stock_account = tqsim_stock.get_account()    print(future_account.available, stock_account.available)    api.close()   Example3::    # 在回测模式下，同时使用 TqSim 交易期货，TqSimStock 交易股票    tqsim_future = TqSim()    tqsim_stock = TqSimStock()    api = TqApi(account=TqMultiAccount([tqsim_future, tqsim_stock]),       backtest=TqBacktest(start_dt=datetime(2021, 7, 12), end_dt=datetime(2021, 7, 14)),       auth=TqAuth(""信易账户"", ""账户密码""))    future_quote = api.get_quote(""SHFE.cu2112"")    future_stock = api.get_quote(""SSE.603666"")    while datetime.strptime(future_stock.datetime, ""%Y-%m-%d %H:%M:%S.%f"") < datetime(2021, 7, 12, 9, 50):     api.wait_update()    # 开仓，多账户下单，需要指定下单账户    order1 = api.insert_order(symbol=""SHFE.cu2112"", direction=""BUY"", offset=""OPEN"", volume=10, limit_price=future_quote.ask_price1, account=tqsim_future)    order2 = api.insert_order(symbol=""SSE.603666"", direction=""BUY"", volume=300, account=tqsim_stock)    while order1.status != 'FINISHED' or order2.status != 'FINISHED':     api.wait_update()    future_account = tqsim_future.get_account()    stock_account = tqsim_stock.get_account()    # 打印账户当前可用资金    print(future_account.available, stock_account.available)    # 等待行情回测到第二天    while datetime.strptime(future_stock.datetime, ""%Y-%m-%d %H:%M:%S.%f"") < datetime(2021, 7, 13, 10, 30):     api.wait_update()    # 平仓，股票只能 T+1 交易    order3 = api.insert_order(symbol=""SHFE.cu2112"", direction=""SELL"", offset=""CLOSE"", volume=8, limit_price=future_quote.bid_price1, account=tqsim_future)    order4 = api.insert_order(symbol=""SSE.603666"", direction=""SELL"", volume=200, account=tqsim_stock)    while order3.status != 'FINISHED' or order4.status != 'FINISHED':     api.wait_update()    try: # 等到回测结束     while True:      api.wait_update()    except BacktestFinished:     # 打印回测时间内账户交易信息统计结果     print(tqsim_future.tqsdk_stat)     print(tqsim_stock.tqsdk_stat)     api.close()   """"""   if float(init_balance) <= 0:    raise Exception(""初始资金(init_balance) %s 错误, 请检查 init_balance 是否填写正确"" % (init_balance))   super(TqSimStock, self).__init__(account_id=""TQSIM_STOCK"" if account_id is None else account_id,           init_balance=float(init_balance),           trade_class=SimTradeStock)  @property  def _account_info(self):   info = super(TqSimStock, self)._account_info   info.update({    ""account_type"": self._account_type   })   return info  def _handle_on_alive(self, msg, order):   """"""   在 order 状态变为 ALIVE 调用，屏幕输出信息，打印日志   """"""   symbol = f""{order['exchange_id']}.{order['instrument_id']}""   self._api._print(    f""模拟交易下单 {self._account_name}, {order['order_id']}: 时间: {_timestamp_nano_to_str(order['insert_date_time'])}, ""    f""合约: {symbol}, 方向: {order['direction']}, 手数: {order['volume_left']}, ""    f""价格: {order.get('limit_price', '市价')}"")   self._logger.debug(msg, order_id=order[""order_id""], datetime=order[""insert_date_time""],       symbol=symbol, direction=order[""direction""],       volume_left=order[""volume_left""], limit_price=order.get(""limit_price"", ""市价""))  def _handle_on_finished(self, msg, order):   """"""   在 order 状态变为 FINISHED 调用，屏幕输出信息，打印日志   """"""   self._api._print(f""模拟交易委托单 {self._account_name}, {order['order_id']}: {order['last_msg']}"")   self._logger.debug(msg, order_id=order[""order_id""], last_msg=order[""last_msg""], status=order[""status""],       volume_orign=order[""volume_orign""], volume_left=order[""volume_left""])  def _report(self):   if not self.trade_log:    return   date_keys = sorted(self.trade_log.keys())   self._api._print(f""模拟交易成交记录, 账户: {self._account_name}"")   for d in date_keys:    for t in self.trade_log[d][""trades""]:     symbol = t[""exchange_id""] + ""."" + t[""instrument_id""]     self._api._print(f""时间: {_timestamp_nano_to_str(t['trade_date_time'])}, 合约: {symbol}, ""         f""方向: {t['direction']}, 手数: {t['volume']}, 价格: {t['price']:.3f}, 手续费: {t['fee']:.2f}"")   self._api._print(f""模拟交易账户资金, 账户: {self._account_name}"")   for d in date_keys:    account = self.trade_log[d][""account""]    self._api._print(     f""日期: {d}, 账户资产: {account['asset']:.2f}, 分红: {account['dividend_balance_today']:.2f}, ""     f""买入成本: {account['cost']:.2f}, 盈亏: {account['profit_today']:.2f}, 盈亏比: {account['profit_rate_today']:.2f}, ""     f""手续费: {account['buy_fee_today'] + account['sell_fee_today']:.2f}"")   report = TqReport(report_id=self._account_id, trade_log=self.trade_log, quotes=self._data['quotes'], account_type=""SPOT"")   self.tqsdk_stat = report.default_metrics   self._api._print(    f""收益率: {self.tqsdk_stat['ror'] * 100:.2f}%, 年化收益率: {self.tqsdk_stat['annual_yield'] * 100:.2f}%, ""    f""最大回撤: {self.tqsdk_stat['max_drawdown'] * 100:.2f}%, 年化夏普率: {self.tqsdk_stat['sharpe_ratio']:.4f},""    f""年化索提诺比率: {self.tqsdk_stat['sortino_ratio']:.4f}"") "
192,n\tqsdk\tradeable\sim\trad,"n\tqsdk\tradeable\sim\trad. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' import math from tqsdk.tradeable.sim.trade_base import SimTradeBase from tqsdk.tradeable.sim.utils import _get_option_margin, _get_premium, _get_close_profit, _get_commission, _get_future_margin class SimTrade(SimTradeBase):  """"""  天勤模拟交易账户，期货及商品期权  """"""  def _generate_account(self, init_balance):   return {    ""currency"": ""CNY"",    ""pre_balance"": init_balance,    ""static_balance"": init_balance,    ""balance"": init_balance,    ""available"": init_balance,    ""float_profit"": 0.0,    ""position_profit"": 0.0, # 期权没有持仓盈亏    ""close_profit"": 0.0,    ""frozen_margin"": 0.0,    ""margin"": 0.0,    ""frozen_commission"": 0.0,    ""commission"": 0.0,    ""frozen_premium"": 0.0,    ""premium"": 0.0,    ""deposit"": 0.0,    ""withdraw"": 0.0,    ""risk_ratio"": 0.0,    ""market_value"": 0.0,    ""ctp_balance"": float(""nan""),    ""ctp_available"": float(""nan"")   }  def _generate_position(self, symbol, quote, underlying_quote) -> dict:   return {    ""exchange_id"": symbol.split(""."", maxsplit=1)[0],    ""instrument_id"": symbol.split(""."", maxsplit=1)[1],    ""pos_long_his"": 0,    ""pos_long_today"": 0,    ""pos_short_his"": 0,    ""pos_short_today"": 0,    ""volume_long_today"": 0,    ""volume_long_his"": 0,    ""volume_long"": 0,    ""volume_long_frozen_today"": 0,    ""volume_long_frozen_his"": 0,    ""volume_long_frozen"": 0,    ""volume_short_today"": 0,    ""volume_short_his"": 0,    ""volume_short"": 0,    ""volume_short_frozen_today"": 0,    ""volume_short_frozen_his"": 0,    ""volume_short_frozen"": 0,    ""open_price_long"": float(""nan""),    ""open_price_short"": float(""nan""),    ""open_cost_long"": 0.0,    ""open_cost_short"": 0.0,    ""position_price_long"": float(""nan""),    ""position_price_short"": float(""nan""),    ""position_cost_long"": 0.0,    ""position_cost_short"": 0.0,    ""float_profit_long"": 0.0,    ""float_profit_short"": 0.0,    ""float_profit"": 0.0,    ""position_profit_long"": 0.0,    ""position_profit_short"": 0.0,    ""position_profit"": 0.0,    ""margin_long"": 0.0,    ""margin_short"": 0.0,    ""margin"": 0.0,    ""last_price"": quote[""last_price""],    ""underlying_last_price"": underlying_quote[""last_price""] if underlying_quote else float(""nan""),    ""market_value_long"": 0.0, # 权利方市值(始终 >= 0)    ""market_value_short"": 0.0, # 义务方市值(始终 <= 0)    ""market_value"": 0.0,    ""future_margin"": _get_future_margin(quote),   }  def _generate_order(self, pack: dict) -> dict:   """"""order 对象预处理""""""   order = pack.copy()   order[""exchange_order_id""] = order[""order_id""]   order[""volume_orign""] = order[""volume""]   order[""volume_left""] = order[""volume""]   order[""frozen_margin""] = 0.0   order[""frozen_premium""] = 0.0   order[""last_msg""] = ""报单成功""   order[""status""] = ""ALIVE""   order[""insert_date_time""] = self._get_trade_timestamp()   del order[""aid""]   del order[""volume""]   self._append_to_diffs(['orders', order[""order_id""]], order)   return order  def _generate_trade(self, order, quote, price) -> dict:   trade_id = order[""order_id""] + ""|"" + str(order[""volume_left""])   return {    ""user_id"": order[""user_id""],    ""order_id"": order[""order_id""],    ""trade_id"": trade_id,    ""exchange_trade_id"": order[""order_id""] + ""|"" + str(order[""volume_left""]),    ""exchange_id"": order[""exchange_id""],    ""instrument_id"": order[""instrument_id""],    ""direction"": order[""direction""],    ""offset"": order[""offset""],    ""price"": price,    ""volume"": order[""volume_left""],    ""trade_date_time"": self._get_trade_timestamp(), # todo: 可能导致测试结果不确定    ""commission"": order[""volume_left""] * _get_commission(quote)   }  def _on_settle(self):   for symbol in self._orders:    for order in self._orders[symbol].values():     order[""frozen_margin""] = 0.0     order[""frozen_premium""] = 0.0     order[""last_msg""] = ""交易日结束，自动撤销当日有效的委托单（GFD）""     order[""status""] = ""FINISHED""     self._append_to_diffs(['orders', order[""order_id""]], order)   # account 原始字段   self._account[""pre_balance""] = self._account[""balance""] - self._account[""market_value""]   self._account[""close_profit""] = 0.0   self._account[""commission""] = 0.0   self._account[""premium""] = 0.0   self._account[""frozen_margin""] = 0.0   self._account[""frozen_premium""] = 0.0   # account 计算字段   self._account[""static_balance""] = self._account[""pre_balance""]   self._account[""position_profit""] = 0.0   self._account[""risk_ratio""] = self._account[""margin""] / self._account[""balance""]   self._account[""available""] = self._account[""static_balance""] - self._account[""margin""]   # 根据公式 账户权益 不需要计算 self._account[""balance""] = static_balance + market_value   self._append_to_diffs(['accounts', 'CNY'], self._account)   # 对于持仓的结算放在这里，没有放在 quote_handler 里的原因：   # 1. 异步发送的话，会造成如果此时 sim 未收到 pending_peek, 就没法把结算的账户信息发送出去，此时用户代码中 api.get_postion 得到的持仓和 sim 里面的持仓是不一致的   # set_target_pos 下单时就会产生错单。而且结算时一定是已经收到过行情的数据包，在同步代码的最后一步，会发送出去这个行情包 peeding_peek，   # quote_handler 处理 settle 的时候, 所以在结算的时候 pending_peek 一定是 False, 要 api 处理过之后，才会收到 peek_message   # 2. 同步发送的话，就可以和产生切换交易日的数据包同时发送出去   # 对 order 的处理发生在下一次回复 peek_message   for position in self._positions.values():    symbol = f""{position['exchange_id']}.{position['instrument_id']}""    # position 原始字段    position[""volume_long_frozen_today""] = 0    position[""volume_long_frozen_his""] = 0    position[""volume_short_frozen_today""] = 0    position[""volume_short_frozen_his""] = 0    position[""volume_long_today""] = 0    position[""volume_long_his""] = position[""volume_long""]    position[""volume_short_today""] = 0    position[""volume_short_his""] = position[""volume_short""]    # position 计算字段    position[""pos_long_his""] = position[""volume_long_his""]    position[""pos_long_today""] = 0    position[""pos_short_his""] = position[""volume_short_his""]    position[""pos_short_today""] = 0    position[""volume_long_frozen""] = 0    position[""volume_short_frozen""] = 0    position[""position_price_long""] = position[""last_price""]    position[""position_price_short""] = position[""last_price""]    quote, _ = self._get_quotes_by_symbol(symbol)    position[""position_cost_long""] = position[""last_price""] * position[""volume_long""] * quote[""volume_multiple""] # position 原始字段    position[""position_cost_short""] = position[""last_price""] * position[""volume_short""] * quote[""volume_multiple""] # position 原始字段    position[""position_profit_long""] = 0    position[""position_profit_short""] = 0    position[""position_profit""] = 0    self._append_to_diffs(['positions', symbol], position)  def _check_insert_order(self, order, symbol, position, quote, underlying_quote=None):   # 无法计入 orderbook, 各种账户都需要判断的   if (""commission"" not in quote or ""margin"" not in quote) and not quote[""ins_class""].endswith(""OPTION""):    order[""last_msg""] = ""不支持的合约类型，TqSim 目前不支持组合，股票，etf期权模拟交易""    order[""status""] = ""FINISHED""   if order[""status""] == ""ALIVE"" and not self._is_in_trading_time(quote):    order[""last_msg""] = ""下单失败, 不在可交易时间段内""    order[""status""] = ""FINISHED""   if order[""status""] == ""ALIVE"" and order[""offset""].startswith('CLOSE'):    if order[""exchange_id""] in [""SHFE"", ""INE""]:     if order[""offset""] == ""CLOSETODAY"":      if order[""direction""] == ""BUY"" and position[""volume_short_today""] - position[""volume_long_frozen_today""] < order[""volume_orign""]:       order[""last_msg""] = ""平今仓手数不足""      elif order[""direction""] == ""SELL"" and position[""volume_long_today""] - position[""volume_long_frozen_today""] < order[""volume_orign""]:       order[""last_msg""] = ""平今仓手数不足""     if order[""offset""] == ""CLOSE"":      if order[""direction""] == ""BUY"" and position[""volume_short_his""] - position[""volume_short_frozen_his""] < order[""volume_orign""]:       order[""last_msg""] = ""平昨仓手数不足""      elif order[""direction""] == ""SELL"" and position[""volume_long_his""] - position[""volume_long_frozen_his""] < order[""volume_orign""]:       order[""last_msg""] = ""平昨仓手数不足""    else:     if order[""direction""] == ""BUY"" and position[""volume_short""] - position[""volume_short_frozen""] < order[""volume_orign""]:      order[""last_msg""] = ""平仓手数不足""     elif order[""direction""] == ""SELL"" and position[""volume_long""] - position[""volume_long_frozen""] < order[""volume_orign""]:      order[""last_msg""] = ""平仓手数不足""    if order[""last_msg""].endswith(""手数不足""):     order[""status""] = ""FINISHED""   if order[""status""] == ""ALIVE"" and order[""offset""] == ""OPEN"":    # 计算冻结保证金，冻结权利金    if quote[""ins_class""].endswith(""OPTION""):     if order[""direction""] == ""SELL"": # 期权的SELL义务仓，开仓需要冻结保证金      order[""frozen_margin""] = order[""volume_orign""] * _get_option_margin(quote, quote[""last_price""], underlying_quote[""last_price""])     else: # 期权的BUY权利仓（市价单使用 last_price 计算需要冻结的权利金）      price = quote[""last_price""] if order[""price_type""] == ""ANY"" else order[""limit_price""]      order[""frozen_premium""] = order[""volume_orign""] * quote[""volume_multiple""] * price    else:     order[""frozen_margin""] = order[""volume_orign""] * _get_future_margin(quote)    if order[""frozen_margin""] + order[""frozen_premium""] > self._account[""available""]:     order[""frozen_margin""] = 0.0     order[""frozen_premium""] = 0.0     order[""last_msg""] = '开仓资金不足'     order[""status""] = ""FINISHED""   if order[""status""] == ""FINISHED"":    self._append_to_diffs(['orders', order[""order_id""]], order)  def _on_insert_order(self, order, symbol, position, quote, underlying_quote=None):   """"""判断 order 是否可以记录在 orderbook""""""   if order[""offset""] == ""OPEN"":    # 修改 account 计算字段    self._adjust_account_by_order(frozen_margin=order[""frozen_margin""], frozen_premium=order[""frozen_premium""])    self._append_to_diffs(['accounts', 'CNY'], self._account)   else:    # 修改 position 原始字段    if order[""exchange_id""] in [""SHFE"", ""INE""]:     if order[""direction""] == ""BUY"":      position[f""volume_short_frozen_{'today' if order['offset'] == 'CLOSETODAY' else 'his'}""] += order[""volume_orign""]     else:      position[f""volume_long_frozen_{'today' if order['offset'] == 'CLOSETODAY' else 'his'}""] += order[""volume_orign""]    elif order[""direction""] == ""BUY"":     volume_short_his_available = position[""volume_short_his""] - position[""volume_short_frozen_his""]     if volume_short_his_available < order[""volume_orign""]:      position[""volume_short_frozen_his""] += volume_short_his_available      position[""volume_short_frozen_today""] += order[""volume_orign""] - volume_short_his_available     else:      position[""volume_short_frozen_his""] += order[""volume_orign""]    else:     volume_long_his_available = position[""volume_long_his""] - position[""volume_long_frozen_his""]     if volume_long_his_available < order[""volume_orign""]:      position[""volume_long_frozen_his""] += volume_long_his_available      position[""volume_long_frozen_today""] += order[""volume_orign""] - volume_long_his_available     else:      position[""volume_long_frozen_his""] += order[""volume_orign""]    # 修改 position 计算字段    self._adjust_position_volume_frozen(position)    self._append_to_diffs(['positions', symbol], position)  def _on_order_traded(self, order, trade, symbol, position, quote, underlying_quote):   origin_frozen_margin = order[""frozen_margin""]   origin_frozen_premium = order[""frozen_premium""]   order[""frozen_margin""] = 0.0   order[""frozen_premium""] = 0.0   order[""volume_left""] = 0   order[""last_msg""] = ""全部成交""   order[""status""] = ""FINISHED""   self._append_to_diffs(['trades', trade[""trade_id""]], trade)   self._append_to_diffs(['orders', order[""order_id""]], order)   position = self._ensure_position(symbol, quote, underlying_quote)   if order[""offset""] == 'OPEN':    if order[""direction""] == ""BUY"":     # 修改 position 原始字段     position[""volume_long_today""] += order[""volume_orign""]     position[""open_cost_long""] += trade[""price""] * order[""volume_orign""] * quote[""volume_multiple""] # 多头开仓成本     position[""position_cost_long""] += trade[""price""] * order[""volume_orign""] * quote[""volume_multiple""] # 多头持仓成本    else:     # 修改 position 原始字段     position[""volume_short_today""] += order[""volume_orign""]     position[""open_cost_short""] += trade[""price""] * order[""volume_orign""] * quote[""volume_multiple""] # 空头开仓成本     position[""position_cost_short""] += trade[""price""] * order[""volume_orign""] * quote[""volume_multiple""] # 空头持仓成本    # 由 order 变化，account 需要更新的计算字段    self._adjust_account_by_order(frozen_margin=-origin_frozen_margin, frozen_premium=-origin_frozen_premium)    # 由 trade 引起的 account 原始字段变化，account 需要更新的计算字段    premium = _get_premium(trade, quote)    self._adjust_account_by_trade(commission=trade[""commission""], premium=premium)    # 由 position 字段变化，同时 account 需要更新的计算字段    buy_open = order[""volume_orign""] if order[""direction""] == ""BUY"" else 0    sell_open = 0 if order[""direction""] == ""BUY"" else order[""volume_orign""]    self._adjust_position_account(symbol, quote, underlying_quote,           pre_last_price=trade[""price""],           last_price=position[""last_price""],           pre_underlying_last_price=underlying_quote[""last_price""] if underlying_quote else float('nan'),           underlying_last_price=position[""underlying_last_price""],           buy_open=buy_open, sell_open=sell_open)   else: # order[""offset""].startswith('CLOSE')    # 修改 position 原始字段    if order[""exchange_id""] in [""SHFE"", ""INE""]:     if order[""offset""] == ""CLOSETODAY"":      if order[""direction""] == ""BUY"":       position[""volume_short_frozen_today""] -= order[""volume_orign""]       position[""volume_short_today""] -= order[""volume_orign""]      elif order[""direction""] == ""SELL"":       position[""volume_long_frozen_today""] -= order[""volume_orign""]       position[""volume_long_today""] -= order[""volume_orign""]     if order[""offset""] == ""CLOSE"":      if order[""direction""] == ""BUY"":       position[""volume_short_frozen_his""] -= order[""volume_orign""]       position[""volume_short_his""] -= order[""volume_orign""]      elif order[""direction""] == ""SELL"":       position[""volume_long_frozen_his""] -= order[""volume_orign""]       position[""volume_long_his""] -= order[""volume_orign""]    elif order[""direction""] == ""BUY"":     if position[""volume_short_frozen_his""] >= order[""volume_orign""]:      position[""volume_short_frozen_his""] -= order[""volume_orign""]      position[""volume_short_his""] -= order[""volume_orign""]     else:      position[""volume_short_frozen_today""] -= order[""volume_orign""] - position[""volume_short_frozen_his""]      position[""volume_short_today""] -= order[""volume_orign""] - position[""volume_short_frozen_his""]      position[""volume_short_his""] -= position[""volume_short_frozen_his""]      position[""volume_short_frozen_his""] = 0    else:     if position[""volume_long_frozen_his""] >= order[""volume_orign""]:      position[""volume_long_frozen_his""] -= order[""volume_orign""]      position[""volume_long_his""] -= order[""volume_orign""]     else:      position[""volume_long_frozen_today""] -= order[""volume_orign""] - position[""volume_long_frozen_his""]      position[""volume_long_today""] -= order[""volume_orign""] - position[""volume_long_frozen_his""]      position[""volume_long_his""] -= position[""volume_long_frozen_his""]      position[""volume_long_frozen_his""] = 0    # 修改 position 原始字段    if order[""direction""] == ""SELL"":     position[""open_cost_long""] -= position[""open_price_long""] * order[""volume_orign""] * quote[""volume_multiple""] # 多头开仓成本     position[""position_cost_long""] -= position[""position_price_long""] * order[""volume_orign""] * quote[""volume_multiple""] # 多头持仓成本    else:     position[""open_cost_short""] -= position[""open_price_short""] * order[""volume_orign""] * quote[""volume_multiple""] # 空头开仓成本     position[""position_cost_short""] -= position[""position_price_short""] * order[""volume_orign""] * quote[""volume_multiple""] # 空头持仓成本    # 由 trade 引起的 account 原始字段变化，account 需要更新的计算字段    premium = _get_premium(trade, quote)    close_profit = _get_close_profit(trade, quote, position)    self._adjust_account_by_trade(commission=trade[""commission""], premium=premium, close_profit=close_profit)    # 由 position 字段变化，同时 account 需要更新的计算字段    buy_close = order[""volume_orign""] if order[""direction""] == ""BUY"" else 0    sell_close = 0 if order[""direction""] == ""BUY"" else order[""volume_orign""]    self._adjust_position_account(symbol, quote, underlying_quote, pre_last_price=position[""last_price""],           last_price=0, pre_underlying_last_price=position[""underlying_last_price""],           underlying_last_price=0, buy_close=buy_close, sell_close=sell_close)   self._append_to_diffs(['positions', symbol], position)   self._append_to_diffs(['accounts', 'CNY'], self._account)  def _on_order_failed(self, symbol, order):   origin_frozen_margin = order[""frozen_margin""]   origin_frozen_premium = order[""frozen_premium""]   order[""frozen_margin""] = 0.0   order[""frozen_premium""] = 0.0   self._append_to_diffs(['orders', order[""order_id""]], order)   # 调整账户和持仓   if order[""offset""] == 'OPEN':    self._adjust_account_by_order(frozen_margin=-origin_frozen_margin, frozen_premium=-origin_frozen_premium)    self._append_to_diffs(['accounts', 'CNY'], self._account)   else:    position = self._positions[symbol]    if order[""exchange_id""] in [""SHFE"", ""INE""]:     if order[""offset""] == ""CLOSETODAY"":      if order[""direction""] == ""BUY"":       position[""volume_short_frozen_today""] -= order[""volume_orign""]      else:       position[""volume_long_frozen_today""] -= order[""volume_orign""]     if order[""offset""] == ""CLOSE"":      if order[""direction""] == ""BUY"":       position[""volume_short_frozen_his""] -= order[""volume_orign""]      else:       position[""volume_long_frozen_his""] -= order[""volume_orign""]    else:     if order[""direction""] == ""BUY"":      if position[""volume_short_frozen_today""] >= order[""volume_orign""]:       position[""volume_short_frozen_today""] -= order[""volume_orign""]      else:       position[""volume_short_frozen_his""] -= order[""volume_orign""] - position[""volume_short_frozen_today""]       position[""volume_short_frozen_today""] = 0     else:      if position[""volume_long_frozen_today""] >= order[""volume_orign""]:       position[""volume_long_frozen_today""] -= order[""volume_orign""]      else:       position[""volume_long_frozen_his""] -= order[""volume_orign""] - position[""volume_long_frozen_today""]       position[""volume_long_frozen_today""] = 0    self._adjust_position_volume_frozen(position)    self._append_to_diffs(['positions', symbol], position)  def _on_update_quotes(self, symbol, position, quote, underlying_quote):   # 调整持仓保证金和盈亏   position = self._positions.get(symbol)   underlying_last_price = underlying_quote[""last_price""] if underlying_quote else float('nan')   future_margin = _get_future_margin(quote)   if position[""volume_long""] > 0 or position[""volume_short""] > 0:    if position[""last_price""] != quote[""last_price""] \      or (math.isnan(future_margin) or future_margin != position[""future_margin""]) \      or (underlying_quote and (      math.isnan(underlying_last_price) or underlying_last_price != position[""underlying_last_price""])):     self._adjust_position_account(symbol, quote, underlying_quote,            pre_last_price=position[""last_price""],            last_price=quote[""last_price""],            pre_underlying_last_price=position[""underlying_last_price""],            underlying_last_price=underlying_last_price)     position[""future_margin""] = future_margin     position[""last_price""] = quote[""last_price""]     position[""underlying_last_price""] = underlying_last_price   else:    # 修改辅助变量    position[""future_margin""] = future_margin    position[""last_price""] = quote[""last_price""]    position[""underlying_last_price""] = underlying_last_price   self._append_to_diffs(['positions', symbol], position) # 一定要返回 position，下游会用到 future_margin 字段判断修改保证金是否成功   self._append_to_diffs(['accounts', 'CNY'], self._account)  def _adjust_position_account(self, symbol, quote, underlying_quote=None, pre_last_price=float('nan'), last_price=float('nan'),         pre_underlying_last_price=float('nan'), underlying_last_price=float('nan'),         buy_open=0, buy_close=0, sell_open=0, sell_close=0):   """"""   价格变化，使得 position 中的以下计算字段需要修改，这个函数计算出需要修改的差值部分，计算出差值部分修改 position、account   有两种情况下调用   1. 委托单 FINISHED，且全部成交，分为4种：buy_open, buy_close, sell_open, sell_close   2. 行情跳动   """"""   position = self._positions[symbol]   float_profit_long = 0 # 多头浮动盈亏   float_profit_short = 0 # 空头浮动盈亏   position_profit_long = 0 # 多头持仓盈亏，期权持仓盈亏为0   position_profit_short = 0 # 空头持仓盈亏，期权持仓盈亏为0   margin_long = 0 # 多头占用保证金   margin_short = 0 # 空头占用保证金   market_value_long = 0 # 期权权利方市值(始终 >= 0)   market_value_short = 0 # 期权义务方市值(始终 <= 0)   assert [buy_open, buy_close, sell_open, sell_close].count(0) >= 3 # 只有一个大于0, 或者都是0，表示价格变化导致的字段修改   if buy_open > 0:    # 买开，pre_last_price 应该是成交价格，last_price 应该是 position['last_price']    float_profit_long = (last_price - pre_last_price) * buy_open * quote[""volume_multiple""]    if quote[""ins_class""].endswith(""OPTION""):     market_value_long = last_price * buy_open * quote[""volume_multiple""]    else:     margin_long = buy_open * _get_future_margin(quote)     position_profit_long = (last_price - pre_last_price) * buy_open * quote[""volume_multiple""]   elif sell_close > 0:    # 卖平，pre_last_price 应该是 position['last_price']，last_price 应该是 0    float_profit_long = -position[""float_profit_long""] / position[""volume_long""] * sell_close    if quote[""ins_class""].endswith(""OPTION""):     market_value_long = -pre_last_price * sell_close * quote[""volume_multiple""]    else:     margin_long = -sell_close * _get_future_margin(quote)     position_profit_long = -position[""position_profit_long""] / position[""volume_long""] * sell_close   elif sell_open > 0:    # 卖开    float_profit_short = (pre_last_price - last_price) * sell_open * quote[""volume_multiple""]    if quote[""ins_class""].endswith(""OPTION""):     market_value_short = -last_price * sell_open * quote[""volume_multiple""]     margin_short = sell_open * _get_option_margin(quote, last_price, underlying_last_price)    else:     margin_short = sell_open * _get_future_margin(quote)     position_profit_short = (pre_last_price - last_price) * sell_open * quote[""volume_multiple""]   elif buy_close > 0:    # 买平    float_profit_short = -position[""float_profit_short""] / position[""volume_short""] * buy_close    if quote[""ins_class""].endswith(""OPTION""):     market_value_short = pre_last_price * buy_close * quote[""volume_multiple""]     margin_short = -buy_close * _get_option_margin(quote, pre_last_price, pre_underlying_last_price)    else:     margin_short = -buy_close * _get_future_margin(quote)     position_profit_short = -position[""position_profit_short""] / position[""volume_short""] * buy_close   else:    float_profit_long = (last_price - pre_last_price) * position[""volume_long""] * quote[""volume_multiple""] # 多头浮动盈亏    float_profit_short = (pre_last_price - last_price) * position[""volume_short""] * quote[""volume_multiple""] # 空头浮动盈亏    if quote[""ins_class""].endswith(""OPTION""):     margin_short = _get_option_margin(quote, last_price, underlying_last_price) * position[""volume_short""] - position[""margin_short""]     market_value_long = (last_price - pre_last_price) * position[""volume_long""] * quote[""volume_multiple""]     market_value_short = (pre_last_price - last_price) * position[""volume_short""] * quote[""volume_multiple""]    else:     # 期权持仓盈亏为 0     position_profit_long = float_profit_long # 多头持仓盈亏     position_profit_short = float_profit_short # 空头持仓盈亏     margin_long = _get_future_margin(quote) * position[""volume_long""] - position[""margin_long""]     margin_short = _get_future_margin(quote) * position[""volume_short""] - position[""margin_short""]   if any([buy_open, buy_close, sell_open, sell_close]):    # 修改 position volume 相关的计算字段    # 在上面 sell_close buy_close 两种情况，计算浮动盈亏时，用到了修改前的手数，所以需改手数字段的代码放在这个位置    self._adjust_position_volume(position)   self._adjust_position(quote, position, float_profit_long, float_profit_short, position_profit_long,        position_profit_short, margin_long, margin_short, market_value_long, market_value_short)   self._adjust_account_by_position(float_profit=float_profit_long + float_profit_short,           position_profit=position_profit_long + position_profit_short,           margin=margin_long + margin_short,           market_value=market_value_long + market_value_short)  # -------- 对于 position 的计算字段修改分为两类：  # 1. 针对手数相关的修改，在下单、成交时会修改  # 2. 针对盈亏、保证金、市值的修改，由于参考合约最新价，在成交、行情跳动时会修改  def _adjust_position_volume_frozen(self, position):   """"""position 原始字段修改后，只有冻结手数需要重新计算，有两种情况需要调用   1. 下平仓单 2. 平仓单 FINISHED, 但没有成交   """"""   position[""volume_long_frozen""] = position[""volume_long_frozen_today""] + position[""volume_long_frozen_his""]   position[""volume_short_frozen""] = position[""volume_short_frozen_today""] + position[""volume_short_frozen_his""]  def _adjust_position_volume(self, position):   """"""position 原始字段修改后，手数之后需要重新计算   1. 委托单 FINISHED，且全部成交   """"""   position[""pos_long_today""] = position[""volume_long_today""]   position[""pos_long_his""] = position[""volume_long_his""]   position[""pos_short_today""] = position[""volume_short_today""]   position[""pos_short_his""] = position[""volume_short_his""]   position[""volume_long""] = position[""volume_long_today""] + position[""volume_long_his""]   position[""volume_long_frozen""] = position[""volume_long_frozen_today""] + position[""volume_long_frozen_his""]   position[""volume_short""] = position[""volume_short_today""] + position[""volume_short_his""]   position[""volume_short_frozen""] = position[""volume_short_frozen_today""] + position[""volume_short_frozen_his""]  def _adjust_position(self, quote, position, float_profit_long=0, float_profit_short=0, position_profit_long=0,         position_profit_short=0, margin_long=0, margin_short=0, market_value_long=0,         market_value_short=0):   # 更新 position 计算字段，根据差值更新的字段   position[""float_profit_long""] += float_profit_long   position[""float_profit_short""] += float_profit_short   position[""position_profit_long""] += position_profit_long   position[""position_profit_short""] += position_profit_short   position[""margin_long""] += margin_long   position[""margin_short""] += margin_short   position[""market_value_long""] += market_value_long   position[""market_value_short""] += market_value_short   # 更新 position 计算字段，原地重新计算的字段   if position[""volume_long""] > 0:    position[""open_price_long""] = position[""open_cost_long""] / position[""volume_long""] / quote[""volume_multiple""]    position[""position_price_long""] = position[""position_cost_long""] / position[""volume_long""] / quote[""volume_multiple""]   else:    position[""open_price_long""] = float(""nan"")    position[""position_price_long""] = float(""nan"")   if position[""volume_short""] > 0:    position[""open_price_short""] = position[""open_cost_short""] / position[""volume_short""] / quote[""volume_multiple""]    position[""position_price_short""] = position[""position_cost_short""] / position[""volume_short""] / quote[""volume_multiple""]   else:    position[""open_price_short""] = float(""nan"")    position[""position_price_short""] = float(""nan"")   position[""float_profit""] = position[""float_profit_long""] + position[""float_profit_short""]   position[""position_profit""] = position[""position_profit_long""] + position[""position_profit_short""]   position[""margin""] = position[""margin_long""] + position[""margin_short""]   position[""market_value""] = position[""market_value_long""] + position[""market_value_short""]  # -------- 对于 account 的修改分为以下三类  def _adjust_account_by_trade(self, commission=0, close_profit=0, premium=0):   """"""由成交引起的 account 原始字段变化，account 需要更新的计算字段""""""   # account 原始字段   self._account[""close_profit""] += close_profit   self._account[""commission""] += commission   self._account[""premium""] += premium # premium变量的值有正负，正数表示收入的权利金，负数表示付出的权利金   # account 计算字段   self._account[""balance""] += close_profit - commission + premium   self._account[""available""] += close_profit - commission + premium   self._account[""risk_ratio""] = self._account[""margin""] / self._account[""balance""]  def _adjust_account_by_position(self, float_profit=0, position_profit=0, margin=0, market_value=0):   """"""由 position 变化，account 需要更新的计算字段""""""   # account 计算字段，持仓字段求和的字段   self._account[""float_profit""] += float_profit   self._account[""position_profit""] += position_profit   self._account[""margin""] += margin   self._account[""market_value""] += market_value   # account 计算字段   self._account[""balance""] += position_profit + market_value   self._account[""available""] += position_profit - margin   self._account[""risk_ratio""] = self._account[""margin""] / self._account[""balance""]  def _adjust_account_by_order(self, frozen_margin=0, frozen_premium=0):   """"""由 order 变化，account 需要更新的计算字段""""""   self._account[""frozen_margin""] += frozen_margin   self._account[""frozen_premium""] += frozen_premium   self._account[""available""] -= (frozen_margin + frozen_premium) "
193,n\tqsdk\tradeable\sim\trade bas,"n\tqsdk\tradeable\sim\trade bas. #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' import math from abc import abstractmethod from datetime import datetime from typing import Callable from tqsdk.datetime import _is_in_trading_time, _str_to_timestamp_nano from tqsdk.diff import _simple_merge_diff from tqsdk.tradeable.sim.utils import _get_price_range class SimTradeBase(object):  """"""  本模块为 TqSim 交易部分的子模块的基类，纯同步计算，不涉及连接行情的动态信息，所以对于接口的调用有一些需要注意的要求  不同的账户类型继承本模块，并实现具体账户类型的计算  对外提供的接口:  + init_snapshot: 返回初始的账户截面信息  + insert_order -> (diffs, orders_events): 处理下单请求，调用 TqSimAccount.insert_order 之前应该调用过 update_quote，保证收到过合约的行情；期权还应该确保收到了标的的行情  + cancel_order -> (diffs, orders_events)：处理撤单请求  + update_quote -> (diffs, orders_events)：处理行情更新  + settle -> (diffs, _orders_events, trade_log)：处理结算请求  注意：  + diffs (list) : 每个元素都是符合 diff 协议中 trade 交易部分的数据包，且返回的都是完整字段的对象，比如：order成交时，返回的是order完整对象而不是有变化的字段  + orders_events (list) : 按照顺序记录 order 的更新，返回给调用方  + trade_log (dict) : 是结算前的账户日志信息  diffs 由子类负责调用 _append_to_diffs  orders_events 由父类统一处理在 order 状态变化时，在 list 中追加委托单实例  """"""  def __init__(self, account_key: str, account_id: str = """", init_balance: float = 10000000.0,     get_trade_timestamp: Callable = None, is_in_trading_time: Callable = None) -> None:   self._account_key = account_key   self._account_id = account_id   self._quotes = {} # 会记录所有的发来的行情   # 初始化账户结构   self._account = self._generate_account(init_balance)   self._positions = {} # {symbol: position, ...}   self._orders = {} # {symbol: {order_id: order}, ...}   self._trades = [] # list 类型，与重构之前代码保持一致，list 可以保留 trade 生产的顺序信息   self._diffs = []   self._orders_events = [] # 按照顺序记录 order 的更新，返回给调用方   self._max_datetime = """" # 所有 quotes 的最大行情更新时间   # 本模块在计算成交时间、判断是否在交易时间段内，默认使用所有 quotes 的最大行情更新时间当作当前时间，并且没有模拟到交易时的时间差   # 若外部调用模块需要更精确时间，则由外部模块提供函数支持   self._get_trade_timestamp = get_trade_timestamp if get_trade_timestamp else self._default_get_trade_timestamp   self._is_in_trading_time = is_in_trading_time if is_in_trading_time else self._default_is_in_trading_time  @abstractmethod  def _generate_account(self, init_balance: float) -> dict:   """"""返回 account 账户结构""""""   pass  @abstractmethod  def _generate_order(self, pack: dict) -> dict:   """"""返回 order 委托单结构""""""   pass  @abstractmethod  def _generate_trade(self, order, quote, price) -> dict:   """"""返回 trade 成交对象结构""""""   pass  @abstractmethod  def _generate_position(self, symbol, quote, underlying_quote) -> dict:   """"""返回 position 对象结构""""""   pass  @abstractmethod  def _check_insert_order(self, order, symbol, position, quote, underlying_quote):   """"""检查是否可以下单，在 order 原对象上修改属性""""""   pass  @abstractmethod  def _on_insert_order(self, order, symbol, position, quote, underlying_quote):   """"""将 order 记入 order_book 时调用""""""   pass  @abstractmethod  def _on_order_failed(self, symbol, order):   """"""处理 order 变为 FINISHED，且没有成交，撤单""""""   pass  @abstractmethod  def _on_order_traded(self, order, trade, symbol, position, quote, underlying_quote):   """"""处理 order 变为 FINISHED，且全部成交""""""   pass  @abstractmethod  def _on_update_quotes(self, symbol, position, quote, underlying_quote):   """"""更新合约行情后，更行对应的持仓及账户信息""""""   pass  @abstractmethod  def _on_settle(self):   """"""结算时，应该调整 委托单、持仓、账户""""""   pass  def init_snapshot(self):   """"""返回初始账户截面信息""""""   return {    ""trade"": {     self._account_key: {      ""accounts"": {""CNY"": self._account.copy()},      ""positions"": {},      ""orders"": {},      ""trades"": {}     }    }   }  def insert_order(self, symbol, pack):   quote, underlying_quote = self._get_quotes_by_symbol(symbol)   position = self._ensure_position(symbol, quote, underlying_quote)   order = self._generate_order(pack)   self._orders_events.append(order.copy())   self._check_insert_order(order, symbol, position, quote, underlying_quote)   if order[""status""] == ""FINISHED"":    self._orders_events.append(order.copy())   else:    orders = self._orders.setdefault(symbol, {})    orders[order[""order_id""]] = order # order 存入全局    self._on_insert_order(order, symbol, position, quote, underlying_quote)    self._match_order(order, symbol, position, quote, underlying_quote)   return self._return_results()  def cancel_order(self, symbol, pack):   order = self._orders.get(symbol, {}).get(pack[""order_id""], {})   if order.get(""status"") == ""ALIVE"":    order[""last_msg""] = ""已撤单""    order[""status""] = ""FINISHED""    self._on_order_failed(symbol, order)    self._orders_events.append(order)    del self._orders[symbol][order[""order_id""]] # 删除 order   return self._return_results()  def update_quotes(self, symbol, pack):   for q in pack.get(""quotes"", {}).values():    self._max_datetime = max(q.get(""datetime"", """"), self._max_datetime)   _simple_merge_diff(self._quotes, pack.get(""quotes"", {}))   quote, underlying_quote = self._get_quotes_by_symbol(symbol)   # 某些非交易时间段，ticks 回测是 quote 的最新价有可能是 nan，无效的行情直接跳过   if math.isnan(quote[""last_price""]):    return [], []   # 撮合委托单   orders = self._orders.get(symbol, {})   position = self._ensure_position(symbol, quote, underlying_quote)   for order_id in list(orders.keys()): # match_order 过程中可能会删除 orders 下对象    self._match_order(orders[order_id], symbol, position, quote, underlying_quote)   self._on_update_quotes(symbol, position, quote, underlying_quote) # 调整持仓及账户信息   return self._return_results()  def _match_order(self, order, symbol, position, quote, underlying_quote=None):   assert order[""status""] == ""ALIVE""   status, last_msg, price = SimTradeBase.match_order(order, quote)   if status == ""FINISHED"":    order[""last_msg""] = last_msg    order[""status""] = status    if last_msg == ""全部成交"":     trade = self._generate_trade(order, quote, price)     self._trades.append(trade)     self._on_order_traded(order, trade, symbol, position, quote, underlying_quote)    else:     self._on_order_failed(symbol, order)    # 成交后记录 orders_event, 删除 order    self._orders_events.append(order)    del self._orders[symbol][order[""order_id""]]  def settle(self):   trade_log = {    ""trades"": self._trades,    ""account"": self._account.copy(),    ""positions"": {k: v.copy() for k, v in self._positions.items()}   }   # 为下一交易日调整账户   self._trades = []   self._on_settle()   for symbol in self._orders:    for order in self._orders[symbol].values():     self._orders_events.append(order)    self._orders[symbol] = {}   diffs, orders_events = self._return_results()   return diffs, orders_events, trade_log  def _ensure_position(self, symbol, quote, underlying_quote):   position = self._positions.get(symbol, None)   if position is None:    position = self._generate_position(symbol, quote, underlying_quote)    self._positions[symbol] = position   return position  def _get_quotes_by_symbol(self, symbol):   """"""返回指定合约及标的合约，在本模块执行过程中，应该保证一定有合约行情""""""   quote = self._quotes.get(symbol)   assert quote and quote.get(""datetime""), ""未收到指定合约行情""   underlying_quote = None   if quote[""ins_class""].endswith(""OPTION""):    underlying_quote = self._quotes.get(quote[""underlying_symbol""])    assert underlying_quote and underlying_quote.get(""datetime""), ""未收到指定合约的标的行情""   return quote, underlying_quote  def _append_to_diffs(self, path, obj):   target = {}   diff = {'trade': {self._account_key: target}}   while len(path) > 0:    k = path.pop(0)    target[k] = obj.copy() if len(path) == 0 else {}    target = target[k]   self._diffs.append(diff)  def _return_results(self):   """"""   返回两项内容：diffs: list, orders_events: list   diffs 是截面的变更   orders_events 是委托单变化   """"""   diffs, self._diffs = self._diffs, []   orders_events, self._orders_events = self._orders_events, []   return diffs, orders_events  def _default_get_trade_timestamp(self):   """"""获取交易时间的默认方法，为当前所有 quote 的最大行情时间""""""   return _str_to_timestamp_nano(self._max_datetime)  def _default_is_in_trading_time(self, quote):   """"""判断是否在交易时间段""""""   return _is_in_trading_time(quote, self._max_datetime, float(""nan""))  @staticmethod  def match_order(order, quote) -> (str, str, float):   """"""   撮合交易规则：   * 市价单使用对手盘价格成交, 如果没有对手盘(涨跌停)则自动撤单   * 限价单要求报单价格达到或超过对手盘价格才能成交, 成交价为报单价格, 如果没有对手盘(涨跌停)则无法成交   * 模拟交易只有全部成交   returns: status, last_msg, price   """"""   status, last_msg = ""ALIVE"", """"   ask_price, bid_price = _get_price_range(quote)   # order 预期成交价格   if order[""price_type""] in [""ANY"", ""BEST"", ""FIVELEVEL""]:    price = ask_price if order[""direction""] == ""BUY"" else bid_price   else:    price = order[""limit_price""]   if order[""price_type""] == ""ANY"" and math.isnan(price):    status, last_msg = ""FINISHED"", ""市价指令剩余撤销""   if order.get(""time_condition"") == ""IOC"": # IOC 立即成交，限价下单且不能成交的价格，直接撤单    if order[""direction""] == ""BUY"" and price < ask_price or order[""direction""] == ""SELL"" and price > bid_price:     status, last_msg = ""FINISHED"", ""已撤单报单已提交""   if order[""direction""] == ""BUY"" and price >= ask_price or order[""direction""] == ""SELL"" and price <= bid_price:    status, last_msg = ""FINISHED"", ""全部成交""   return status, last_msg, price "
194,n\tqsdk\tradeable\sim\trade futur,"n\tqsdk\tradeable\sim\trade futur. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' import math from tqsdk.tradeable.sim.trade_base import SimTradeBase from tqsdk.tradeable.sim.utils import _get_option_margin, _get_premium, _get_close_profit, _get_commission, _get_future_margin class SimTrade(SimTradeBase):  """"""  天勤模拟交易账户，期货及商品期权  """"""  def _generate_account(self, init_balance):   return {    ""currency"": ""CNY"",    ""pre_balance"": init_balance,    ""static_balance"": init_balance,    ""balance"": init_balance,    ""available"": init_balance,    ""float_profit"": 0.0,    ""position_profit"": 0.0, # 期权没有持仓盈亏    ""close_profit"": 0.0,    ""frozen_margin"": 0.0,    ""margin"": 0.0,    ""frozen_commission"": 0.0,    ""commission"": 0.0,    ""frozen_premium"": 0.0,    ""premium"": 0.0,    ""deposit"": 0.0,    ""withdraw"": 0.0,    ""risk_ratio"": 0.0,    ""market_value"": 0.0,    ""ctp_balance"": float(""nan""),    ""ctp_available"": float(""nan"")   }  def _generate_position(self, symbol, quote, underlying_quote) -> dict:   return {    ""exchange_id"": symbol.split(""."", maxsplit=1)[0],    ""instrument_id"": symbol.split(""."", maxsplit=1)[1],    ""pos_long_his"": 0,    ""pos_long_today"": 0,    ""pos_short_his"": 0,    ""pos_short_today"": 0,    ""volume_long_today"": 0,    ""volume_long_his"": 0,    ""volume_long"": 0,    ""volume_long_frozen_today"": 0,    ""volume_long_frozen_his"": 0,    ""volume_long_frozen"": 0,    ""volume_short_today"": 0,    ""volume_short_his"": 0,    ""volume_short"": 0,    ""volume_short_frozen_today"": 0,    ""volume_short_frozen_his"": 0,    ""volume_short_frozen"": 0,    ""open_price_long"": float(""nan""),    ""open_price_short"": float(""nan""),    ""open_cost_long"": 0.0,    ""open_cost_short"": 0.0,    ""position_price_long"": float(""nan""),    ""position_price_short"": float(""nan""),    ""position_cost_long"": 0.0,    ""position_cost_short"": 0.0,    ""float_profit_long"": 0.0,    ""float_profit_short"": 0.0,    ""float_profit"": 0.0,    ""position_profit_long"": 0.0,    ""position_profit_short"": 0.0,    ""position_profit"": 0.0,    ""margin_long"": 0.0,    ""margin_short"": 0.0,    ""margin"": 0.0,    ""last_price"": quote[""last_price""],    ""underlying_last_price"": underlying_quote[""last_price""] if underlying_quote else float(""nan""),    ""market_value_long"": 0.0, # 权利方市值(始终 >= 0)    ""market_value_short"": 0.0, # 义务方市值(始终 <= 0)    ""market_value"": 0.0,    ""future_margin"": _get_future_margin(quote),   }  def _generate_order(self, pack: dict) -> dict:   """"""order 对象预处理""""""   order = pack.copy()   order[""exchange_order_id""] = order[""order_id""]   order[""volume_orign""] = order[""volume""]   order[""volume_left""] = order[""volume""]   order[""frozen_margin""] = 0.0   order[""frozen_premium""] = 0.0   order[""last_msg""] = ""报单成功""   order[""status""] = ""ALIVE""   order[""insert_date_time""] = self._get_trade_timestamp()   del order[""aid""]   del order[""volume""]   self._append_to_diffs(['orders', order[""order_id""]], order)   return order  def _generate_trade(self, order, quote, price) -> dict:   trade_id = order[""order_id""] + ""|"" + str(order[""volume_left""])   return {    ""user_id"": order[""user_id""],    ""order_id"": order[""order_id""],    ""trade_id"": trade_id,    ""exchange_trade_id"": order[""order_id""] + ""|"" + str(order[""volume_left""]),    ""exchange_id"": order[""exchange_id""],    ""instrument_id"": order[""instrument_id""],    ""direction"": order[""direction""],    ""offset"": order[""offset""],    ""price"": price,    ""volume"": order[""volume_left""],    ""trade_date_time"": self._get_trade_timestamp(), # todo: 可能导致测试结果不确定    ""commission"": order[""volume_left""] * _get_commission(quote)   }  def _on_settle(self):   for symbol in self._orders:    for order in self._orders[symbol].values():     order[""frozen_margin""] = 0.0     order[""frozen_premium""] = 0.0     order[""last_msg""] = ""交易日结束，自动撤销当日有效的委托单（GFD）""     order[""status""] = ""FINISHED""     self._append_to_diffs(['orders', order[""order_id""]], order)   # account 原始字段   self._account[""pre_balance""] = self._account[""balance""] - self._account[""market_value""]   self._account[""close_profit""] = 0.0   self._account[""commission""] = 0.0   self._account[""premium""] = 0.0   self._account[""frozen_margin""] = 0.0   self._account[""frozen_premium""] = 0.0   # account 计算字段   self._account[""static_balance""] = self._account[""pre_balance""]   self._account[""position_profit""] = 0.0   self._account[""risk_ratio""] = self._account[""margin""] / self._account[""balance""]   self._account[""available""] = self._account[""static_balance""] - self._account[""margin""]   # 根据公式 账户权益 不需要计算 self._account[""balance""] = static_balance + market_value   self._append_to_diffs(['accounts', 'CNY'], self._account)   # 对于持仓的结算放在这里，没有放在 quote_handler 里的原因：   # 1. 异步发送的话，会造成如果此时 sim 未收到 pending_peek, 就没法把结算的账户信息发送出去，此时用户代码中 api.get_postion 得到的持仓和 sim 里面的持仓是不一致的   # set_target_pos 下单时就会产生错单。而且结算时一定是已经收到过行情的数据包，在同步代码的最后一步，会发送出去这个行情包 peeding_peek，   # quote_handler 处理 settle 的时候, 所以在结算的时候 pending_peek 一定是 False, 要 api 处理过之后，才会收到 peek_message   # 2. 同步发送的话，就可以和产生切换交易日的数据包同时发送出去   # 对 order 的处理发生在下一次回复 peek_message   for position in self._positions.values():    symbol = f""{position['exchange_id']}.{position['instrument_id']}""    # position 原始字段    position[""volume_long_frozen_today""] = 0    position[""volume_long_frozen_his""] = 0    position[""volume_short_frozen_today""] = 0    position[""volume_short_frozen_his""] = 0    position[""volume_long_today""] = 0    position[""volume_long_his""] = position[""volume_long""]    position[""volume_short_today""] = 0    position[""volume_short_his""] = position[""volume_short""]    # position 计算字段    position[""pos_long_his""] = position[""volume_long_his""]    position[""pos_long_today""] = 0    position[""pos_short_his""] = position[""volume_short_his""]    position[""pos_short_today""] = 0    position[""volume_long_frozen""] = 0    position[""volume_short_frozen""] = 0    position[""position_price_long""] = position[""last_price""]    position[""position_price_short""] = position[""last_price""]    quote, _ = self._get_quotes_by_symbol(symbol)    position[""position_cost_long""] = position[""last_price""] * position[""volume_long""] * quote[""volume_multiple""] # position 原始字段    position[""position_cost_short""] = position[""last_price""] * position[""volume_short""] * quote[""volume_multiple""] # position 原始字段    position[""position_profit_long""] = 0    position[""position_profit_short""] = 0    position[""position_profit""] = 0    self._append_to_diffs(['positions', symbol], position)  def _check_insert_order(self, order, symbol, position, quote, underlying_quote=None):   # 无法计入 orderbook, 各种账户都需要判断的   if (""commission"" not in quote or ""margin"" not in quote) and not quote[""ins_class""].endswith(""OPTION""):    order[""last_msg""] = ""不支持的合约类型，TqSim 目前不支持组合，股票，etf期权模拟交易""    order[""status""] = ""FINISHED""   if order[""status""] == ""ALIVE"" and not self._is_in_trading_time(quote):    order[""last_msg""] = ""下单失败, 不在可交易时间段内""    order[""status""] = ""FINISHED""   if order[""status""] == ""ALIVE"" and order[""offset""].startswith('CLOSE'):    if order[""exchange_id""] in [""SHFE"", ""INE""]:     if order[""offset""] == ""CLOSETODAY"":      if order[""direction""] == ""BUY"" and position[""volume_short_today""] - position[""volume_long_frozen_today""] < order[""volume_orign""]:       order[""last_msg""] = ""平今仓手数不足""      elif order[""direction""] == ""SELL"" and position[""volume_long_today""] - position[""volume_long_frozen_today""] < order[""volume_orign""]:       order[""last_msg""] = ""平今仓手数不足""     if order[""offset""] == ""CLOSE"":      if order[""direction""] == ""BUY"" and position[""volume_short_his""] - position[""volume_short_frozen_his""] < order[""volume_orign""]:       order[""last_msg""] = ""平昨仓手数不足""      elif order[""direction""] == ""SELL"" and position[""volume_long_his""] - position[""volume_long_frozen_his""] < order[""volume_orign""]:       order[""last_msg""] = ""平昨仓手数不足""    else:     if order[""direction""] == ""BUY"" and position[""volume_short""] - position[""volume_short_frozen""] < order[""volume_orign""]:      order[""last_msg""] = ""平仓手数不足""     elif order[""direction""] == ""SELL"" and position[""volume_long""] - position[""volume_long_frozen""] < order[""volume_orign""]:      order[""last_msg""] = ""平仓手数不足""    if order[""last_msg""].endswith(""手数不足""):     order[""status""] = ""FINISHED""   if order[""status""] == ""ALIVE"" and order[""offset""] == ""OPEN"":    # 计算冻结保证金，冻结权利金    if quote[""ins_class""].endswith(""OPTION""):     if order[""direction""] == ""SELL"": # 期权的SELL义务仓，开仓需要冻结保证金      order[""frozen_margin""] = order[""volume_orign""] * _get_option_margin(quote, quote[""last_price""], underlying_quote[""last_price""])     else: # 期权的BUY权利仓（市价单使用 last_price 计算需要冻结的权利金）      price = quote[""last_price""] if order[""price_type""] == ""ANY"" else order[""limit_price""]      order[""frozen_premium""] = order[""volume_orign""] * quote[""volume_multiple""] * price    else:     order[""frozen_margin""] = order[""volume_orign""] * _get_future_margin(quote)    if order[""frozen_margin""] + order[""frozen_premium""] > self._account[""available""]:     order[""frozen_margin""] = 0.0     order[""frozen_premium""] = 0.0     order[""last_msg""] = '开仓资金不足'     order[""status""] = ""FINISHED""   if order[""status""] == ""FINISHED"":    self._append_to_diffs(['orders', order[""order_id""]], order)  def _on_insert_order(self, order, symbol, position, quote, underlying_quote=None):   """"""判断 order 是否可以记录在 orderbook""""""   if order[""offset""] == ""OPEN"":    # 修改 account 计算字段    self._adjust_account_by_order(frozen_margin=order[""frozen_margin""], frozen_premium=order[""frozen_premium""])    self._append_to_diffs(['accounts', 'CNY'], self._account)   else:    # 修改 position 原始字段    if order[""exchange_id""] in [""SHFE"", ""INE""]:     if order[""direction""] == ""BUY"":      position[f""volume_short_frozen_{'today' if order['offset'] == 'CLOSETODAY' else 'his'}""] += order[""volume_orign""]     else:      position[f""volume_long_frozen_{'today' if order['offset'] == 'CLOSETODAY' else 'his'}""] += order[""volume_orign""]    elif order[""direction""] == ""BUY"":     volume_short_his_available = position[""volume_short_his""] - position[""volume_short_frozen_his""]     if volume_short_his_available < order[""volume_orign""]:      position[""volume_short_frozen_his""] += volume_short_his_available      position[""volume_short_frozen_today""] += order[""volume_orign""] - volume_short_his_available     else:      position[""volume_short_frozen_his""] += order[""volume_orign""]    else:     volume_long_his_available = position[""volume_long_his""] - position[""volume_long_frozen_his""]     if volume_long_his_available < order[""volume_orign""]:      position[""volume_long_frozen_his""] += volume_long_his_available      position[""volume_long_frozen_today""] += order[""volume_orign""] - volume_long_his_available     else:      position[""volume_long_frozen_his""] += order[""volume_orign""]    # 修改 position 计算字段    self._adjust_position_volume_frozen(position)    self._append_to_diffs(['positions', symbol], position)  def _on_order_traded(self, order, trade, symbol, position, quote, underlying_quote):   origin_frozen_margin = order[""frozen_margin""]   origin_frozen_premium = order[""frozen_premium""]   order[""frozen_margin""] = 0.0   order[""frozen_premium""] = 0.0   order[""volume_left""] = 0   self._append_to_diffs(['trades', trade[""trade_id""]], trade)   self._append_to_diffs(['orders', order[""order_id""]], order)   if order[""offset""] == 'OPEN':    if order[""direction""] == ""BUY"":     # 修改 position 原始字段     position[""volume_long_today""] += order[""volume_orign""]     position[""open_cost_long""] += trade[""price""] * order[""volume_orign""] * quote[""volume_multiple""] # 多头开仓成本     position[""position_cost_long""] += trade[""price""] * order[""volume_orign""] * quote[""volume_multiple""] # 多头持仓成本    else:     # 修改 position 原始字段     position[""volume_short_today""] += order[""volume_orign""]     position[""open_cost_short""] += trade[""price""] * order[""volume_orign""] * quote[""volume_multiple""] # 空头开仓成本     position[""position_cost_short""] += trade[""price""] * order[""volume_orign""] * quote[""volume_multiple""] # 空头持仓成本    # 由 order 变化，account 需要更新的计算字段    self._adjust_account_by_order(frozen_margin=-origin_frozen_margin, frozen_premium=-origin_frozen_premium)    # 由 trade 引起的 account 原始字段变化，account 需要更新的计算字段    premium = _get_premium(trade, quote)    self._adjust_account_by_trade(commission=trade[""commission""], premium=premium)    # 由 position 字段变化，同时 account 需要更新的计算字段    buy_open = order[""volume_orign""] if order[""direction""] == ""BUY"" else 0    sell_open = 0 if order[""direction""] == ""BUY"" else order[""volume_orign""]    self._adjust_position_account(symbol, quote, underlying_quote,           pre_last_price=trade[""price""],           last_price=position[""last_price""],           pre_underlying_last_price=underlying_quote[""last_price""] if underlying_quote else float('nan'),           underlying_last_price=position[""underlying_last_price""],           buy_open=buy_open, sell_open=sell_open)   else: # order[""offset""].startswith('CLOSE')    # 修改 position 原始字段    if order[""exchange_id""] in [""SHFE"", ""INE""]:     if order[""offset""] == ""CLOSETODAY"":      if order[""direction""] == ""BUY"":       position[""volume_short_frozen_today""] -= order[""volume_orign""]       position[""volume_short_today""] -= order[""volume_orign""]      elif order[""direction""] == ""SELL"":       position[""volume_long_frozen_today""] -= order[""volume_orign""]       position[""volume_long_today""] -= order[""volume_orign""]     if order[""offset""] == ""CLOSE"":      if order[""direction""] == ""BUY"":       position[""volume_short_frozen_his""] -= order[""volume_orign""]       position[""volume_short_his""] -= order[""volume_orign""]      elif order[""direction""] == ""SELL"":       position[""volume_long_frozen_his""] -= order[""volume_orign""]       position[""volume_long_his""] -= order[""volume_orign""]    elif order[""direction""] == ""BUY"":     if position[""volume_short_frozen_his""] >= order[""volume_orign""]:      position[""volume_short_frozen_his""] -= order[""volume_orign""]      position[""volume_short_his""] -= order[""volume_orign""]     else:      position[""volume_short_frozen_today""] -= order[""volume_orign""] - position[""volume_short_frozen_his""]      position[""volume_short_today""] -= order[""volume_orign""] - position[""volume_short_frozen_his""]      position[""volume_short_his""] -= position[""volume_short_frozen_his""]      position[""volume_short_frozen_his""] = 0    else:     if position[""volume_long_frozen_his""] >= order[""volume_orign""]:      position[""volume_long_frozen_his""] -= order[""volume_orign""]      position[""volume_long_his""] -= order[""volume_orign""]     else:      position[""volume_long_frozen_today""] -= order[""volume_orign""] - position[""volume_long_frozen_his""]      position[""volume_long_today""] -= order[""volume_orign""] - position[""volume_long_frozen_his""]      position[""volume_long_his""] -= position[""volume_long_frozen_his""]      position[""volume_long_frozen_his""] = 0    # 修改 position 原始字段    if order[""direction""] == ""SELL"":     position[""open_cost_long""] -= position[""open_price_long""] * order[""volume_orign""] * quote[""volume_multiple""] # 多头开仓成本     position[""position_cost_long""] -= position[""position_price_long""] * order[""volume_orign""] * quote[""volume_multiple""] # 多头持仓成本    else:     position[""open_cost_short""] -= position[""open_price_short""] * order[""volume_orign""] * quote[""volume_multiple""] # 空头开仓成本     position[""position_cost_short""] -= position[""position_price_short""] * order[""volume_orign""] * quote[""volume_multiple""] # 空头持仓成本    # 由 trade 引起的 account 原始字段变化，account 需要更新的计算字段    premium = _get_premium(trade, quote)    close_profit = _get_close_profit(trade, quote, position)    self._adjust_account_by_trade(commission=trade[""commission""], premium=premium, close_profit=close_profit)    # 由 position 字段变化，同时 account 需要更新的计算字段    buy_close = order[""volume_orign""] if order[""direction""] == ""BUY"" else 0    sell_close = 0 if order[""direction""] == ""BUY"" else order[""volume_orign""]    self._adjust_position_account(symbol, quote, underlying_quote, pre_last_price=position[""last_price""],           last_price=0, pre_underlying_last_price=position[""underlying_last_price""],           underlying_last_price=0, buy_close=buy_close, sell_close=sell_close)   self._append_to_diffs(['positions', symbol], position)   self._append_to_diffs(['accounts', 'CNY'], self._account)  def _on_order_failed(self, symbol, order):   origin_frozen_margin = order[""frozen_margin""]   origin_frozen_premium = order[""frozen_premium""]   order[""frozen_margin""] = 0.0   order[""frozen_premium""] = 0.0   self._append_to_diffs(['orders', order[""order_id""]], order)   # 调整账户和持仓   if order[""offset""] == 'OPEN':    self._adjust_account_by_order(frozen_margin=-origin_frozen_margin, frozen_premium=-origin_frozen_premium)    self._append_to_diffs(['accounts', 'CNY'], self._account)   else:    position = self._positions[symbol]    if order[""exchange_id""] in [""SHFE"", ""INE""]:     if order[""offset""] == ""CLOSETODAY"":      if order[""direction""] == ""BUY"":       position[""volume_short_frozen_today""] -= order[""volume_orign""]      else:       position[""volume_long_frozen_today""] -= order[""volume_orign""]     if order[""offset""] == ""CLOSE"":      if order[""direction""] == ""BUY"":       position[""volume_short_frozen_his""] -= order[""volume_orign""]      else:       position[""volume_long_frozen_his""] -= order[""volume_orign""]    else:     if order[""direction""] == ""BUY"":      if position[""volume_short_frozen_today""] >= order[""volume_orign""]:       position[""volume_short_frozen_today""] -= order[""volume_orign""]      else:       position[""volume_short_frozen_his""] -= order[""volume_orign""] - position[""volume_short_frozen_today""]       position[""volume_short_frozen_today""] = 0     else:      if position[""volume_long_frozen_today""] >= order[""volume_orign""]:       position[""volume_long_frozen_today""] -= order[""volume_orign""]      else:       position[""volume_long_frozen_his""] -= order[""volume_orign""] - position[""volume_long_frozen_today""]       position[""volume_long_frozen_today""] = 0    self._adjust_position_volume_frozen(position)    self._append_to_diffs(['positions', symbol], position)  def _on_update_quotes(self, symbol, position, quote, underlying_quote):   # 调整持仓保证金和盈亏   underlying_last_price = underlying_quote[""last_price""] if underlying_quote else float('nan')   future_margin = _get_future_margin(quote)   if position[""volume_long""] > 0 or position[""volume_short""] > 0:    if position[""last_price""] != quote[""last_price""] \      or (math.isnan(future_margin) or future_margin != position[""future_margin""]) \      or (underlying_quote and (      math.isnan(underlying_last_price) or underlying_last_price != position[""underlying_last_price""])):     self._adjust_position_account(symbol, quote, underlying_quote,            pre_last_price=position[""last_price""],            last_price=quote[""last_price""],            pre_underlying_last_price=position[""underlying_last_price""],            underlying_last_price=underlying_last_price)     position[""future_margin""] = future_margin     position[""last_price""] = quote[""last_price""]     position[""underlying_last_price""] = underlying_last_price   else:    # 修改辅助变量    position[""future_margin""] = future_margin    position[""last_price""] = quote[""last_price""]    position[""underlying_last_price""] = underlying_last_price   self._append_to_diffs(['positions', symbol], position) # 一定要返回 position，下游会用到 future_margin 字段判断修改保证金是否成功   self._append_to_diffs(['accounts', 'CNY'], self._account)  def _adjust_position_account(self, symbol, quote, underlying_quote=None, pre_last_price=float('nan'), last_price=float('nan'),         pre_underlying_last_price=float('nan'), underlying_last_price=float('nan'),         buy_open=0, buy_close=0, sell_open=0, sell_close=0):   """"""   价格变化，使得 position 中的以下计算字段需要修改，这个函数计算出需要修改的差值部分，计算出差值部分修改 position、account   有两种情况下调用   1. 委托单 FINISHED，且全部成交，分为4种：buy_open, buy_close, sell_open, sell_close   2. 行情跳动   """"""   position = self._positions[symbol]   float_profit_long = 0 # 多头浮动盈亏   float_profit_short = 0 # 空头浮动盈亏   position_profit_long = 0 # 多头持仓盈亏，期权持仓盈亏为0   position_profit_short = 0 # 空头持仓盈亏，期权持仓盈亏为0   margin_long = 0 # 多头占用保证金   margin_short = 0 # 空头占用保证金   market_value_long = 0 # 期权权利方市值(始终 >= 0)   market_value_short = 0 # 期权义务方市值(始终 <= 0)   assert [buy_open, buy_close, sell_open, sell_close].count(0) >= 3 # 只有一个大于0, 或者都是0，表示价格变化导致的字段修改   if buy_open > 0:    # 买开，pre_last_price 应该是成交价格，last_price 应该是 position['last_price']    float_profit_long = (last_price - pre_last_price) * buy_open * quote[""volume_multiple""]    if quote[""ins_class""].endswith(""OPTION""):     market_value_long = last_price * buy_open * quote[""volume_multiple""]    else:     margin_long = buy_open * _get_future_margin(quote)     position_profit_long = (last_price - pre_last_price) * buy_open * quote[""volume_multiple""]   elif sell_close > 0:    # 卖平，pre_last_price 应该是 position['last_price']，last_price 应该是 0    float_profit_long = -position[""float_profit_long""] / position[""volume_long""] * sell_close    if quote[""ins_class""].endswith(""OPTION""):     market_value_long = -pre_last_price * sell_close * quote[""volume_multiple""]    else:     margin_long = -sell_close * _get_future_margin(quote)     position_profit_long = -position[""position_profit_long""] / position[""volume_long""] * sell_close   elif sell_open > 0:    # 卖开    float_profit_short = (pre_last_price - last_price) * sell_open * quote[""volume_multiple""]    if quote[""ins_class""].endswith(""OPTION""):     market_value_short = -last_price * sell_open * quote[""volume_multiple""]     margin_short = sell_open * _get_option_margin(quote, last_price, underlying_last_price)    else:     margin_short = sell_open * _get_future_margin(quote)     position_profit_short = (pre_last_price - last_price) * sell_open * quote[""volume_multiple""]   elif buy_close > 0:    # 买平    float_profit_short = -position[""float_profit_short""] / position[""volume_short""] * buy_close    if quote[""ins_class""].endswith(""OPTION""):     market_value_short = pre_last_price * buy_close * quote[""volume_multiple""]     margin_short = -buy_close * _get_option_margin(quote, pre_last_price, pre_underlying_last_price)    else:     margin_short = -buy_close * _get_future_margin(quote)     position_profit_short = -position[""position_profit_short""] / position[""volume_short""] * buy_close   else:    float_profit_long = (last_price - pre_last_price) * position[""volume_long""] * quote[""volume_multiple""] # 多头浮动盈亏    float_profit_short = (pre_last_price - last_price) * position[""volume_short""] * quote[""volume_multiple""] # 空头浮动盈亏    if quote[""ins_class""].endswith(""OPTION""):     margin_short = _get_option_margin(quote, last_price, underlying_last_price) * position[""volume_short""] - position[""margin_short""]     market_value_long = (last_price - pre_last_price) * position[""volume_long""] * quote[""volume_multiple""]     market_value_short = (pre_last_price - last_price) * position[""volume_short""] * quote[""volume_multiple""]    else:     # 期权持仓盈亏为 0     position_profit_long = float_profit_long # 多头持仓盈亏     position_profit_short = float_profit_short # 空头持仓盈亏     margin_long = _get_future_margin(quote) * position[""volume_long""] - position[""margin_long""]     margin_short = _get_future_margin(quote) * position[""volume_short""] - position[""margin_short""]   if any([buy_open, buy_close, sell_open, sell_close]):    # 修改 position volume 相关的计算字段    # 在上面 sell_close buy_close 两种情况，计算浮动盈亏时，用到了修改前的手数，所以需改手数字段的代码放在这个位置    self._adjust_position_volume(position)   self._adjust_position(quote, position, float_profit_long, float_profit_short, position_profit_long,        position_profit_short, margin_long, margin_short, market_value_long, market_value_short)   self._adjust_account_by_position(float_profit=float_profit_long + float_profit_short,           position_profit=position_profit_long + position_profit_short,           margin=margin_long + margin_short,           market_value=market_value_long + market_value_short)  # -------- 对于 position 的计算字段修改分为两类：  # 1. 针对手数相关的修改，在下单、成交时会修改  # 2. 针对盈亏、保证金、市值的修改，由于参考合约最新价，在成交、行情跳动时会修改  def _adjust_position_volume_frozen(self, position):   """"""position 原始字段修改后，只有冻结手数需要重新计算，有两种情况需要调用   1. 下平仓单 2. 平仓单 FINISHED, 但没有成交   """"""   position[""volume_long_frozen""] = position[""volume_long_frozen_today""] + position[""volume_long_frozen_his""]   position[""volume_short_frozen""] = position[""volume_short_frozen_today""] + position[""volume_short_frozen_his""]  def _adjust_position_volume(self, position):   """"""position 原始字段修改后，手数之后需要重新计算   1. 委托单 FINISHED，且全部成交   """"""   position[""pos_long_today""] = position[""volume_long_today""]   position[""pos_long_his""] = position[""volume_long_his""]   position[""pos_short_today""] = position[""volume_short_today""]   position[""pos_short_his""] = position[""volume_short_his""]   position[""volume_long""] = position[""volume_long_today""] + position[""volume_long_his""]   position[""volume_long_frozen""] = position[""volume_long_frozen_today""] + position[""volume_long_frozen_his""]   position[""volume_short""] = position[""volume_short_today""] + position[""volume_short_his""]   position[""volume_short_frozen""] = position[""volume_short_frozen_today""] + position[""volume_short_frozen_his""]  def _adjust_position(self, quote, position, float_profit_long=0, float_profit_short=0, position_profit_long=0,         position_profit_short=0, margin_long=0, margin_short=0, market_value_long=0,         market_value_short=0):   # 更新 position 计算字段，根据差值更新的字段   position[""float_profit_long""] += float_profit_long   position[""float_profit_short""] += float_profit_short   position[""position_profit_long""] += position_profit_long   position[""position_profit_short""] += position_profit_short   position[""margin_long""] += margin_long   position[""margin_short""] += margin_short   position[""market_value_long""] += market_value_long   position[""market_value_short""] += market_value_short   # 更新 position 计算字段，原地重新计算的字段   if position[""volume_long""] > 0:    position[""open_price_long""] = position[""open_cost_long""] / position[""volume_long""] / quote[""volume_multiple""]    position[""position_price_long""] = position[""position_cost_long""] / position[""volume_long""] / quote[""volume_multiple""]   else:    position[""open_price_long""] = float(""nan"")    position[""position_price_long""] = float(""nan"")   if position[""volume_short""] > 0:    position[""open_price_short""] = position[""open_cost_short""] / position[""volume_short""] / quote[""volume_multiple""]    position[""position_price_short""] = position[""position_cost_short""] / position[""volume_short""] / quote[""volume_multiple""]   else:    position[""open_price_short""] = float(""nan"")    position[""position_price_short""] = float(""nan"")   position[""float_profit""] = position[""float_profit_long""] + position[""float_profit_short""]   position[""position_profit""] = position[""position_profit_long""] + position[""position_profit_short""]   position[""margin""] = position[""margin_long""] + position[""margin_short""]   position[""market_value""] = position[""market_value_long""] + position[""market_value_short""]  # -------- 对于 account 的修改分为以下三类  def _adjust_account_by_trade(self, commission=0, close_profit=0, premium=0):   """"""由成交引起的 account 原始字段变化，account 需要更新的计算字段""""""   # account 原始字段   self._account[""close_profit""] += close_profit   self._account[""commission""] += commission   self._account[""premium""] += premium # premium变量的值有正负，正数表示收入的权利金，负数表示付出的权利金   # account 计算字段   self._account[""balance""] += close_profit - commission + premium   self._account[""available""] += close_profit - commission + premium   self._account[""risk_ratio""] = self._account[""margin""] / self._account[""balance""]  def _adjust_account_by_position(self, float_profit=0, position_profit=0, margin=0, market_value=0):   """"""由 position 变化，account 需要更新的计算字段""""""   # account 计算字段，持仓字段求和的字段   self._account[""float_profit""] += float_profit   self._account[""position_profit""] += position_profit   self._account[""margin""] += margin   self._account[""market_value""] += market_value   # account 计算字段   self._account[""balance""] += position_profit + market_value   self._account[""available""] += position_profit - margin   self._account[""risk_ratio""] = self._account[""margin""] / self._account[""balance""]  def _adjust_account_by_order(self, frozen_margin=0, frozen_premium=0):   """"""由 order 变化，account 需要更新的计算字段""""""   self._account[""frozen_margin""] += frozen_margin   self._account[""frozen_premium""] += frozen_premium   self._account[""available""] -= (frozen_margin + frozen_premium) "
195,n\tqsdk\tradeable\sim\trade stoc,"n\tqsdk\tradeable\sim\trade stoc. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = ""mayanqiong"" from tqsdk.tradeable.sim.trade_base import SimTradeBase from tqsdk.tradeable.sim.utils import _get_stock_fee, _get_order_price, _get_dividend_ratio class SimTradeStock(SimTradeBase):  """"""  天勤模拟交易账户，期货及商品期权  """"""  def _generate_account(self, init_balance):   return {    ""user_id"": self._account_id, # 客户号, 与 order / trade 对象中的 user_id 值保持一致    ""currency"": ""CNY"",    ""market_value_his"": 0.0, # 期初市值    ""asset_his"": init_balance, # 期初资产    ""cost_his"": 0.0, # 期初买入成本    ""deposit"": 0.0,    ""withdraw"": 0.0,    ""dividend_balance_today"": 0.0, # 当日分红金额    ""available_his"": init_balance,    ""market_value"": 0.0, # 当前市值    ""asset"": init_balance, # 当前资产 = 当前市值 + 可用余额 + 冻结    ""available"": init_balance, # 可用余额 = 期初余额 + 当日分红金额 - 买入费用 - 卖出费用 + 当日入金 - 当日出金 - 当日买入占用资金 + 当日卖出释放资金 - 委托冻结金额 - 委托冻结费用    ""drawable"": init_balance, # 可取余额 = 可用余额 - 当日卖出释放资金    ""buy_frozen_balance"": 0.0, # 当前交易冻结金额（不含费用）= sum(order.volume_orign * order.limit_price)    ""buy_frozen_fee"": 0.0, # 当前交易冻结费用 = sum(order.frozen_fee)    ""buy_balance_today"": 0.0, # 当日买入占用资金（不含费用）    ""buy_fee_today"": 0.0, # 当日买入累计费用    ""sell_balance_today"": 0.0, # 当日卖出释放资金    ""sell_fee_today"": 0.0, # 当日卖出累计费用    ""cost"": 0.0, # 当前买入成本 = SUM（买入成本）    ""hold_profit"": 0.0, # 当日持仓盈亏 = 当前市值 - 当前买入成本    ""float_profit_today"": 0.0, # 当日浮动盈亏 = SUM(持仓当日浮动盈亏)    ""real_profit_today"": 0.0, # 当日实现盈亏 = SUM(持仓当日实现盈亏)    ""profit_today"": 0.0, # 当日盈亏 = 当日浮动盈亏 + 当日实现盈亏    ""profit_rate_today"": 0.0 # 当日盈亏比 = 当日盈亏 / (当前买入成本 if 当前买入成本 > 0 else 期初资产)   }  def _generate_position(self, symbol, quote, underlying_quote) -> dict:   return {    ""user_id"": self._account_id,    ""exchange_id"": symbol.split(""."", maxsplit=1)[0],    ""instrument_id"": symbol.split(""."", maxsplit=1)[1],    ""create_date"": """", # 建仓日期    ""volume_his"": 0, # 昨持仓数量    ""cost_his"": 0.0, # 期初买入成本    ""market_value_his"": 0.0, # 期初市值    ""real_profit_his"": 0.0, # 期初实现盈亏    ""shared_volume_today"": 0, # 今送股数量    ""devidend_balance_today"": 0.0, # 今分红金额    ""buy_volume_his"": 0, # 期初累计买入持仓    ""buy_balance_his"": 0.0, # 期初累计买入金额    ""buy_fee_his"": 0.0, # 期初累计买入费用    ""sell_volume_his"": 0, # 期初累计卖出持仓    ""sell_balance_his"": 0.0, # 期初累计卖出金额    ""sell_fee_his"": 0.0, # 期初累计卖出费用    ""buy_volume_today"": 0, # 当日累计买入持仓    ""buy_balance_today"": 0.0, # 当日累计买入金额 (不包括费用)    ""buy_fee_today"": 0.0, # 当日累计买入费用    ""sell_volume_today"": 0, # 当日累计卖出持仓    ""sell_balance_today"": 0.0, # 当日累计卖出金额 (不包括费用)    ""sell_fee_today"": 0.0, # 当日累计卖出费用    ""last_price"": quote[""last_price""],    ""sell_volume_frozen"": 0, # 今日卖出冻结手数    ""sell_float_profit_today"": 0.0, # 昨仓浮动盈亏 = (昨持仓数量 - 今卖数量) * (最新价 - 昨收盘价)    ""buy_float_profit_today"": 0.0, # 今仓浮动盈亏 = (今持仓数量 - (昨持仓数量 - 今卖数量)) * (最新价 - 买入均价)    # 买入均价 = (buy_balance_today + buy_fee_today) / buy_volume_today    ""cost"": 0.0, # 当前成本 = 期初成本 + 今买金额 + 今买费用 - 今卖数量 × (期初买入成本 / 期初持仓数量)    ""volume"": 0, # 今持仓数量 = 昨持仓数量 + 今买数量 - 今卖数量 + 送股数量    ""market_value"": 0.0, # 当前市值 = 持仓数量 × 行情最新价    ""float_profit_today"": 0.0, # 当日浮动盈亏 = sell_float_profit_today + buy_float_profit_today    ""real_profit_today"": 0.0, # 当日实现盈亏 = 今卖数量 * (最新价 - 昨收盘价) - 今卖费用 + 今派息金额    ""profit_today"": 0.0, # 当日盈亏 = 当日浮动盈亏 + 当日实现盈亏    ""profit_rate_today"": 0.0, # 当日收益率 = 当日盈亏 / ( 当前成本 if 当前成本 > 0 else 期初市值)    ""hold_profit"": 0.0, # 当日持仓盈亏 = 当前市值 – 当前买入成本    ""real_profit_total"": 0.0, # 累计实现盈亏 += 当日实现盈亏（成本）    ""profit_total"": 0.0, # 总盈亏 = 累计实现盈亏 + 持仓盈亏    ""profit_rate_total"": 0.0, # 累计收益率 = 总盈亏 / (当前成本 if 当前成本 > 0 else 期初成本)   }  def _generate_order(self, pack: dict) -> dict:   """"""order 对象预处理""""""   order = pack.copy()   order[""exchange_order_id""] = order[""order_id""]   order[""volume_orign""] = order[""volume""]   order[""volume_left""] = order[""volume""]   order[""frozen_balance""] = 0.0   order[""frozen_fee""] = 0.0   order[""last_msg""] = ""报单成功""   order[""status""] = ""ALIVE""   order[""insert_date_time""] = self._get_trade_timestamp()   del order[""aid""]   del order[""volume""]   self._append_to_diffs([""orders"", order[""order_id""]], order)   return order  def _generate_trade(self, order, quote, price) -> dict:   fee = _get_stock_fee(order[""direction""], order[""volume_left""], price)   return {    ""user_id"": order[""user_id""],    ""order_id"": order[""order_id""],    ""trade_id"": order[""order_id""] + ""|"" + str(order[""volume_left""]),    ""exchange_trade_id"": order[""order_id""] + ""|"" + str(order[""volume_left""]),    ""exchange_id"": order[""exchange_id""],    ""instrument_id"": order[""instrument_id""],    ""direction"": order[""direction""], # 下单方向, BUY=买, SELL=卖，SHARED=送股，DEVIDEND=分红 (送股|分红没有计算费用)    ""price"": price,    ""volume"": order[""volume_left""],    ""trade_date_time"": self._get_trade_timestamp(), # todo: 可能导致测试结果不确定    ""fee"": fee   }  def _on_settle(self):   for symbol in self._orders:    for order in self._orders[symbol].values():     order[""frozen_balance""] = 0.0     order[""frozen_fee""] = 0.0     order[""last_msg""] = ""交易日结束，自动撤销当日有效的委托单（GFD）""     order[""status""] = ""FINISHED""     self._append_to_diffs([""orders"", order[""order_id""]], order)   dividend_balance_today = 0.0 # 今日分红总的分红数据   for position in self._positions.values():    symbol = f""{position['exchange_id']}.{position['instrument_id']}""    quote, _ = self._get_quotes_by_symbol(symbol)    stock_dividend, cash_dividend = _get_dividend_ratio(quote)    # position 原始字段    position[""volume_his""] = position[""volume""] # 期初持仓数量    position[""cost_his""] = position[""cost""] # 期初买入成本    position[""market_value_his""] = position[""market_value""] # 期初市值    position[""real_profit_his""] = position[""real_profit_today""] # 期初实现盈亏    # 处理分红送股    position[""shared_volume_today""] = stock_dividend * position[""volume""] # 今送股数量    position[""devidend_balance_today""] = cash_dividend * position[""volume""] # 今分红金额    if position[""shared_volume_today""] > 0.0 or position[""devidend_balance_today""] > 0.0:     position[""volume""] += position[""shared_volume_today""]     position[""market_value""] -= position[""devidend_balance_today""] # 分红后的市值     position[""last_price""] = position[""market_value""] / position[""volume""] # 分红送股后的最新价, todo: 可能会于第二天收到的第一笔行情有误差？     dividend_balance_today += position[""devidend_balance_today""] # 记录累积分红金额，account 需要    position[""buy_volume_his""] = position[""buy_volume_today""]    position[""buy_balance_his""] = position[""buy_balance_today""]    position[""buy_fee_his""] = position[""buy_fee_today""]    position[""sell_volume_his""] = position[""sell_volume_today""]    position[""sell_balance_his""] = position[""sell_balance_today""]    position[""sell_fee_his""] = position[""sell_fee_today""]    position[""buy_volume_today""] = 0    position[""buy_balance_today""] = 0.0    position[""buy_fee_today""] = 0.0    position[""sell_volume_today""] = 0    position[""sell_balance_today""] = 0.0    position[""sell_fee_today""] = 0.0    position[""sell_volume_frozen""] = 0    position[""buy_avg_price""] = 0.0    position[""sell_float_profit_today""] = 0.0    position[""buy_float_profit_today""] = 0.0    position[""float_profit_today""] = 0.0 # 当日浮动盈亏 = position[""sell_float_profit_today""] + position[""buy_float_profit_today""]    position[""real_profit_today""] = 0.0 # 当日实现盈亏 = 今卖数量 * (最新价 - 昨收盘价) - 今卖费用 + 今派息金额    position[""profit_today""] = 0.0 # 当日盈亏 = 当日浮动盈亏 + 当日实现盈亏    position[""profit_rate_today""] = 0.0 # 当日收益率 = 当日盈亏 / ( 当前成本 if 当前成本 > 0 else 期初市值)    position[""hold_profit""] = 0.0 # 当日持仓盈亏 = 当前市值 – 当前买入成本    self._append_to_diffs([""positions"", symbol], position)   # account 原始字段   self._account[""dividend_balance_today""] = dividend_balance_today   self._account[""market_value_his""] = self._account[""market_value""]   self._account[""asset_his""] = self._account[""asset""]   self._account[""cost_his""] = self._account[""cost""]   self._account[""available_his""] = self._account[""available""] + self._account[""buy_frozen_balance""] + self._account[""buy_frozen_fee""]   self._account[""buy_frozen_balance""] = 0.0   self._account[""buy_frozen_fee""] = 0.0   self._account[""buy_balance_today""] = 0.0   self._account[""buy_fee_today""] = 0.0   self._account[""sell_balance_today""] = 0.0   self._account[""sell_fee_today""] = 0.0   self._account[""asset""] += self._account[""dividend_balance_today""]   self._account[""market_value""] -= self._account[""dividend_balance_today""]   # account 计算字段   self._account[""available""] = self._account[""asset""] - self._account[""market_value""] # 当前可用余额 = 当前资产 - 当前市值   self._account[""drawable""] = self._account[""available""]   self._account[""hold_profit""] = 0.0 # 当日持仓盈亏 = 当前市值 - 当前买入成本   self._account[""float_profit_today""] = 0.0 # 当日浮动盈亏 = SUM(持仓当日浮动盈亏)   self._account[""real_profit_today""] = 0.0 # 当日实现盈亏 = SUM(持仓当日实现盈亏)   self._account[""profit_today""] = 0.0 # 当日盈亏 = 当日浮动盈亏 + 当日实现盈亏   self._account[""profit_rate_today""] = 0.0 # 当日盈亏比 = 当日盈亏 / (当前买入成本 if 当前买入成本 > 0 else 期初资产)   # 根据公式 账户权益 不需要计算 self._account[""balance""] = static_balance + market_value   self._append_to_diffs([""accounts"", ""CNY""], self._account)  def _check_insert_order(self, order, symbol, position, quote, underlying_quote=None):   # 无法计入 orderbook   if quote[""ins_class""] != ""STOCK"":    order[""last_msg""] = ""不支持的合约类型，TqSimStock 只支持股票模拟交易""    order[""status""] = ""FINISHED""   if order[""status""] == ""ALIVE"" and not self._is_in_trading_time(quote):    order[""last_msg""] = ""下单失败, 不在可交易时间段内""    order[""status""] = ""FINISHED""   if order[""status""] == ""ALIVE"" and order[""direction""] == ""BUY"":    price = _get_order_price(quote, order)    order[""frozen_balance""] = price * order[""volume_orign""]    order[""frozen_fee""] = _get_stock_fee(order[""direction""], order[""volume_orign""], price)    if order[""frozen_balance""] + order[""frozen_fee""] > self._account[""available""]:     order[""frozen_balance""] = 0.0     order[""frozen_fee""] = 0.0     order[""last_msg""] = ""开仓资金不足""     order[""status""] = ""FINISHED""   if order[""status""] == ""ALIVE"" and order[""direction""] == ""SELL"":    if position[""volume_his""] + position[""shared_volume_today""] - position[""sell_volume_today""] - position[""sell_volume_frozen""] < order[""volume_orign""]:     order[""last_msg""] = ""平仓手数不足""     order[""status""] = ""FINISHED""   if order[""status""] == ""FINISHED"":    self._append_to_diffs([""orders"", order[""order_id""]], order)  def _on_insert_order(self, order, symbol, position, quote, underlying_quote=None):   """"""记录在 orderbook""""""   if order[""direction""] == ""BUY"":    self._adjust_account_by_order(buy_frozen_balance=order[""frozen_balance""], buy_frozen_fee=order[""frozen_fee""])    self._append_to_diffs([""accounts"", ""CNY""], self._account)   else:    position[""sell_volume_frozen""] += order[""volume_orign""]    self._append_to_diffs([""positions"", symbol], position)  def _on_order_failed(self, symbol, order):   origin_frozen_balance = order[""frozen_balance""]   origin_frozen_fee = order[""frozen_fee""]   order[""frozen_balance""] = 0.0   order[""frozen_fee""] = 0.0   self._append_to_diffs([""orders"", order[""order_id""]], order)   # 调整账户和持仓   if order[""direction""] == ""BUY"":    self._adjust_account_by_order(buy_frozen_balance=-origin_frozen_balance, buy_frozen_fee=-origin_frozen_fee)    self._append_to_diffs([""accounts"", ""CNY""], self._account)   else:    position = self._positions[symbol]    position[""sell_volume_frozen""] -= order[""volume_orign""]    self._append_to_diffs([""positions"", symbol], position)  def _on_order_traded(self, order, trade, symbol, position, quote, underlying_quote):   origin_frozen_balance = order[""frozen_balance""]   origin_frozen_fee = order[""frozen_fee""]   order[""frozen_balance""] = 0.0   order[""frozen_fee""] = 0.0   order[""volume_left""] = 0   self._append_to_diffs([""trades"", trade[""trade_id""]], trade)   self._append_to_diffs([""orders"", order[""order_id""]], order)   # 调整账户和持仓   if order[""direction""] == ""BUY"":    if position[""volume""] == 0:     position[""create_date""] = quote['datetime'][:10]    self._adjust_account_by_order(buy_frozen_balance=-origin_frozen_balance, buy_frozen_fee=-origin_frozen_fee)    # 修改 position 原始字段    buy_balance = trade[""volume""] * trade[""price""]    position[""buy_volume_today""] += trade[""volume""]    position[""buy_balance_today""] += buy_balance    position[""buy_fee_today""] += trade[""fee""]    # 修改 account 原始字段    self._adjust_account_by_trade(buy_fee=trade[""fee""], buy_balance=buy_balance)    self._adjust_position_account(position, pre_last_price=trade[""price""], last_price=position[""last_price""],           buy_volume=trade[""volume""], buy_balance=buy_balance, buy_fee=trade[""fee""])   else:    position[""sell_volume_frozen""] -= order[""volume_orign""]    # 修改 position 原始字段    sell_balance = trade[""volume""] * trade[""price""]    position[""sell_volume_today""] += trade[""volume""]    position[""sell_balance_today""] += sell_balance    position[""sell_fee_today""] += trade[""fee""]    self._adjust_account_by_trade(sell_fee=trade[""fee""], sell_balance=sell_balance)    self._adjust_position_account(position, last_price=quote[""last_price""], sell_volume=trade[""volume""],           sell_balance=sell_balance, sell_fee=trade[""fee""])   self._append_to_diffs([""positions"", symbol], position)   self._append_to_diffs([""accounts"", ""CNY""], self._account)  def _on_update_quotes(self, symbol, position, quote, underlying_quote):   # 调整持仓保证金和盈亏   if position[""volume""] > 0:    if position[""last_price""] != quote[""last_price""]:     self._adjust_position_account(position, pre_last_price=position[""last_price""], last_price=quote[""last_price""])     position[""last_price""] = quote[""last_price""]   # 修改辅助变量   position[""last_price""] = quote[""last_price""]   self._append_to_diffs([""positions"", symbol], position) # 一定要返回 position，下游会用到 future_margin 字段判断修改保证金是否成功   self._append_to_diffs([""accounts"", ""CNY""], self._account)  def _adjust_position_account(self, position, pre_last_price=float(""nan""), last_price=float(""nan""), buy_volume=0, buy_balance=0, buy_fee=0, sell_volume=0, sell_balance=0, sell_fee=0):   """"""   价格变化，使得 position 中的以下计算字段需要修改，这个函数计算出需要修改的差值部分，计算出差值部分修改 position、account   有两种情况下调用   1. 委托单 FINISHED，且全部成交，分为4种：buy_open, buy_close, sell_open, sell_close   2. 行情跳动   """"""   assert [buy_volume, sell_volume].count(0) >= 1 # 只有一个大于0, 或者都是0，表示价格变化导致的字段修改   if buy_volume > 0:    position[""volume""] += buy_volume    cost = buy_balance + buy_fee    market_value = buy_volume * position[""last_price""]    position[""buy_avg_price""] = (position[""buy_balance_today""] + position[""buy_fee_today""]) / position[""buy_volume_today""]    buy_float_profit_today = (position[""volume""] - (position[""volume_his""] - position[""sell_volume_today""])) * (last_price - position[""buy_avg_price""]) # 今仓浮动盈亏 = (今持仓数量 - (昨持仓数量 - 今卖数量)) * (最新价 - 买入均价)    self._adjust_position(position, cost=cost, market_value=market_value,         sell_float_profit_today=0,         buy_float_profit_today=buy_float_profit_today, real_profit_today=0)    self._adjust_account_by_position(market_value=market_value, cost=cost,            float_profit_today=buy_float_profit_today,            real_profit_today=0)   elif sell_volume > 0:    position[""volume""] -= sell_volume    cost = -sell_volume * (position[""cost_his""] / position[""volume_his""])    market_value = -sell_volume * position[""last_price""]    real_profit_today = (sell_volume / position[""volume_his""]) * position[""sell_float_profit_today""]    sell_float_profit_today = position[""sell_float_profit_today""] - real_profit_today    self._adjust_position(position, cost=cost, market_value=market_value,         sell_float_profit_today=sell_float_profit_today,         buy_float_profit_today=0, real_profit_today=real_profit_today)    self._adjust_account_by_position(market_value=market_value, cost=cost,            float_profit_today=sell_float_profit_today,            real_profit_today=real_profit_today)   else:    market_value = position[""volume""] * last_price - position[""market_value""]    sell_float_profit_today = (position[""volume_his""] - position[""sell_volume_today""]) * (last_price - pre_last_price) # 昨仓浮动盈亏 = (昨持仓数量 - 今卖数量) * (最新价 - 昨收盘价)    buy_float_profit_today = (position[""volume""] - (position[""volume_his""] - position[""sell_volume_today""])) * (last_price - position[""buy_avg_price""]) # 今仓浮动盈亏 = (今持仓数量 - (昨持仓数量 - 今卖数量)) * (最新价 - 买入均价)    self._adjust_position(position, cost=0, market_value=market_value, sell_float_profit_today=sell_float_profit_today, buy_float_profit_today=buy_float_profit_today, real_profit_today=0)    self._adjust_account_by_position(market_value=market_value, cost=0, float_profit_today=sell_float_profit_today+buy_float_profit_today, real_profit_today=0)  # -------- 对于 position 的计算字段修改分为两类：  # 1. 针对手数相关的修改，在下单、成交时会修改  # 2. 针对盈亏、保证金、市值的修改，由于参考合约最新价，在成交、行情跳动时会修改  def _adjust_position(self, position, cost=0, market_value=0, sell_float_profit_today=0, buy_float_profit_today=0, real_profit_today=0):   # 更新 position 计算字段，根据差值更新的字段   position[""sell_float_profit_today""] += sell_float_profit_today   position[""buy_float_profit_today""] += buy_float_profit_today   position[""cost""] += cost # 当前成本 = 期初成本 + 今买金额 + 今买费用 - 今卖数量 × (期初买入成本 / 期初持仓数量)   position[""market_value""] += market_value # 当前市值 = 持仓数量 × 行情最新价   position[""float_profit_today""] += sell_float_profit_today + buy_float_profit_today # 当日浮动盈亏 = (昨持仓数量 - 今卖数量) * (最新价 - 昨收盘价) + (今持仓数量 - (昨持仓数量 - 今卖数量)) * (最新价 - 买入均价)   position[""real_profit_today""] += real_profit_today # 当日实现盈亏 = 今卖数量 * (最新价 - 昨收盘价) - 今卖费用 + 今派息金额   position[""profit_today""] += sell_float_profit_today + buy_float_profit_today + real_profit_today   position[""hold_profit""] += (market_value - cost)   position[""real_profit_total""] += real_profit_today # 累计实现盈亏 += 当日实现盈亏（成本）   position[""profit_total""] += real_profit_today + (market_value - cost) # 总盈亏 = 累计实现盈亏 + 持仓盈亏   # 当日收益率 = 当日盈亏 / ( 当前成本 if 当前成本 > 0 else 期初市值)   if position[""cost""] > 0:    position[""profit_rate_today""] = position[""profit_today""] / position[""cost""]   else:    position[""profit_rate_today""] = position[""profit_today""] / position[""market_value_his""] if position[""market_value_his""] > 0 else 0.0   # 累计收益率 = 总盈亏 / (当前成本 if 当前成本 > 0 else 期初成本)   if position[""cost""] > 0:    position[""profit_rate_total""] = position[""profit_total""] / position[""cost""]   else:    position[""profit_rate_total""] = position[""profit_total""] / position[""cost_his""] if position[""cost_his""] > 0 else 0.0  # -------- 对于 account 的修改分为以下三类  def _adjust_account_by_trade(self, buy_fee=0, buy_balance=0, sell_fee=0, sell_balance=0):   """"""由成交引起的 account 原始字段变化，account 需要更新的计算字段""""""   # account 原始字段   self._account[""buy_balance_today""] += buy_balance # 当日买入占用资金（不含费用）   self._account[""buy_fee_today""] += buy_fee # 当日买入累计费用   self._account[""sell_balance_today""] += sell_balance # 当日卖出释放资金   self._account[""sell_fee_today""] += sell_fee # 当日卖出累计费用   # account 计算字段   self._account[""available""] += (sell_balance - buy_fee - sell_fee - buy_balance)   self._account[""asset""] += (sell_balance - buy_fee - sell_fee - buy_balance)   self._account[""drawable""] = max(self._account[""available_his""] + min(0, self._account[""sell_balance_today""] - self._account[""buy_balance_today""] - self._account[""buy_fee_today""] - self._account[""buy_frozen_balance""] - self._account[""buy_frozen_fee""]), 0)  def _adjust_account_by_position(self, market_value=0, cost=0, float_profit_today=0, real_profit_today=0):   """"""由 position 变化，account 需要更新的计算字段""""""   # account 计算字段，持仓字段求和的字段   self._account[""market_value""] += market_value   self._account[""cost""] += cost   self._account[""float_profit_today""] += float_profit_today   self._account[""real_profit_today""] += real_profit_today   # account 计算字段   self._account[""asset""] += market_value # 当前资产 = 当前市值 + 当前可用余额 + 委托冻结金额 + 委托冻结费用   # 当前可取余额 = MAX( 期初余额 + MIN(0，当日卖出释放资金 - 当日买入占用资金 - 委托冻结金额) , 0)   self._account[""drawable""] = max(self._account[""available_his""] + min(0, self._account[""sell_balance_today""] - self._account[""buy_balance_today""] - self._account[""buy_fee_today""] - self._account[""buy_frozen_balance""] - self._account[""buy_frozen_fee""]), 0)   self._account[""hold_profit""] = self._account[""market_value""] - self._account[""cost""] # 当日持仓盈亏 = 当前市值 - 当前买入成本   self._account[""profit_today""] = self._account[""float_profit_today""] + self._account[""real_profit_today""] # 当日盈亏 = 当日浮动盈亏 + 当日实现盈亏   # 当日盈亏比 = 当日盈亏 / (当前买入成本 if 当前买入成本 > 0 else 期初资产)   if self._account[""cost""] > 0:    self._account[""profit_rate_today""] = self._account[""profit_today""] / self._account[""cost""]   else:    self._account[""profit_rate_today""] = self._account[""profit_today""] / self._account[""asset_his""] if self._account[""asset_his""] > 0 else 0.0  def _adjust_account_by_order(self, buy_frozen_balance=0, buy_frozen_fee=0):   """"""由 order 变化，account 需要更新的计算字段""""""   self._account[""buy_frozen_balance""] += buy_frozen_balance   self._account[""buy_frozen_fee""] += buy_frozen_fee   self._account[""available""] -= (buy_frozen_balance + buy_frozen_fee)   self._account[""drawable""] = max(self._account[""available_his""] + min(0, self._account[""sell_balance_today""] - self._account[""buy_balance_today""] - self._account[""buy_fee_today""] - self._account[""buy_frozen_balance""] - self._account[""buy_frozen_fee""]), 0) "
196,n\tqsdk\tradeable\sim\util,"n\tqsdk\tradeable\sim\util. #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'mayanqiong' from datetime import datetime from tqsdk.datetime import _get_trading_day_from_timestamp, _get_trade_timestamp TRADING_DAYS_OF_YEAR = 250 def _get_price_range(quote):  """""" 返回合约对应的买一卖一盘口价格""""""  ask_price = quote[""ask_price1""]  bid_price = quote[""bid_price1""]  if quote[""ins_class""].endswith(""INDEX""):   # 在指数交易时，使用 tick 进行回测时，backtest 发的 quote 没有买一卖一价；或者在实时行情中，指数的 quote 也没有买一卖一价   if ask_price != ask_price:    ask_price = quote[""last_price""] + quote[""price_tick""]   if bid_price != bid_price:    bid_price = quote[""last_price""] - quote[""price_tick""]  return ask_price, bid_price def _get_option_margin(quote, last_price, underlying_last_price):  """"""返回每张期权占用保证金，只有空头持仓占用保证金""""""  # 期权保证金计算公式参考深交所文档 http://docs.static.szse.cn/www/disclosure/notice/general/W020191207433397366259.pdf  if quote[""option_class""] == ""CALL"":   # 认购期权义务仓开仓保证金＝[合约最新价 + Max（12% × 合约标的最新价 - 认购期权虚值， 7% × 合约标的最新价）] × 合约单位   # 认购期权虚值＝Max（行权价 - 合约标的最新价，0）   out_value = max(quote[""strike_price""] - underlying_last_price, 0)   return (last_price + max(0.12 * underlying_last_price - out_value,         0.07 * underlying_last_price)) * quote[""volume_multiple""]  else:   # 认沽期权义务仓开仓保证金＝Min[合约最新价+ Max（12% × 合约标的最新价 - 认沽期权虚值，7% × 行权价），行权价] × 合约单位   # 认沽期权虚值＝Max（合约标的最新价 - 行权价，0）   out_value = max(underlying_last_price - quote[""strike_price""], 0)   return min(quote[""last_price""] + max(0.12 * underlying_last_price - out_value,            0.07 * quote[""strike_price""]),     quote[""strike_price""]) * quote[""volume_multiple""] def _get_premium(trade, quote):  """"""返回成交导致的权利金变化""""""  if quote[""ins_class""].endswith(""OPTION""):   premium = trade[""price""] * trade[""volume""] * quote[""volume_multiple""]   return -premium if trade[""direction""] == ""BUY"" else premium  else:   return 0 def _get_close_profit(trade, quote, position):  """"""返回成交导致的平仓盈亏变化""""""  if quote[""ins_class""].endswith(""OPTION""):   # 期权没有持仓盈亏没有持仓价，其平仓的盈亏体现在市价变化中   return 0  # 期货及其他使用持仓价计算  elif trade[""direction""] == ""SELL"":   return (trade[""price""] - position[""position_price_long""]) * trade[""volume""] * quote[""volume_multiple""]  else:   return (position[""position_price_short""] - trade[""price""]) * trade[""volume""] * quote[""volume_multiple""] def _get_commission(quote={}):  """"""返回每手手续费""""""  if quote.get(""ins_class"", """").endswith(""OPTION""):   return quote.get(""user_commission"", 10) # 期权quote没有commission字段, 设为固定10元一张, 优先采用用户设置的参数  return quote.get(""user_commission"", quote.get('commission', float('nan'))) def _get_future_margin(quote={}):  """"""返回期货每手保证金""""""  if quote.get(""ins_class"", """").endswith(""OPTION""):   return float('nan')  return quote.get(""user_margin"", quote.get(""margin"", float('nan'))) def _get_order_price(quote, order):  # order 预期成交价格  if order[""price_type""] in [""ANY"", ""BEST"", ""FIVELEVEL""]:   ask_price, bid_price = _get_price_range(quote)   return ask_price if order[""direction""] == ""BUY"" else bid_price  else:   return order[""limit_price""] def _get_stock_fee(direction, volume, price):  # 费用(BUY) = 佣金; 费用(SELL) = 佣金 + 印花税  balance = volume * price  return max(balance * 0.00025, 5.0) + (0 if direction == ""BUY"" else balance * 0.001) def _get_dividend_ratio(quote):  # 获取合约下一个交易日的送股、分红信息  timestamp = _get_trading_day_from_timestamp(_get_trade_timestamp(quote['datetime'], float('nan')) + 86400000000000) # 下一交易日  stock_dividend = _get_dividend_ratio_by_dt(quote['stock_dividend_ratio'], timestamp=timestamp)  cash_dividend = _get_dividend_ratio_by_dt(quote['cash_dividend_ratio'], timestamp=timestamp)  return stock_dividend, cash_dividend def _get_dividend_ratio_by_dt(dividend_list: list, timestamp: int) -> float:  # 从分红/送股列表中找到指定的数据返回  # ['20181102,0.400000', '20200624,0.400000', '20210716,0.400000'] '20210716'  dt = datetime.fromtimestamp(timestamp / 1000000000).strftime('%Y%m%d') # 转为 str 格式  for item in dividend_list:   if item[:8] == dt:    return float(item[9:])  return 0.0 "
197,n\tqsdk\tradeable\sim\  init ,n\tqsdk\tradeable\sim\  init . #!usr/bin/env python3 # -*- coding:utf-8 -*- __author__ = 'mayanqiong' from tqsdk.tradeable.sim.tqsim import TqSim from tqsdk.tradeable.sim.tqsim_stock import TqSimStock 
198,n\tqsdk\  pyinstaller\hook tqsd,"n\tqsdk\  pyinstaller\hook tqsd. from PyInstaller.utils.hooks import collect_data_files datas = collect_data_files('tqsdk', includes=['ctpse', 'web', 'expired_quotes.json.lzma']) "
199,n\tqsdk\  pyinstaller\  init ,n\tqsdk\  pyinstaller\  init . import os def get_hook_dirs():  return [os.path.dirname(__file__)] 
